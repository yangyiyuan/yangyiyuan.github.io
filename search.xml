<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HHVM 3.23.3 发布，高速的 PHP 执行引擎]]></title>
    <url>%2F2018%2F01%2F03%2FHHVM-3-23-3-%E5%8F%91%E5%B8%83%EF%BC%8C%E9%AB%98%E9%80%9F%E7%9A%84-PHP-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[HHVM 3.23.3 发布了，HipHop VM(HHVM)是 Facebook 推出的用来执行 PHP 代码的虚拟机，它是一个 PHP 的 JIT（Just-In- Time）编译器，同时具有产生快速代码和即时编译的优点。 更新内容： Warn about a GCC 4.9 bug Add HHI file for ext/pgsql aarch64 - slight improvement to ffs64 [AArch64] Remove extra syncing of CodeBlock from base to frontier. 完整更新内容请查看更新日志。 下载地址： Source code (zip) Source code (tar.gz)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HHVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP V5.1.0 发布]]></title>
    <url>%2F2018%2F01%2F03%2FThinkPHP-V5-1-0-%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[ThinkPHP 自诞生以来一路走来已经 12 载，初心不改，并将继续努力，感谢大家的一路支持和贡献！ 特性5.1 版本主要特性包括： 引入容器和 Facade 支持 依赖注入完善和支持更多场景 重构的（对象化）路由 路由跨域请求支持 支持注解路由 配置和路由目录独立 取消系统常量 助手函数增强 类库别名机制 模型和数据库增强 验证类增强 模板引擎改进 支持 PSR-3 日志规范 安装5.1 版本开始官方不提供下载包，请使用 composer 安装：1$ composer create-project topthink/think tp 手册官方完全开发手册 已经更新至最新 5.1的扩展也同步更新支持了（都支持composer安装），包括： topthink/think-testing topthink/think-mongo topthink/think-migration topthink/think-queue topthink/think-captcha topthink/think-image topthink/think-walkman topthink/think-swoole 以及大量的第三方类库包（不再一一列举）另外，官方已经把5.1版本的很多组件独立成composer包了（不再依赖ThinkPHP核心框架运行），包括但不限于： topthink/think-container topthink/think-orm topthink/think-validate topthink/think-template topthink/think-log topthink/think-cache]]></content>
      <categories>
        <category>PHP</category>
        <category>ThinkPHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CakePHP 3.5.9 发布，PHP 开发框架]]></title>
    <url>%2F2017%2F12%2F28%2FCakePHP-3-5-9-%E5%8F%91%E5%B8%83%EF%BC%8CPHP-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[CakePHP 3.5.9 已发布。CakePHP 是一个运用了诸如 ActiveRecord、Association Data Mapping、Front Controller 和 MVC 等著名设计模式的快速开发框架。该项目主要目标是提供一个可以让各种层次的 PHP 开发人员快速地开发出健壮的 Web 应用，而又不失灵活性。 主要更新内容： Updated API documentation. SQLServer driver allows port to be defined now. Improved __debugInfo() output of EventManager. Improved performance of route connection. Improved typehinting adherance in Session implementations. 详情请查看 ChangeLog。 下载地址： cakephp-3-5-9.zip Source code (zip) Source code (tar.gz)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CakePHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phalcon7 发布 Dao7-1.3.2，改进事件机制]]></title>
    <url>%2F2017%2F12%2F19%2FPhalcon7-%E5%8F%91%E5%B8%83-Dao7-1-3-2%EF%BC%8C%E6%94%B9%E8%BF%9B%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[模型的属性方法增加前缀“__”。改进事件机制，能够针对部分操作对应事件进行拦截，并停止继续运行：1234567891011121314151617181920212223242526272829303132333435$eventsManager = new Phalcon\Events\Manager();$eventsManager-&gt;attach(&apos;model:beforeQuery&apos;, function($event, $model, $data, $prevdata) &#123; if (!$prevdata) &#123; return [&apos;data&apos; =&gt; 1]; &#125; return $prevdata;&#125;);$eventsManager-&gt;attach(&apos;model:beforeQuery&apos;, function($event, $model, $data, $prevdata) &#123; if (!$prevdata) &#123; return []; &#125; $prevdata[&apos;data2&apos;] = 2; return $prevdata;&#125;);$di = new Phalcon\Di\FactoryDefault;$di-&gt;set(&apos;modelsManager&apos;, function() use ($eventsManager) &#123; $modelsManager = new Phalcon\Mvc\Model\Manager(); $modelsManager-&gt;setEventsManager($eventsManager); return $modelsManager;&#125;, true);class Robots extends Phalcon\Mvc\Model &#123; public function beforeQuery($event, $data, $prevdata) &#123; if (!$prevdata) &#123; return []; &#125; $prevdata[&apos;data3&apos;] = 3; return $prevdata; &#125;&#125;var_dump(Robots::find()); 返回：12345678array(2) &#123; [&quot;data&quot;]=&gt; int(1) [&quot;data2&quot;]=&gt; int(2) [&quot;data3&quot;]=&gt; int(3)&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Phalcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 上关于npm一些令我窒息的操作]]></title>
    <url>%2F2017%2F12%2F13%2FMac-%E4%B8%8A%E5%85%B3%E4%BA%8Enpm%E4%B8%80%E4%BA%9B%E4%BB%A4%E6%88%91%E7%AA%92%E6%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天想学个前端框架来着，需要npm安装一些环境，搞来搞去各种module.js报错，一咬牙，劳资从头再来。 安装nvm目前我更多的使用nvm来进行node版本管理，它会安装相应版本的npm。执行如下命令安装nvm：1$ brew install nvm 安装成功，按照提示做一些附属操作，不细说。 安装node及npm首先删除node文件，完全卸载node和npm，让那些扯淡的报错统统go out！1$ sudo rm -rf /usr/local/&#123;lib/node&#123;,/.npm,_modules&#125;,bin,share/man&#125;/&#123;npm*,node*,man1/node*&#125; 然后进行安装：123$ brew link node$ brew uninstall node$ brew install node 安装成功后测试：1$ npm install -g grunt-cli 如果安装成功，那么恭喜你node，npm，grunt均安装成功。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPUnit 6.5.3 发布，PHP 单元测试框]]></title>
    <url>%2F2017%2F12%2F07%2FPHPUnit-6-5-3-%E5%8F%91%E5%B8%83%EF%BC%8CPHP-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%2F</url>
    <content type="text"><![CDATA[PHPUnit 6.5.3 已发布，这是一个修复版本，修复了修正了配置 forceCoversAnnotation =“true” 时 PHPT 测试的问题。PHPUnit 是一个面向程序员的 PHP 测试框架。是 xUnit 单元测试框架体系结构的一员。PHPUnit 6.2 系列需要 PHP 7 及以上，强烈推荐使用最新版本的 PHP。PHPUnit 需要使用 dom 和 json 扩展，它们通常是默认启用的。PHPUnit 还需要 pcre、reflection、spl 扩展。这些标准扩展默认启用，并且除非修改 PHP 的构建系统和 C 源代码，否则无法禁用它们。代码覆盖率分析报告功能需要 Xdebug（2.5.0以上）与 tokenizer 扩展。生成 XML 格式的报告需要有 xmlwriter 扩展。 下载地址： Source code (zip) Source code (tar.gz)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.2.0 正式发布，多项内容修复]]></title>
    <url>%2F2017%2F11%2F29%2FPHP-7-2-0-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E5%A4%9A%E9%A1%B9%E5%86%85%E5%AE%B9%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[PHP 7.2.0 正式发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。该版本主要还是修复 bug，改进日志如下： 30 Nov 2017, PHP 7.2.0 BCMath: Fixed bug #46564 (bcmod truncates fractionals). (liborm85) CLI: Fixed bug #74849 (Process is started as interactive shell in PhpStorm). (Anatol) Fixed bug #74979 (Interactive shell opening instead of script execution with ##f flag). (Anatol) CLI server: Fixed bug #60471 (Random “Invalid request (unexpected EOF)” using a router script). (SammyK) Core: Added ZEND_COUNT, ZEND_GET_CLASS, ZEND_GET_CALLED_CLASS, ZEND_GET_TYPE, ZEND_FUNC_NUM_ARGS, ZEND_FUNC_GET_ARGS instructions, to implement corresponding builtin functions. (Dmitry) “Countable” interface is moved from SPL to Core. (Dmitry) Added ZEND_IN_ARRAY instruction, implementing optimized in_array() builtin function, through hash lookup in flipped array. (Dmitry) Removed IS_TYPE_IMMUTABLE (it’s the same as COPYABLE &amp; !REFCOUNTED). (Dmitry) Removed the sql.safe_mode directive. (Kalle) Removed support for Netware. (Kalle) Renamed ReflectionClass::isIterateable() to ReflectionClass::isIterable() (alias original name for BC). (Sara) Fixed bug #54535 (WSA cleanup executes before MSHUTDOWN). (Kalle) Implemented FR #69791 (Disallow mail header injections by extra headers) (Yasuo) Implemented FR #49806 (proc_nice() for Windows). (Kalle) Fix pthreads detection when cross##compiling (ffontaine) Fixed memory leaks caused by exceptions thrown from destructors. (Bob, Dmitry). Fixed bug #73215 (uniqid() should use better random source). (Yasuo) Implemented FR #72768 (Add ENABLE_VIRTUAL_TERMINAL_PROCESSING flag for php.exe). (Michele Locati) Implemented “Convert numeric keys in object/array casts” RFC, fixes bugs #53838, #61655, #66173, #70925, #72254, etc. (Andrea) Implemented “Deprecate and Remove Bareword (Unquoted) Strings” RFC. (Rowan Collins) Raised minimum supported Windows versions to Windows 7/Server 2008 R2. (Anatol) Implemented minor optimization in array_keys/array_values(). (Sara) Added PHP_OS_FAMILY constant to determine on which OS we are. (Jan Altensen) Fixed bug #73987 (Method compatibility check looks to original definition and not parent). (pmmaga) Fixed bug #73991 (JSON_OBJECT_AS_ARRAY not respected). (Sara) Fixed bug #74053 (Corrupted class entries on shutdown when a destructor spawns another object). (jim at commercebyte dot com) Fixed bug #73971 (Filename got limited to MAX_PATH on Win32 when scan directory). (Anatol) Fixed bug #72359, bug #72451, bug #73706, bug #71115 and others related to interned strings handling in TS builds. (Anatol, Dmitry) Implemented “Trailing Commas In List Syntax” RFC for group use lists only. (Sammy Kaye Powers) Fixed bug #74269 (It’s possible to override trait property with different loosely##equal value). (pmmaga) Fixed bug #61970 (Restraining __construct() access level in subclass gives a fatal error). (pmmaga) Fixed bug #63384 (Cannot override an abstract method with an abstract method). (pmmaga, wes) Fixed bug #74607 (Traits enforce different inheritance rules). (pmmaga) Fixed misparsing of abstract unix domain socket names. (Sara) Change PHP_OS_FAMILY value from “OSX” to “Darwin”. (Sebastian, Kalle) Allow loading PHP/Zend extensions by name in ini files (extension=). (francois at tekwire dot net) Added object type annotation. (brzuchal) Fixed bug #74815 (crash with a combination of INI entries at startup). (Anatol) Fixed bug #74836 (isset on zero##prefixed numeric indexes in array broken). (Dmitry) Added new VM instuctions ISSET_ISEMPTY_CV and UNSET_CV. Previously they were implemented as ISSET_ISEMPTY_VAR and UNSET_VAR variants with ZEND_QUICK_SET flag. (Nikita, Dmitry) Fixed bug #49649 (unserialize() doesn’t handle changes in property visibility). (pmmaga) Fixed #74866 (extension_dir = “./ext” now use current directory for base). (Francois Laupretre) Implemented FR #74963 (Improved error message on fetching property of non##object). (Laruence) Fixed Bug #75142 (buildcheck.sh check for autoconf version needs to be updated for v2.64). (zizzy at zizzy dot net, Remi) Fixed bug #74878 (Data race in ZTS builds). (Nikita, Dmitry) Fixed bug #75515 (“stream_copy_to_stream” doesn’t stream anymore). (Sara) cURL: Fixed bug #75093 (OpenSSL support not detected). (Remi) Better fix for #74125 (use pkg##config instead of curl##config). (Remi) Date: Fixed bug #55407 (Impossible to prototype DateTime::createFromFormat). (kelunik) Implemented FR #71520 (Adding the DateTime constants to the DateTimeInterface interface). (Majkl578) Fixed bug #75149 (redefinition of typedefs ttinfo and t1info). (Remi) Fixed bug #75222 (DateInterval microseconds property always 0). (jhdxr) Dba: Fixed bug #72885 (flatfile: dba_fetch() fails to read replaced entry). (Anatol) DOM: Implement #74837 (Implement Countable for DomNodeList and DOMNamedNodeMap). (Andreas Treichel) EXIF: Added support for vendor specific tags for the following formats: Samsung, DJI, Panasonic, Sony, Pentax, Minolta, Sigma/Foveon, AGFA,Kyocera, Ricoh &amp; Epson. (Kalle) Fixed bug #72682 (exif_read_data() fails to read all data for some images). (Kalle) Fixed bug #71534 (Type confusion in exif_read_data() leading to heap overflow in debug mode). (hlt99 at blinkenshell dot org, Kalle) Fixed bug #68547 (Exif Header component value check error). (sjh21a at gmail dot com, Kalle) Fixed bug #66443 (Corrupt EXIF header: maximum directory nesting level reached for some cameras). (Kalle) Fixed Redhat bug #1362571 (PHP not returning full results for exif_read_data function). (Kalle) Implemented #65187 (exif_read_data/thumbnail: add support for stream resource). (Kalle) Deprecated the read_exif_data() alias. (Kalle) Fixed bug #74428 (exif_read_data(): “Illegal IFD size” warning occurs with correct exif format). (bradpiccho at gmail dot com, Kalle) Fixed bug #72819 (EXIF thumbnails not read anymore). (Kalle) Fixed bug #62523 (php crashes with segfault when exif_read_data called). (Kalle) Fixed bug #50660 (exif_read_data(): Illegal IFD offset (works fine with other exif readers). (skinny dot bravo at gmail dot com, Kalle) Fileinfo: Upgrade bundled libmagic to 5.31. (Anatol) FPM: Configuration to limit fpm slow log trace callers. (Sannis) Fixed bug #75212 (php_value acts like php_admin_value). (Remi) FTP: Implement MLSD for structured listing of directories. (blar) Added ftp_append() function. (blar) GD: Implemented imageresolution as getter and setter (Christoph) Fixed bug #74744 (gd.h: stdarg.h include missing for va_list use in gdErrorMethod). (rainer dot jung at kippdata dot de, cmb) Fixed bug #75111 (Memory disclosure or DoS via crafted .bmp image). (cmb) GMP: Fixed bug #70896 (gmp_fact() silently ignores non##integer input). (Sara) Hash: Changed HashContext from resource to object. (Rouven Weßling, Sara) Disallowed usage of non##cryptographic hash functions with HMAC and PBKDF2. (Andrey Andreev, Nikita) Fixed Bug #75284 (sha3 is not supported on bigendian machine). (Remi) IMAP: Fixed bug #72324 (imap_mailboxmsginfo() return wrong size). (ronaldpoon at udomain dot com dot hk, Kalle) Intl: Fixed bug #63790 (test using Spoofchecker which may be unavailable). (Sara) Fixed bug #75378 ([REGRESSION] IntlDateFormatter::parse() does not change $position argument). (Laruence) JSON: Add JSON_INVALID_UTF8_IGNORE and JSON_INVALID_UTF8_SUBSTITUTE options for json_encode and json_decode to ignore or replace invalid UTF##8 byte sequences ## it addresses request #65082. (Jakub Zelenka) Fixed bug #75185 (Buffer overflow in json_decode() with JSON_INVALID_UTF8_IGNORE or JSON_INVALID). (Jakub Zelenka) Fixed bug #68567 (JSON_PARTIAL_OUTPUT_ON_ERROR can result in JSON with null key). (Jakub Zelenka) LDAP: Implemented FR #69445 (Support for LDAP EXOP operations) Fixed support for LDAP_OPT_SERVER_CONTROLS and LDAP_OPT_CLIENT_CONTROLS in ldap_get_option Fixed passing an empty array to ldap_set_option for client or server controls. Mbstring: Implemented request #66024 (mb_chr() and mb_ord()). (Masakielastic, Yasuo) Implemented request #65081 (mb_scrub()). (Masakielastic, Yasuo) Implemented request #69086 (enhancement for mb_convert_encoding() that handles multibyte replacement char nicely). (Masakielastic, Yasuo) Added array input support to mb_convert_encoding(). (Yasuo) Added array input support to mb_check_encoding(). (Yasuo) Fixed bug #69079 (enhancement for mb_substitute_character). (masakielastic) Update to oniguruma version 6.3.0. (Remi) Fixed bug #69267 (mb_strtolower fails on titlecase characters). (Nikita) Mcrypt: The deprecated mcrypt extension has been moved to PECL. (leigh) Opcache: Added global optimisation passes based on data flow analysis using Single Static Assignment (SSA) form: Sparse Conditional Constant Propagation (SCCP), Dead Code Elimination (DCE), and removal of unused local variables (Nikita, Dmitry) Fixed incorect constant conditional jump elimination. (Dmitry) Fixed bug #75230 (Invalid opcode 49/1/8 using opcache). (Laruence) Fixed bug (assertion fails with extended info generated). (Laruence) Fixed bug (Phi sources removel). (Laruence) Fixed bug #75370 (Webserver hangs on valid PHP text). (Laruence) Fixed bug #75357 (segfault loading WordPress wp##admin). (Laruence) OpenSSL: Use TLS_ANY for default ssl:// and tls:// negotiation. (kelunik) Fix leak in openssl_spki_new(). (jelle at vdwaa dot nl) Added openssl_pkcs7_read() and pk7 parameter to openssl_pkcs7_verify(). (jelle at vdwaa dot nl) Add ssl security_level stream option to support OpenSSL security levels. (Jakub Zelenka). Allow setting SNI cert and private key in separate files. (Jakub Zelenka) Fixed bug #74903 (openssl_pkcs7_encrypt() uses different EOL than before). (Anatol) Automatically load OpenSSL configuration file. (Jakub Zelenka) PCRE: Added support for PCRE JIT fast path API. (dmitry) Fixed bug #61780 (Inconsistent PCRE captures in match results). (cmb) Fixed bug #74873 (Minor BC break: PCRE_JIT changes output of preg_match()). (Dmitry) Fixed bug #75089 (preg_grep() is not reporting PREG_BAD_UTF8_ERROR after first input string). (Dmitry) Fixed bug #75223 (PCRE JIT broken in 7.2). (Dmitry) Fixed bug #75285 (Broken build when system libpcre don’t have jit support). (Remi) phar: Fixed bug #74196 (phar does not correctly handle names containing dots). (mhagstrand) PDO: Add “Sent SQL” to debug dump for emulated prepares. (Adam Baratz) Add parameter types for national character set strings. (Adam Baratz) PDO_DBlib: Fixed bug #73234 (Emulated statements let value dictate parameter type). (Adam Baratz) Fixed bug #73396 (bigint columns are returned as strings). (Adam Baratz) Expose DB##Library version as \PDO::DBLIB_ATTR_VERSION attribute on \PDO instance. (Adam Baratz) Add test coverage for bug #72969. (Jeff Farr) PDO_OCI: Fixed Bug #74537 (Align ####with##pdo##oci configure option with ####with##oci8 syntax). (Tianfang Yang) PDO_Sqlite Switch to sqlite3_prepare_v2() and sqlite3_close_v2() functions (rasmus) PHPDBG Added extended_value to opcode dump output. (Sara) Session: Fixed bug #73461 (Prohibit session save handler recursion). (Yasuo) PR #2233 Removed register_globals related code and “!” can be used as $_SESSION key name. (Yasuo) Improved bug #73100 fix. ‘user’ save handler can only be set by session_set_save_handler() Fixed bug #74514 (5 session functions incorrectly warn when calling in read##only/getter mode). (Yasuo) Fixed bug #74936 (session_cache_expire/cache_limiter/save_path() trigger a warning in read mode). (morozov) Fixed bug #74941 (session fails to start after having headers sent). (morozov) Sodium: New cryptographic extension Added missing bindings for libsodium &gt; 1.0.13. (Frank) SPL: Fixed bug #71412 (Incorrect arginfo for ArrayIterator::__construct). (tysonandre775 at hotmail dot com) Added spl_object_id(). (Tyson Andre) SQLite3: Implement writing to blobs. (bohwaz at github dot com) Update to Sqlite 3.20.1. (cmb) Standard: Fixed bug #69442 (closing of fd incorrect when PTS enabled). (jaytaph) Fixed bug #74300 (unserialize accepts two plus/minus signs for float number exponent part). (xKerman) Compatibility with libargon2 versions 20161029 and 20160821. (charlesportwoodii at erianna dot com) Fixed Bug #74737 (mysqli_get_client_info reflection info). (mhagstrand at gmail dot com) Add support for extension name as argument to dl(). (francois at tekwire dot net) Fixed bug #74851 (uniqid() without more_entropy performs badly). (Emmanuel Dreyfus) Fixed bug #74103 (heap##use##after##free when unserializing invalid array size). (Nikita) Fixed bug #75054 (A Denial of Service Vulnerability was found when performing deserialization). (Nikita) Fixed bug #75170 (mt_rand() bias on 64##bit machines). (Nikita) Fixed bug #75221 (Argon2i always throws NUL at the end). (cmb) Streams: Default ssl/single_dh_use and ssl/honor_cipher_order to true. (kelunik) XML: Moved utf8_encode() and utf8_decode() to the Standard extension. (Andrea) XMLRPC: Use Zend MM for allocation in bundled libxmlrpc (Joe) ZIP: Add support for encrypted archives. (Remi) Use of bundled libzip is deprecated, ####with##libzip option is recommended. (Remi) Fixed Bug #73803 (Reflection of ZipArchive does not show public properties). (Remi) ZipArchive implements countable, added ZipArchive::count() method. (Remi) Fix segfault in php_stream_context_get_option call. (Remi) Fixed bug #75143 (new method setEncryptionName() seems not to exist in ZipArchive). (Anatol) zlib: Expose inflate_get_status() and inflate_get_read_len() functions. (Matthew Trescott) 下载地址： http://php.net/distributions/php-7.2.0.tar.gz]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel v5.5.22 发布，PHP 开发框架]]></title>
    <url>%2F2017%2F11%2F29%2FLaravel-v5-5-22-%E5%8F%91%E5%B8%83%EF%BC%8CPHP-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Laravel 5.5.22 已发布，Laravel 是一套简洁、优雅的 PHP Web 开发框架。它可以让你从面条一样杂乱的代码中解脱出来；它可以帮你构建一个完美的网络 APP ，而且每行代码都可以简洁、富于表达力。此次更新内容： 新增： Added response() and download() methods to file system (#22089) Added complete temporary table support (#22110) Added Mode::newQueryForRestoration() method (#22119) 修改： Updated depreciated MailFake::queue() method signature (#22072) Use MEDIUMTEXT instead of TEXT for database cache values (MySQL only) (#22091) Include the name of the scheduled job in the output email subject (#22098) 修复： Fixed HasManyThrough relation with custom intermediate and local keys when used in whereHas()(#22071, 3788cbd) Fixed SQL Server handling of DATETIME columns (#22052) Return default value from old() when session isn’t available (#22082) 删除： Removed between operator from basic where clauses (#22182) 下载地址： Source code (zip) Source code (tar.gz) 完整更新内容请查看发布主页。]]></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.1.12 正式发布，多项内容修复]]></title>
    <url>%2F2017%2F11%2F23%2FPHP-7-1-12-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E5%A4%9A%E9%A1%B9%E5%86%85%E5%AE%B9%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[PHP 7.1.12 正式发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 主线版 1.13.7 发布，修复了部分 Bug]]></title>
    <url>%2F2017%2F11%2F22%2FNginx-%E4%B8%BB%E7%BA%BF%E7%89%88-1-13-7-%E5%8F%91%E5%B8%83%EF%BC%8C%E4%BF%AE%E5%A4%8D%E4%BA%86%E9%83%A8%E5%88%86-Bug%2F</url>
    <content type="text"><![CDATA[Nginx 1.13.7 已发布，该版本是 mainline 版，即通常说的开发版。本次更新主要是修复了 bug，详细如下： Bugfix: in the $upstream_status variable. Bugfix: a segmentation fault might occur in a worker process if a backend returned a “101 Switching Protocols” response to a subrequest. Bugfix: a segmentation fault occurred in a master process if a shared memory zone size was changed during a reconfiguration and the reconfiguration failed. Bugfix: in the ngx_http_fastcgi_module. Bugfix: nginx returned the 500 error if parameters without variables were specified in the “xslt_stylesheet” directive. Workaround: “gzip filter failed to use preallocated memory” alerts appeared in logs when using a zlib library variant from Intel. Bugfix: the “worker_shutdown_timeout” directive did not work when using mail proxy and when proxying WebSocket connections. 下载地址：http://nginx.org/en/download.html点此查看完整更新日志]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CakePHP 2.10.5 发布，PHP 开发框架]]></title>
    <url>%2F2017%2F11%2F22%2FCakePHP-2-10-5-%E5%8F%91%E5%B8%83%EF%BC%8CPHP-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[CakePHP 是一个运用了诸如 ActiveRecord、Association Data Mapping、Front Controller 和 MVC 等著名设计模式的快速开发框架。该项目主要目标是提供一个可以让各种层次的 PHP 开发人员快速地开发出健壮的 Web 应用，而又不失灵活性。CakePHP 2.10.5 已发布，这是修复了几个社区报告的问题的 2.10 分支的维护版本。更新内容如下： Bug 修复和新特性2.10.5 包括以下的更改内容，查看更新日志以了解每个提交包含的内容 Fix fallback domain lookups not working in Validation::email(). 改进 API 文档 下载地址 Source code (zip) Source code (tar.gz)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CakePHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.0.26 正式发布，多项内容修复]]></title>
    <url>%2F2017%2F11%2F22%2FPHP-7-0-26-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E5%A4%9A%E9%A1%B9%E5%86%85%E5%AE%B9%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[PHP 7.0.26 正式发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下：23 Nov 2017 PHP 7.0.26 Core: Fixed bug #75420 (Crash when modifing property name in __isset for BP_VAR_IS). (Laruence) Fixed bug #75368 (mmap/munmap trashing on unlucky allocations). (Nikita,Dmitry) CLI: Fixed bug #75287 (Builtin webserver crash after chdir in a shutdown function). (Laruence) Enchant: Fixed bug #53070 (enchant_broker_get_path crashes if no path is set). (jelle van der Waa, cmb) Fixed bug #75365 (Enchant still reports version 1.1.0). (cmb) Exif: Fixed bug #75301 (Exif extension has built in revision version). (Peter Kokot) GD: Fixed bug #65148 (imagerotate may alter image dimensions). (cmb) Fixed bug #75437 (Wrong reflection on imagewebp). (Fabien Villepinte) intl: Fixed bug #75317 (UConverter::setDestinationEncoding changes source instead of destination). (andrewnester) interbase: Fixed bug #75453 (Incorrect reflection for ibase_[p]connect). (villfa) Mysqli: Fixed bug #75434 (Wrong reflection for mysqli_fetch_all function). (Fabien Villepinte) OCI8: Fixed valgrind issue. (Tianfang Yang) Opcache: Fixed bug #75373 (Warning Internal error: wrong size calculation). (Laruence, Dmitry) OpenSSL: Fixed bug #75363 (openssl_x509_parse leaks memory). (Bob, Jakub Zelenka) Fixed bug #75307 (Wrong reflection for openssl_open function). (villfa) PGSQL: Fixed bug #75419 (Default link incorrectly cleared/linked by pg_close()). (Sara) SOAP: Fixed bug #75464 (Wrong reflection on SoapClient::__setSoapHeaders). (villfa) Zlib: Fixed bug #75299 (Wrong reflection on inflate_init and inflate_add). (Fabien Villepinte) 下载链接：http://php.net/distributions/php-7.1.12.tar.gz]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PV UV IP 的区别]]></title>
    <url>%2F2017%2F11%2F21%2FPV-UV-IP-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[作为大部分开发程序员，日常交流或者面试的时候，很多小伙伴会问你现在负责的项目 PV 是多少啊？UV 是多少啊？IP 是多少的？有些人或许知道这三者的区别，根本接触不到，有些新手可能根本就不了解这个感念，下边分别阐述一下三个关键词的释义和区别。 PV （page view，页面浏览量）PV（page view）即页面浏览量；用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计。 UV （Unique Visitor，独立访客）UV (unique visitor)，指某站点被多少台电脑访问过，以用户电脑的Cookie作为统计依据。 IP (Internet Protocol，独立IP数)IP (Internet Protocol)访问过某站点的IP总数，以用户的IP地址作为统计依据。 PV UV IP 区别 PV即页面访问量，每打开一次页面PV计数+1，刷新页面也是。 UV即独立访客量，一台电脑终端为一个访客。 IP即独立 IP 访问量，计算是以一个独立的IP在一个计算时段内访问网站计算为1次IP访问数。在同一个计算时段内不管这个IP访问多少次均计算为1次。计算段自己定义，不过多追究。 场景理解场景一 ADSL(宽带)上网的用户一个用户有可能在一天之内重复访问某站点，如果他在同一台电脑上，并且IP没有变化的情况下，那么这个用户为该站点贡献了一个独立IP量，一个独立访客量，而PV则是随着他的浏览在不断增加；如果他在中途在不改变电脑的情况下，掉线了一次，重新连上后IP发生了变化，之后他又访问了该站点，那么这个用户为该站点贡献了两个IP数，一个独立访客数。 场景二 网吧、单位、学校上网的用户这些场所一般都是采用局域网共享上网的方式，只有一个IP地址接入互联网，此种情况就有可能出现独立访客数大于独立IP数，比如某单位内有多人访问A站点，但是整个单位的公网IP出口就只有一个，那么无论该单位里在当日有多少人次访问A站点，这些用户为A站点贡献的独立IP数为1，除非该单位的IP地址发生了变化，相反，这些用户为A站点带来的独立访客数就是该单位内当日访问A站点的实际人数了。 由此可见，独立访客比独立IP更具说服力，只不过我们平时比较关心独立IP罢了。一个网站的独立IP数与独立访客数是相近的，有可能独立IP数&gt;独立访客数，也有可能独立IP数&lt;独立访客数，当然也有可能是相等的，这取决于网站的用户访问情况。而PV则是永远都是大于等于独立IP和独立访客的，因为PV是重复统计的。 场景三 UV 和 IP的区别和联系UV 高于IP数的时候正常是以下这种状况：例如一个局域网对外是相同的一个IP，但是有10个人同时访问，那么这个时候，UV 为10，独立P仅为1； IP高于独立访客的时候正常是以下这种状况：一个用户，上网的时候频繁掉线，拔号10次均打开了受统计网站，此时，独立访客仅计为1，而IP数则被计为10。]]></content>
      <categories>
        <category>-计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HHVM 3.23 发布，高速的 PHP 执行引擎]]></title>
    <url>%2F2017%2F11%2F21%2FHHVM-3-23-%E5%8F%91%E5%B8%83%EF%BC%8C%E9%AB%98%E9%80%9F%E7%9A%84-PHP-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[HHVM 3.23 已发布，此版本包含新功能、错误修复、性能改进和支持未来改进的工作。 有以下值得关注的更新： optional shape fields 现在与 nullable shape fields 不同，有关帮助迁移的详细信息和工具，请参阅 3.22 发布公告。 支持 VSCode 语言服务器协议，这将很快被 Nuclide 的 Hack 整合使用 函数可能不再命名为 using()，因为这将与即将到来的 using 特性相冲突 支持使类型检查器完全忽略某些文件；这是通过 ignored_paths .hhconfig 实现的，其中包含一个正则表达式数组 - 例如，ignored_paths = [ “vendor/.*tests?/“ 现在支持元组常量 方法调用现在支持括号表达式 修复了一些需要中断(Ctrl-C) hh_client的情况 支持针对 OpenSSL 1.1 进行构建，例如 Debian Stretch，Ubuntu Zesty 和 Ubuntu Artful Hack 的实验性 bytecode emitter 替代方案 即将到来的变更：Call-Time Pass-By-ReferenceHHVM 3.24 将要求引用参数在调用点处标记 - 例如：123function foo(array&lt;string&gt; $bar): void &#123; sort(&amp;$bar);&#125; 3.23 中的 Hack 允许使用这种语法，但不需要这种要求。可以通过在 .hhconfig 中将 safe_pass_by_ref 添加到 enable_experimental_tc_features 来选择加入这种要求。 Lambda 类型推断在 HHVM 3.24 中，将使用预期的 lambda 类型来改进它们；例如，下面的代码没有错误：123456789101112131415161718192021&lt;?hh // strictclass MyClass &#123;&#125;class MyClosureRunner&lt;-T&gt; &#123; public function __construct(private (function(T): string) $closure) &#123;&#125;&#125;function expectsMyClosureRunnerMyClass( MyClosureRunner&lt;MyClass&gt; $x,): MyClosureRunner&lt;MyClass&gt; &#123; return $x;&#125;function getThing1(): MyClosureRunner&lt;MyClass&gt; &#123; $var = expectsMyClosureRunnerMyClass( new MyClosureRunner( function(/* MyClass */ $arg) &#123; $arg-&gt;missing_method(); return &quot;ok&quot;; &#125;, ), ); return $var;&#125; 在 3.24 中，或者在 .hhconfig 中使用 enable_experimental_tc_features=contextual_inference，typechecker 会引发以下错误：123test.php:19:15,28: Could not find method missing_method in an object of type MyClass (Typing[4053]) test.php:10:19,25: This is why I think it is an object of type MyClass test.php:3:7,13: Declaration of MyClass is here 更新内容较多，详情请查看发布主页。目前，3.23 的最新修正版 3.23.2 也已发布。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HHVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CakePHP 3.5.6 发布，PHP 开发框架]]></title>
    <url>%2F2017%2F11%2F20%2FCakePHP-3-5-6-%E5%8F%91%E5%B8%83%EF%BC%8CPHP-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[CakePHP 3.5.6 已发布。CakePHP 是一个运用了诸如 ActiveRecord、Association Data Mapping、Front Controller 和 MVC 等著名设计模式的快速开发框架。该项目主要目标是提供一个可以让各种层次的 PHP 开发人员快速地开发出健壮的 Web 应用，而又不失灵活性。此版本更新内容： Iterating subclasses of ArrayIterator that include CollectionTrait retains the original class fixing use of methods defined on the subclass. Response::__debugInfo() includes the response body now. Http\Client creates response objects in a separate method making response creation easier to extend. SQL expressions no longer include double parenthesis when nesting expressions. View subdirectories are no longer doubled when RequestHandlerComponent and view classes using subDir property are used together. Middleware can now be registered in RouteBuilder using a string classname. Protocol relative string URLs are now properly HTML encoded by UrlHelper. 更多内容请查看发布说明。 下载地址： cakephp-3-5-6.zip Source code (zip) Source code (tar.gz)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CakePHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPUnit 5.7.25 发布，PHP 单元测试框架]]></title>
    <url>%2F2017%2F11%2F15%2FPHPUnit-5-7-25-%E5%8F%91%E5%B8%83%EF%BC%8CPHP-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[PHPUnit 5.7.25 已发布，这是一个小的修复版本，修复了 #2859 的问题。PHPUnit 是一个面向程序员的 PHP 测试框架。是 xUnit 单元测试框架体系结构的一员。PHPUnit 需要使用 dom 和 json 扩展，它们通常是默认启用的。PHPUnit 还需要 pcre、reflection、spl 扩展。这些标准扩展默认启用，并且除非修改 PHP 的构建系统和 C 源代码，否则无法禁用它们。代码覆盖率分析报告功能需要 Xdebug（2.5.0以上）与 tokenizer 扩展。生成 XML 格式的报告需要有 xmlwriter 扩展。 下载地址： Source code (zip) Source code (tar.gz)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress 4.9 RC3 发布，正式版往后推迟]]></title>
    <url>%2F2017%2F11%2F15%2FWordPress-4-9-RC3-%E5%8F%91%E5%B8%83%EF%BC%8C%E6%AD%A3%E5%BC%8F%E7%89%88%E5%BE%80%E5%90%8E%E6%8E%A8%E8%BF%9F%2F</url>
    <content type="text"><![CDATA[WordPress 4.9 正式版原计划于2017 年 11 月 14 日晚上 11点（世界协调时）发布，也就是北京时间 11 月 15 日早上 7 点发布，但由于发现小工具内短代码等问题，开发团队决定将 4.9 正式版发布日期推迟一天，即计划于北京时间2017年11月16日发布。也因此，开发团队发布了 WordPress 4.9 RC3 版本。这是一个计划外的版本，由于发现了 RC1 和 RC2 版本中存在的一些问题，临时决定发布此版本。关于 RC3 版本的改进，主要体现于： 在切换编辑器的可视化和文本选项卡时，同步光标位置。 重写主题自定义面板中附加 CSS 编辑器的错误提示功能。 在主题自定义面板中，给自定义链接添加导航菜单条目。 主题自定义面板的定期发布的自定义草稿功能。 自定义面板中所做修改的自动保存版本功能。 关于页面的样式。 完整内容可查看发布主页。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Highcharts 6.0.3 发布，纯 Javascript 图表库]]></title>
    <url>%2F2017%2F11%2F15%2FHighcharts-6-0-3-%E5%8F%91%E5%B8%83%EF%BC%8C%E7%BA%AF-Javascript-%E5%9B%BE%E8%A1%A8%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Highcharts 6.0.3 已发布，带来了全新的 dataLabels.filter 选项，用于不使用格式化程序的情况下筛选数据标签。该版本还修复了大量 bug : 修复在区域范围内添加点时动画出错的问题。 改进在 ES6 中加载 Highcharts 的相关文档。 修复热点图在 boost 模式下未正确裁剪的问题。 修复在某些浏览器中没有焦点指示器的问题。 修复 wordcloud 中的 font-size 未设置像素，导致 Firefox 渲染出来的所有词句大小相同的问题。 修复 minPointLength 在某些情况下不正确的问题。 改进 xAxis 的文档。 修复当试图导出数据时没有标题的图表出现错误的问题。 …… 完整更新内容请查阅发行说明。 Highcharts 6 包含 15 种新的图表系列类型，包括 Sankey diagram（桑基图）、Stream graph、Sunburst（旭日图）、Variwide Charts、Parallel coordinates、Variable radius pie、Vector plot、Wind-barbs、X-range 等。 下载地址：https://www.highcharts.com/download]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Highcharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP V5.0.12 暨 5.1.0 RC3 版本发布]]></title>
    <url>%2F2017%2F11%2F06%2FThinkPHP-V5-0-12-%E6%9A%A8-5-1-0-RC3-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[V5.1.0版本是继5.0版本之后又一个重大版本，ThinkPHP5.1在5.0的基础上对底层架构做了进一步的改进，引入新特性，并提升版本要求。ThinkPHP5.1运行环境要求PHP5.6+，虽然不支持5.0的无缝升级，但升级过程并不复杂（请参考升级指导） 主要新特性 引入容器和Facade支持 依赖注入完善和支持更多场景 重构的（对象化）路由 配置和路由目录独立 取消系统常量 助手函数增强 类库别名机制 模型和数据库增强 验证类增强 模板引擎改进 支持PSR-3日志规范 RC3对于之前版本主要更新如下： 改进redis驱动的get方法 修正Query类的alias方法 File类错误信息支持多语言 修正路由的额外参数解析 改进whereTime方法 改进Model类getAttr方法 改进App类的controller和validate方法支持多层 改进HasManyThrough类 修正软删除的restore方法 改进MorpthTo关联 改进数据库驱动类的parseKey方法 增加whereField动态查询方法 模型增加废弃字段功能 改进路由的after行为检查和before行为机制 改进路由分组的检查 修正mysql的json字段查询 取消Connection类的quote方法 改进命令行的支持 验证信息支持多语言 修正路由模型绑定 改进参数绑定类型对枚举类型的支持 修正模板的{$Think.version}输出 改进模板date函数解析 改进insertAll方法支持分批执行 Request类host方法支持反向代理 改进JumpResponse支持区分成功和错误模板 改进开启类库后缀后的关联外键自动识别问题 修正一对一关联的JOIN方式预载入查询问题 Query类增加hidden方法 目前5.1版本尚处于RC阶段，仅供学习，请勿用于商业项目！5.1完全开发手册：https://www.kancloud.cn/manual/thinkphp5_1/content 5.0.12是一个修正版本，包含了上个版本发布以来的一些修正和完善，主要包括： 更新日志 上传类和验证类的多语言支持； 模型增加排除和废弃字段支持； 改进insertAll方法的分批处理； 改进对枚举类型的参数绑定支持； 修正社区反馈的问题； 数据库和模型 改进Connection类的getRealSql方法 改进append方法支持一对一关联的bind设置 改进whereTime查询 改进model类的destroy方法 修正softdelete 修正chunk方法对时间字段的支持 Collection类增加push方法 改进alias方法 修正模型类的append处理 改进appendRelationAttr方法 改进HasManyThrough关联 改进MorphTo关联 模型增加废除字段disuse定义 增加排除字段方法except 修正has方法 改进参数绑定类型对枚举类型的支持 改进insertAll方法的分批处理 其它 改进Loader类controller和validate方法 支持多层 验证提示信息支持多语言 File类错误信息支持多语言 模板渲染异常处理 修正rest控制器 改进trace驱动 改进Cache类的remember方法 改进url_common_param的情况下urlencode的问题 改进Url类 改进exception_handle配置参数对闭包的支持 执行路由缓存命令前检测RUNTIME_PATH是否存在 调整部分CacheDriver::dec在为空的时候递减的行为 优化移动端的显示 改进对JSON-Handle插件的支持 改进redis的get方法 改进Request类的host方法 5.0.11可以无缝升级到5.0.12。 下载 核心版 完整版 文档官方完全开发手册内容已经同步更新 完全开发手册 官方快速入门系列]]></content>
      <categories>
        <category>PHP</category>
        <category>ThinkPHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 molde模型相关使用技巧]]></title>
    <url>%2F2017%2F11%2F03%2FYii2-molde%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[今天整理一些 Yii2 Model模型在开发中常用到的一些方法我技巧。模型是 MVC 模式中的一部分， 是代表业务数据、规则和逻辑的对象。 获取查询 SQL12345$query = User::find()-&gt;where([&apos;like&apos;, &apos;name&apos;, &apos;ewan%&apos;, false]);$commandQuery = clone $query;// SELECT * FROM `user` WHERE `name` LIKE &apos;ewan%&apos;echo $commandQuery-&gt;createCommand()-&gt;getRawSql(); 简单查询技巧1234567891011121314151617where(): 添加查询条件。select(): 添加查询字段。with(): 该查询应执行的关系列表。indexBy(): 根据索引的列的名称查询结果。asArray(): 以数组的形式返回每条记录。orderBy(): 按指定字段排序。User::find()-&gt;one(); // 返回一条数据，返回对象；User::find()-&gt;column(); // 返回查询结果中的第一列的值,返回数组；User::find()-&gt;scalar(); // 返回查询结果的第一行中的第一列的值；User::find()-&gt;all(); // 返回所有记录数据；User::find()-&gt;count(); // 返回记录的数量；User::find()-&gt;sum(&apos;num&apos;); // 返回指定字段（&apos;num&apos;）的总和；User::find()-&gt;average(&apos;num&apos;); // 返回指定字段（&apos;num&apos;）的平均值；User::find()-&gt;min(&apos;num&apos;); // 返回指定字段（&apos;num&apos;）的最小值；User::find()-&gt;max(&apos;num&apos;); // 返回指定字段（&apos;num&apos;）的最大值；User::find()-&gt;exists(); // 返回一个值，该值指示查询结果是否有数据； 关联查询12User::hasOne()：返回对应关系的单条记录User::hasMany()：返回对应关系的多条记录 模型中事务处理12345Yii::$app-&gt;db-&gt;transaction(function() &#123; $order = new Order($customer); $order-&gt;save(); $order-&gt;addItems($items);&#125;); 批量插入批量插入的问题，已经写了一篇《Yii2 批量插入》,点击链接查看即可。 表单验证两个字段选取一个12345678910public function rules()&#123; return [ [[&apos;card_id&apos;, &apos;card_code&apos;], function ($attribute, $param) &#123; //至少要一个 if (empty($this-&gt;card_code) &amp;&amp; empty($this-&gt;card_id)) &#123; $this-&gt;addError($attribute, &apos;card_id/card_code至少要填一个&apos;); &#125; &#125;, &apos;skipOnEmpty&apos; =&gt; false], ];&#125; Like 模糊查询1$query = User::find()-&gt;where([&apos;LIKE&apos;, &apos;name&apos;, &apos;ad%&apos;, false]); // SELECT * FROM `user` WHERE `name` LIKE &apos;ad%&apos;]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 2.0.13 发布，高性能 PHP 框架]]></title>
    <url>%2F2017%2F11%2F03%2FYii2-2-0-13-%E5%8F%91%E5%B8%83%EF%BC%8C%E9%AB%98%E6%80%A7%E8%83%BD-PHP-%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Yii2 2.0.13 发布了。Yii 2 完全根据 Yii 1.1 版本重写，后者是最流行的 PHP 框架之一。Yii 2 继承了 Yii 的简洁、快速、和高扩展性。Yii 2 需要 PHP 5.4，并且拥有现代 Web 应用开发中最好的实例和协议。 主要更新内容： yii\web\DbSession 现依靠错误处理程序来显示错误。 允许移动任何大小的名称，但长度限制在 180 个字符 日志消息时间精确到毫秒 更新详情：详情链接 下载地址： yii-advanced-app-2.0.13.tgz yii-basic-app-2.0.13.tgz Source code (zip) Source code (tar.gz)]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CakePHP 3.5.5 发布，PHP 开发框架]]></title>
    <url>%2F2017%2F11%2F03%2FCakePHP-3-5-5-%E5%8F%91%E5%B8%83%EF%BC%8CPHP-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[CakePHP 3.5.5 发布了。CakePHP 是一个运用了诸如 ActiveRecord、Association Data Mapping、Front Controller 和 MVC 等著名设计模式的快速开发框架。该项目主要目标是提供一个可以让各种层次的 PHP 开发人员快速地开发出健壮的 Web 应用，而又不失灵活性。 更新内容： SQLServer no longer reports double column lengths for NVARCHAR and NCHAR columns. IntegrationTestSuite::enableCsrfToken() no longer emits errors when the POST body is a string. Response::getType() has been added as a replacement for Response::type(). Network\Socket now supports explicit use of TLS1.1 and 1.2. Support for SSL2 is deprecated and will be removed in 4.0.0. IntegrationTestCase::assertResponseCode() now allows custom messages to be set. Cake\Http\Client\FormData::addFile() now adds parts as documented. Router::$initialized is deprecated. As we migrate to routes being loaded via middleware this property will no longer be in use. TableSchema now provides more succinct debug information. 更多内容请查看 changelog 下载地址： cakephp-3-5-5.zip Source code (zip) Source code (tar.gz)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CakePHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.2.0 RC3 发布，bug 修复版本]]></title>
    <url>%2F2017%2F09%2F28%2FPHP-7-2-0-RC3-%E5%8F%91%E5%B8%83%EF%BC%8Cbug-%E4%BF%AE%E5%A4%8D%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[PHP 7.2.0 RC3 发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下： Core Fixed bug #75241 (Null pointer dereference in zend_mm_alloc_small()). (Laruence) Fixed bug #74878 (Data race in ZTS builds). (Nikita, Dmitry) Fixed bug #75236 (infinite loop when printing an error-message). (Andrea) Fixed bug #75252 (Incorrect token formatting on two parse errors in one request). (Nikita) FPM: Fixed bug #75212 (php_value acts like php_admin_value). (Remi) MySQLi: Fixed bug #75018 (Data corruption when reading fields of bit type). (Anatol) Opcache: Fixed bug #75230 (Invalid opcode 49/1/8 using opcache). (Laruence) PCRE: Fixed bug ##75223 (PCRE JIT broken in 7.2). (Dmitry) PDO_mysql: Fixed bug #75177 (Type ‘bit’ is fetched as unexpected string). (Anatol) SPL: Fixed bug #73629 (SplDoublyLinkedList::setIteratorMode masks intern flags). (J. Jeising, cmb) 下载地址：https://downloads.php.net/~remi/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.0.24 和 7.1.10 正式发布，多项内容修复]]></title>
    <url>%2F2017%2F09%2F27%2FPHP-7-0-24-%E5%92%8C-7-1-10-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E5%A4%9A%E9%A1%B9%E5%86%85%E5%AE%B9%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[PHP 7.0.24 和 7.1.10 正式发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下： PHP 7.1.10Core: Fixed bug #75042 (run-tests.php issues with EXTENSION block). (John Boehr) BCMath: Fixed bug #44995 (bcpowmod() fails if scale != 0). (cmb) Fixed bug #46781 (BC math handles minus zero incorrectly). (cmb) Fixed bug #54598 (bcpowmod() may return 1 if modulus is 1). (okano1220, cmb) Fixed bug #75178 (bcpowmod() misbehaves for non-integer base or modulus). (cmb) CLI server: Fixed bug #70470 (Built-in server truncates headers spanning over TCP packets). (bouk) CURL: Fixed bug #75093 (OpenSSL support not detected). (Remi) GD: Fixed bug #75124 (gdImageGrayScale() may produce colors). (cmb) Fixed bug #75139 (libgd/gd_interpolation.c:1786: suspicious if ?). (cmb) Gettext: Fixed bug #73730 (textdomain(null) throws in strict mode). (cmb) Intl: Fixed bug #75090 (IntlGregorianCalendar doesn’t have constants from parentclass). (tpunt) Fixed bug #75193 (segfault in collator_convert_object_to_string). (Remi) PDO_OCI: Fixed bug #74631 (PDO_PCO with PHP-FPM: OCI environment initialized before PHP-FPM sets it up). (Ingmar Runge) SPL: Fixed bug #75155 (AppendIterator::append() is broken when appending another AppendIterator). (Nikita) Fixed bug #75173 (incorrect behavior of AppendIterator::append in foreach loop). (jhdxr) Standard: Fixed bug #75152 (signed integer overflow in parse_iv). (Laruence) Fixed bug #75097 (gethostname fails if your host name is 64 chars long). (Andrea) PHP 7.0.24Core: Fixed bug #75042 (run-tests.php issues with EXTENSION block). (John Boehr) BCMath: Fixed bug #44995 (bcpowmod() fails if scale != 0). (cmb) Fixed bug #46781 (BC math handles minus zero incorrectly). (cmb) Fixed bug #54598 (bcpowmod() may return 1 if modulus is 1). (okano1220, cmb) Fixed bug #75178 (bcpowmod() misbehaves for non-integer base or modulus). (cmb) CLI server: Fixed bug #70470 (Built-in server truncates headers spanning over TCP packets). (bouk) CURL: Fixed bug #75093 (OpenSSL support not detected). (Remi) GD: Fixed bug #75124 (gdImageGrayScale() may produce colors). (cmb) Fixed bug #75139 (libgd/gd_interpolation.c:1786: suspicious if ?). (cmb) Gettext: Fixed bug #73730 (textdomain(null) throws in strict mode). (cmb) Intl: Fixed bug #75090 (IntlGregorianCalendar doesn’t have constants from parent class). (tpunt) Fixed bug #75193 (segfault in collator_convert_object_to_string). (Remi) PDO_OCI: Fixed bug #74631 (PDO_PCO with PHP-FPM: OCI environment initialized before PHP-FPM sets it up). (Ingmar Runge) SPL: Fixed bug #75173 (incorrect behavior of AppendIterator::append in foreach loop). (jhdxr) Standard: Fixed bug #75097 (gethostname fails if your host name is 64 chars long). (Andrea)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3.0 Build 3143 发布，全新 UI 主题]]></title>
    <url>%2F2017%2F09%2F15%2FSublime-Text-3-0-Build-3143-%E5%8F%91%E5%B8%83%EF%BC%8C%E5%85%A8%E6%96%B0-UI-%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[还记得我刚学 PHP 编程的时候，老师强烈推荐了Sublime，当时因为正处于测试阶段，然后就种破解，现在3.0终于发布了，欠的船票该补上了。Sublime Text 3.0 Build 3143 发布了。Sublime Text 3 比 Sublime Text 2 快得多。 虽然它比 2 的安装包更大，但它的启动速度更快，打开文件的速度更快，滚动效率更高。 与最后一个 beta 版相比，3.0 带来了新的 UI 主题，新配色方案和新图标。其他改进如： 改进大型语法的高亮 支持 Windows 触摸输入 支持 MacOS 上的 Touch Bar 添加适用于 Linux 的 apt / yum / pacman 存储库 提升 Goto Definition 的性能 了解更多 3.0 版的更新内容，请参阅发布新闻和完整版发布说明。 下载地址： https://www.sublimetext.com/3]]></content>
      <categories>
        <category>Sublime</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.2.0 RC2 发布，bug 修复版本]]></title>
    <url>%2F2017%2F09%2F13%2FPHP-7-2-0-RC2-%E5%8F%91%E5%B8%83%EF%BC%8Cbug-%E4%BF%AE%E5%A4%8D%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[PHP 7.2.0 RC2 发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下： 14 Sep 2017, PHP 7.2.0RC2 Core:. Fixed Bug #75142 (buildcheck.sh check for autoconf version needs to be updated for v2.64). (zizzy at zizzy dot net, Remi) BCMath:. Fixed bug #44995 (bcpowmod() fails if scale != 0). (cmb). Fixed bug #46781 (BC math handles minus zero incorrectly). (cmb). Fixed bug #54598 (bcpowmod() may return 1 if modulus is 1). (okano1220, cmb). Fixed bug #75178 (bcpowmod() misbehaves for non-integer base or modulus). (cmb) CLI server:. Fixed bug #70470 (Built-in server truncates headers spanning over TCP packets). (bouk) Date:. Fixed bug #75149 (redefinition of typedefs ttinfo and t1info). (Remi) GD:. Fixed bug #75139 (libgd/gd_interpolation.c:1786: suspicious if ?). (cmb) Intl:. Fixed bug #75193 (segfault in collator_convert_object_to_string). (Remi) Gettext:. Fixed bug #73730 (textdomain(null) throws in strict mode). (cmb) Opcache. Fixed incorect constant conditional jump elimination. (Dmitry) OpenSSL. Automatically load OpenSSL configuration file. (Jakub Zelenka) SPL:. Fixed bug #75155 (AppendIterator::append() is broken when appending another AppendIterator). (Nikita). Fixed bug #75173 (incorrect behavior of AppendIterator::append in foreach loop). (jhdxr) Standard:. Fixed bug #75152 (signed integer overflow in parse_iv). (Laruence). Fixed bug #75170 (mt_rand() bias on 64-bit machines). (Nikita) ZIP:. Fixed bug #75143 (new method setEncryptionName() seems not to exist in ZipArchive). (Anatol) 下载地址：https://downloads.php.net/~pollita/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP V5.0.11 暨 5.1.0 RC1 版本发布: 包含安全更新]]></title>
    <url>%2F2017%2F09%2F11%2FThinkPHP-V5-0-11-%E6%9A%A8-5-1-0-RC1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83-%E5%8C%85%E5%90%AB%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[V5.1.0RC1版本是继5.0版本之后又一个重大版本，ThinkPHP5.1在5.0的基础上对底层架构做了进一步的改进，引入新特性，并提升版本要求。ThinkPHP5.1运行环境要求PHP5.6+，虽然不支持5.0的无缝升级，但升级过程并不复杂（请参考升级指导） 主要新特性 引入容器和Facade支持 依赖注入完善和支持更多场景 重构的（对象化）路由 配置和路由目录独立 取消系统常量 助手函数增强 类库别名机制 模型和数据库增强 验证类增强 模板引擎改进 支持PSR-3日志规范 下载核心版本 目前5.1版本尚处于RC阶段，仅供学习参考，请勿用于商业项目！5.1完全开发手册：https://www.kancloud.cn/manual/thinkphp5_1/353946V5.0.11版本主要为BUG修正和改进，并且包含一个安全更新，可以从5.0.10无缝升级，推荐更新，主要改进如下： 主要更新 完善缓存驱动； 改进数据库查询； 改进URL生成类； 缓存有效期支持指定过期时间； 更新日志[数据库和模型] 改进数据库驱动类 改进group方法的字段关键字冲突 修正聚合查询返回null的问题 改进Db类的强制重连 改进关联的属性绑定 修正事务的断线重连 修正对象的条件查询 Db类增加clear方法 改进数组查询条件中的null查询 改进Query类的chunk方法支持排序设置 改进HasOne和HasMany关联的has方法 改进软删除的关联删除 改进一个字段多次查询条件 [其它] 缓存有效期支持指定过期时间（DateTime）； 改进Url生成对端口号的支持 改进RouteNotFound异常提示 改进路由分组的全局完整路由匹配 修正部分验证规则的错误提示问题 支持数据集和模型的xml响应输出 改进模板的三元运算标签 改进控制器不存在的错误提示 input助手函数支持route变量获取 支持在配置文件中读取额外配置参数 完善分页类 修复Trait命名空间重复问题 修正Request类的env方法 优先使用Cookie中的多语言设置 获取缓存标签的时候过滤无效的缓存标识 修正路由批量注册的一个BUG exception_handle配置参数支持使用闭包定义render处理 请求缓存支持缓存标签设置 缓存类remember方法增加并发锁定机制 改进上传类对swf的支持 改进Session类的prefix方法 5.0.10可以无缝升级到5.0.11，升级完成后务必清空你的缓存目录。 下载OSChina：应用仓库：http://git.oschina.net/liu21st/thinkphp5核心仓库：http://git.oschina.net/liu21st/framework官网下载：核心版 完整版 文档官方完全开发手册内容已经同步更新 完全开发手册 官方快速入门系列]]></content>
      <categories>
        <category>PHP</category>
        <category>ThinkPHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 修改远程URL]]></title>
    <url>%2F2017%2F09%2F04%2Fgit-%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8BURL%2F</url>
    <content type="text"><![CDATA[使用的临时域名，没有实名制，暂时不能用了，项目急着上线，那只有修改远程 URL，使用 IP 访问了。查看当前 remote url:1$ git remote -v 修改 remote url:1$ git remote set-url origin http://cola@101.81.167.17:10020/r/project.git 完成，可以拉代码了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 5.5 LTS 正式发布，Whoops Package 回归]]></title>
    <url>%2F2017%2F08%2F31%2FLaravel-5-5-LTS-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8CWhoops-Package-%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[Laravel 5.5 已发布，这是最新的长期支持版本（LTS），包含多项改进。发行说明：https://laravel-news.com/laravel-5-5 部分亮点Whoops Package 回归filp / whoops package 曾经出现在 V4 系列，用于在调试时提供优雅的堆栈跟踪，是一个错误处理框架。Laravel 5.5 版本 Whoops Package 正式回归。 Exception Rendering5.5 无需额外的逻辑，可直接抛出异常，并进行响应：12345678910111213141516171819202122232425262728&lt;?php// throw new TerribleSongException($song) in a controller...namespace App\Exceptions;use App\Song;class TerribleSongException extends \Exception&#123; /** * @var \App\Song */ protected $song; public function __construct(Song $song) &#123; $this-&gt;song = $song; &#125; /** * @param \Illuminate\Http\Request $request */ public function render($request) &#123; return response(&quot;The song &apos;&#123;$this-&gt;song-&gt;title&#125;&apos; by &apos;&#123;$this-&gt;song-&gt;artist&#125;&apos; is terrible.&quot;); &#125;&#125; 自定义验证规则对象Laravel 5.5 带来新的自定义验证规则对象，以此作为 Validator::extend 的替代方法。新规则的逻辑更一目了然：123456789101112131415161718&lt;?phpnamespace App\Rules;use Illuminate\Contracts\Validation\Rule;class CowbellValidationRule implements Rule&#123; public function passes($attribute, $value) &#123; return $value &gt; 10; &#125; public function message() &#123; return &apos;:attribute needs more cowbell!&apos;; &#125;&#125; 使用新规则后：12345678910&lt;?phprequest()-&gt;validate([ &apos;cowbells&apos; =&gt; [new CowbellValidationRule], &apos;more_cowbells&apos; =&gt; [function ($attribute, $value, $fail) &#123; if ($value &lt;= 10) &#123; $fail(&apos;:attribute needs more cowbell!&apos;); &#125; &#125;]]); Blade::if () 指令新的指令包括 @auth and @guest1234567@auth Welcome &#123;&#123; user()-&gt;name &#125;&#125;!@endauth@guest Welcome Guest!@endguest 新的迁移命令：Fresh新的 migrate:fresh 命令会直接删除所有的表，然后运行迁移。通常在开发过程中，你也只需删除表，获取新数据库，和运行迁移。 更多细节请直接查看发行说明Laravel 5.5 更多链接： 升级文档：https://laravel.com/docs/5.5 版本说明 https://laravel.com/docs/5.5/releases 升级指南：https://laravel.com/docs/5.5/upgrade]]></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRC16 For PHP]]></title>
    <url>%2F2017%2F08%2F13%2FCRC16-For-PHP%2F</url>
    <content type="text"><![CDATA[随着物联网技术的发展和普及，作为最好的语言 PHP 也难免会遇上与硬件设备数据对接的情况。在数据通信领域中有一种查错校验码，CRC。在 PHP 官网上搜索了一下，只提供 CRC32 的相关的函数，关于 CRC16 我自己封装了一个方法用于校验计算。然后我将代码整理了一番，已发布到 GitHub，有需要的同学可以去看下，或许我们可以共同维护他。项目地址CRC16ForPHP具体实现代码：123456789101112131415function crc16Modbus($str)&#123; $data = pack(&apos;H*&apos;, $str); $crc = 0xFFFF; for ($i = 0; $i &lt; strlen($data); $i++) &#123; $crc ^= ord($data[$i]); for ($j = 8; $j != 0; $j--) &#123; if (($crc &amp; 0x0001) != 0) &#123; $crc &gt;&gt;= 1; $crc ^= 0xA001; &#125; else $crc &gt;&gt;= 1; &#125; &#125; return sprintf(&apos;%04X&apos;, $crc);&#125; 用法：1echo crc16(&apos;010301180001&apos;).PHP_EOL;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CRC16</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole TCP服务器心跳维持方案]]></title>
    <url>%2F2017%2F08%2F04%2Fswoole-TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%83%E8%B7%B3%E7%BB%B4%E6%8C%81%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[正常情况下客户端中断TCP连接时，会发送一个FIN包，进行4次断开握手来通知服务器。但一些异常情况下，如客户端突然断电断网或者网络异常，服务器可能无法得知客户端已断开连接。尤其是移动网络，TCP连接非常不稳定，所以需要一套机制来保证服务器和客户端之间连接的有效性。Swoole扩展本身内置了这种机制，开发者只需要配置一个参数即可启用。Swoole在每次收到客户端数据会记录一个时间戳，当客户端在一定时间内未向服务器端发送数据，那服务器会自动切断连接。使用方法：1234$serv-&gt;set(array( &apos;heartbeat_check_interval&apos; =&gt; 60, &apos;heartbeat_idle_time&apos; =&gt; 300,)); 上面的设置就是每60秒侦测一次心跳，一个TCP连接如果在300秒内未向服务器端发送数据，将会被切断。当然我这个长连接，这样做是为了回收进程。 高级用法：使用swoole_server::heartbeat()函数手工检测心跳是否到期。此函数会返回闲置时间超过heartbeat_idle_time的所有TCP连接。程序中可以将这些连接做一些操作，如发送数据或关闭连接。]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole 粘包 EOF 包头+包尾]]></title>
    <url>%2F2017%2F08%2F03%2Fswoole-%E7%B2%98%E5%8C%85-EOF%2F</url>
    <content type="text"><![CDATA[今天在跟硬件开发的小伙伴测试的时候发现了一个非常有趣的问题，即Client 每次请求，Server 端我返回相同信息，但是有时候会出现两次或多次返回的数据堆叠到一起的现象。开始我还以为我代码写的有问题，仔细看了一下代码没问题啊，终究还是要相信科学。经我多方查证，原来我们的问题是 TCP 粘包问题，下面科普一下。 TCP 粘包长连接和短连接在讨论 TCP 粘包的问题前，我们先理解一下长连接和短连接。长连接 Client 与 Server 先建立通讯连接，连接建立后不断开， 然后再进行数据发送和接收。 短连接 Client 与 Server 每进行一次数据收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个Client连接一个Server。 什么是 TCP 粘包TCP 粘包是指发送方发送的若干包数据 到 接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。 TCP 出现粘包的原因 发送方：发送方需要等缓冲区满才发送出去，造成粘包 接收方：接收方不及时接收缓冲区的包，造成多个包接收 什么时候需要处理粘包不处理： 短连接，每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题。 如果发送数据无结构，如文件传输被分成多个分组发送，也不用考虑粘包。 需处理： 双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：good morning、good evening，如果发送方连续发了两个包出去，接收方可能就回收到`good morninggood evening很明显不是我们想要，需要处理。 Swoole 处理粘包既然了解了为什么会出现粘包现象和什么时候需要处理粘包，那下边就是想办法解决了。很显然我的需求得处理，很幸运 Swoole 已经提供了怎么解决粘包问题的方案。 EOF 结束协议之前我在翻阅 Swoole 文档过程中，在看到 Server 配置选项的时候，看到过open_eof_check、open_eof_split、package_eof…配置的时候，搂了两眼，感觉很深奥的样子，就一眼带过了。现在才知道它们是用来干嘛的。EOF，即指每一个数据包的结尾加一个EOF标记，表示数据包的结束，但是如果你的数据本身含有EOF标记，那就会造成收到的数据包不完整，所以开启EOF支持后，应避免数据中含有EOF标记。Server 的 open_eof_check设置为true时，打开EOF检测，此选项将检测客户端连接发来的数据，当数据包结尾是指定的EOF字符串时才会投递给Worker进程。否则会一直拼接数据包，直到超过缓存区或者超时才会中止。当出错时swoole底层会认为是恶意连接，丢弃数据并强制关闭连接。1234$serv-&gt;set([ &apos;open_eof_check&apos; =&gt; true, //打开EOF检测 &apos;package_eof&apos; =&gt; &quot;\r\n&quot;, //设置EOF]); 常见的Memcache/SMTP/POP等协议都是以\r\n结束的，就可以使用以上配置。开启后可以保证Worker进程一次性总是收到一个或者多个完整的数据包。虽然Swoole 已经帮我在服务端做了 EOF 结束协议，但是你不能保证客户端会一次性发过来几条数据，这样会出现一次性接受多个数据包的问题，因为EOF检测不会从数据中间查找eof字符串，所以Worker进程可能会同时收到多个数据包，需要在应用层代码中自行explode(“\r\n”, $data) 来拆分数据包。1234567891011public function onReceive($serv, $fd, $fromId, $data)&#123; $datas = explode(&quot;\r\n&quot;, $data); foreach ($datas as $data) &#123; if(!$data)&#123; continue; &#125; echo &quot;Server received data: &#123;$data&#125;&quot; . PHP_EOL; &#125;&#125; 虽然我们可以自己拆分数据，但是Swoole1.7.15版本增加了open_eof_split，支持从数据中查找EOF，并切分数据，那我们何乐而不为呐?12345$serv-&gt;set([ &apos;open_eof_check&apos; =&gt; true, //打开EOF检测 &apos;package_eof&apos; =&gt; &quot;\r\n&quot;, //设置EOF &apos;open_eof_split&apos; =&gt; true,]); 配置成上面这样，我们就不用自己在应用层代码中自行 explode()了。 发送长度 固定包头和包尾发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。在这种协议下，我们的数据包的组成就是包头+包体。其中包头就是包体长度的二进制形式。比如我们本来想向服务端发送一段数据 “Just a test.” 共12个字符，现在我们要发送的数据就应该是这样的1pack(&apos;N&apos;, strlen(&quot;Just a test.&quot;)) . &quot;Just a test.&quot; pack()函数是将数据打包成二进制字符串，也就是我们的包头部分。这样的话 Server 收到一个数据包（可能是多个完整的数据包）之后，会先解出包头指定的数据长度，然后按照这个长度取出后面的数据，如果一次性收到多个数据包，依次循环，如此就能保证Worker进程可以一次性收到一个完整的数据包。Swoole 为我们提供一下几个配置选项： open_length_check：打开包长检测特性 package_length_type：长度字段的类型，固定包头中用一个4字节或2字节表示包体长度，文章最后给出详细长度值的类型 package_length_offset：从第几个字节开始是长度，比如包头长度为120字节，第10个字节为长度值，这里填入9（从0开始计数） package_body_offset：从第几个字节开始计算长度，比如包头为长度为120字节，第10个字节为长度值，包体长度为1000。如果长度包含包头，这里填入0，如果不包含包头，这里填入120 package_max_length：最大允许的包长度。因为在一个请求包完整接收前，需要将所有数据保存在内存中，所以需要做保护。避免内存占用过大。 具体配置就写这样：1234567$serv-&gt;set([ &apos;open_length_check&apos; =&gt; true, // 开启协议解析 &apos;package_length_type&apos; =&gt; &apos;N&apos;, // 长度字段的类型 &apos;package_length_offset&apos; =&gt; 0, //第几个字节是包长度的值 &apos;package_body_offset&apos; =&gt; 4, //第几个字节开始计算长度 &apos;package_max_length&apos; =&gt; 81920, //协议最大长度]); 数据处理部分为这样：1234567public function onReceive($serv, $fd, $fromId, $data)&#123; $info = unpack(&apos;N&apos;, $data); $len = $info[1]; $body = substr($data, - $len); echo &quot;server received data: &#123;$body&#125;\n&quot;;&#125; 完成这些，这种方案就算完成了。 package_length_type 长度值的类型长度值的类型，接受一个字符参数，与php的pack函数一致。目前swoole支持10种类型： c：有符号、1字节 C：无符号、1字节 s ：有符号、主机字节序、2字节 S：无符号、主机字节序、2字节 n：无符号、网络字节序、2字节 (常用) N：无符号、网络字节序、4字节 (常用) l：有符号、主机字节序、4字节（小写L） L：无符号、主机字节序、4字节（大写L） v：无符号、小端字节序、2字节 V：无符号、小端字节序、4字节]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lantern 运行时关闭终端]]></title>
    <url>%2F2017%2F08%2F03%2Flantern-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%85%B3%E9%97%AD%E7%BB%88%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[之前写过一篇 Mac 上破解 lantern 的文章lantern Mac版编译 无限流量。小伙伴胖佳说可以运行了，但是有个终端会一直开着，关闭掉以后 lantern 就终止执行了，也就不能翻墙了，今天想到了一个办法。接着上篇文章继续，Mac上搜索一下lantern_darwin_amd64,双击打开以后，会出现一个终端，上边不停的有各种信息出现，此时我们是可以正常使用的。但是一直开着个终端，有点不爽，首先我们把 lantern 执行终端滚到最上边会看到一下命令：其实我们就是想要lantern_darwin_amd64文件路径，然后你的.bash_profile或者.profile中添加以下命令：1alias lantern=&apos;/Users/yangyiyuan/projects/landeng/lantern/lantern_darwin_amd64 &amp; exit&apos; 将上边的文件路径换成你自己的就可以了，然后终端执行：1$ source .bash_profile 这样就可以了，以后我们要启动蓝灯，直接打开终端执行：1$ lantern 然后关闭窗口就可以了。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>lantern</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole 进程守护 日志保存]]></title>
    <url>%2F2017%2F08%2F03%2Fswoole-%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4-%E6%97%A5%E5%BF%97%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[前边我已经学会了 Swoole 的 Server 和 Client，也用他们做了不同压力测试、并发测试等等。但是终究离应用到实际项目还差一步，因为没有开启进程守护，只要我的终端关掉了，程序也就中断执行了。其实在写这篇之前，不依赖 Swoole 为我们提供的方法，如果 Linux 算熟悉的话，自己也能想到办法：1$ php server.php &gt; server_log.log &amp; 进程守护 日志保存但是既然 Swoole 给提供了，那我们就开看一下怎么用的吧。将daemonize设置为true时，程序将转入后台作为守护进程运行。长时间运行的服务器端程序必须启用此项。如果不启用守护进程，当ssh终端退出后，程序将被终止运行。 启用守护进程后，标准输入和输出会被重定向到 log_file 如果未设置log_file，将重定向到 /dev/null，所有打印屏幕的信息都会被丢弃 代码实现，只要将我们之前讲过的 server 配置添加daemonize 和log_file即可：12345$serv-&gt;set([ &apos;worker_num&apos; =&gt; 1, &apos;daemonize&apos; =&gt; true, &apos;log_file&apos; =&gt; __DIR__ . &apos;/server.log&apos;]); 设置好以后，确认是够已经成功进行进程守护，可使用命令查看：12345$ ps aux | grep server.phpyangyiyuan 92904 0.0 0.0 2491660 2280 ?? S 10:54上午 0:00.00 php server.phpyangyiyuan 92861 0.0 0.0 2491052 1596 ?? S 10:54上午 0:00.00 php server.phpyangyiyuan 92857 0.0 0.0 2492280 1860 ?? Ss 10:54上午 0:00.27 php server.phpyangyiyuan 98783 0.0 0.0 2423392 600 s001 R+ 1:52下午 0:00.00 grep server.php 此时执行我们的客户端文件，将会有日志输出到server.log文件中。 重启进程一台繁忙的后端服务器随时都在处理请求，如果管理员通过kill进程方式来终止/重启服务器程序，可能导致刚好代码执行到一半终止。这种情况下会产生数据的不一致。如交易系统中，支付逻辑的下一段是发货，假设在支付逻辑之后进程被终止了。会导致用户支付了货币，但并没有发货，后果非常严重。Swoole提供了柔性终止/重启的机制，管理员只需要向SwooleServer发送特定的信号，Server的worker进程可以安全的结束。 SIGTERM: 向主进程/管理进程发送此信号服务器将安全终止,在PHP代码中可以调用$serv-&gt;shutdown()完成此操作 SIGUSR1: 向主进程/管理进程发送SIGUSR1信号，将平稳地restart所有worker进程,在PHP代码中可以调用$serv-&gt;reload()完成此操作 swoole的reload有保护机制，当一次reload正在进行时，收到新的重启信号会丢弃 如果设置了user/group，Worker进程可能没有权限向master进程发送信息，这种情况下必须使用root账户，在shell中执行kill指令进行重启 reload指令对addProcess添加的用户进程无效 终端重启所有worker进程：1$ kill -USR1 主进程PID 终端仅重启task进程1$ kill -USR2 主进程PID 注意事项： 平滑重启只对onWorkerStart或onReceive等在Worker进程中include/require的PHP文件有效，Server启动前就已经include/require的PHP文件，不能通过平滑重启重新加载对于Server的配置即$serv-&gt;set()中传入的参数设置，必须关闭/重启整个Server才可以重新加载Server可以监听一个内网端口，然后可以接收远程的控制命令，去重启所有worker Reload有效范围：Reload操作只能重新载入Worker进程启动后加载的PHP文件，建议使用get_included_files函数来列出哪些文件是在WorkerStart之前就加载的PHP文件，在此列表中的PHP文件，即使进行了reload操作也无法重新载入。比如要关闭服务器重新启动才能生效。WorkerStart之前就加载的PHP文件：123$serv-&gt;on(&apos;WorkerStart&apos;, function($serv, $workerId) &#123; var_dump(get_included_files()); //此数组中的文件表示进程启动前就加载了，所以无法reload&#125;); 重启无效：1234require_once &apos;./Test.php&apos;;class Server&#123; &#125; 重启有效：1234$serv-&gt;on(&apos;WorkerStart&apos;, function($serv, $workerId) &#123; require_once(&quot;Test.php&quot;); //此处 Test.php重启有效 $this-&gt;_test = new Test;&#125;);]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole Worker进程]]></title>
    <url>%2F2017%2F08%2F01%2Fswoole-Worker%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在文章之前先看两张图片，试着去理解一下Swoole Server运行流程和进程/线程结构. 运行流程图 进程/线程结构图为了能更好的理解Swoole Server 的运行流程，下面我们创一个简单的实例server-process.php配合上面的图片进行讲解。1234567891011121314151617$serv = new swoole_server(&apos;127.0.0.1&apos;, 9501);$serv-&gt;set([ &apos;worker_num&apos; =&gt; 2, &apos;task_worker_num&apos; =&gt; 1,]);$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123;&#125;);$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123;&#125;);$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123;&#125;);$serv-&gt;on(&apos;Task&apos;, function ($serv, $taskId, $fromId, $data) &#123;&#125;);$serv-&gt;on(&apos;Finish&apos;, function ($serv, $taskId, $data) &#123;&#125;);$serv-&gt;start(); 然后执行 ps 命令查看：1234567$ ps aux | grep server-processroot 21843 xxx... php server-process.phproot 21844 xxx... php server-process.phproot 21846 xxx... php server-process.phproot 21847 xxx... php server-process.phproot 21848 xxx... php server-process.phproot 21854 xxx... grep --color=auto server-process 排除掉 grep 那条，一共有5条。相比Master-Worker模式，swoole 的进程模型可以用Master-Manager-Worker来形容。即在Master-Worker的基础上又增加了一层Manager进程。 1个 Master 进程 1个 Manager 进程 2个 Worker 进程 1个 Task 进程 Swoole 是一个多进程模式的框架（可以类比Nginx的进程模型），当启动一个Swoole应用时，一共会创建2 + n + m个进程，其中n为 Worker 进程数，m为TaskWorker进程数，2为一个 Master 进程和一个 Manager 进程，它们之间的关系如下图所示。其中，Master进程为主进程，该进程会创建Manager进程、Reactor线程等工作进/线程。 Reactor线程实际运行epoll实例，用于accept客户端连接以及接收客户端数据； Manager进程为管理进程，该进程的作用是创建、管理所有的Worker进程和TaskWorker进程。]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole Task Worker 篇]]></title>
    <url>%2F2017%2F08%2F01%2Fswoole-Task-Worker-%E7%AF%87%2F</url>
    <content type="text"><![CDATA[swoole_server-&gt;task投递一个异步任务到 task_worker 池中。此函数是非阻塞的，执行完毕会立即返回。Worker 进程可以继续处理新的请求。使用Task功能，必须先设置 task_worker_num，并且必须设置 Server 的 onTask 和 onFinish 事件回调函数。注意事项： 使用 task 必须为 Server 设置 onTask 和 onFinish 回调，否则 swoole_server-&gt;start 会失败 task 操作的次数必须小于 onTask 处理速度，如果投递容量超过处理能力，task 会塞满缓存区，导致 worker 进程发生阻塞。worker 进程将无法接收新的请求 使用 addProcess 添加的用户进程中无法使用 task 投递任务，请使用 sendMessage 接口与 Task 工作进程通信 Task 实例创建 Server1$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501); 设置task_worker_num设置task_worker_num是我们使用 task 中不可缺少的一点哦1234$serv-&gt;set([ &apos;worker_num&apos; =&gt; 2, &apos;task_worker_num&apos; =&gt; 1,]); 客户端链接回调123$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123; echo &quot;new client connected.\n&quot;;&#125;); 接受客户端数据，使用 task123456789$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123; echo &quot;worker received data: &#123;$data&#125;\n&quot;; // 投递一个任务到task进程中 $serv-&gt;task($data); // 通知客户端server收到数据了 $serv-&gt;send($fd, &apos;This is a message from server.&apos;); // 为了校验task是否是异步的，这里和task进程内都输出内容，看看谁先输出 echo &quot;worker continue run.\n&quot;;&#125;); 设置 Server 的 onTask 和 onFinish 事件回调函数123456789101112131415161718192021/** * $serv swoole_server * $taskId 投递的任务id,因为task进程是由worker进程发起，所以多worker多task下，该值可能会相同 * $fromId 来自那个worker进程的id * $data 要投递的任务数据 */$serv-&gt;on(&apos;Task&apos;, function ($serv, $taskId, $fromId, $data) &#123; echo &quot;task start. --- from worker id: &#123;$fromId&#125;.\n&quot;; for ($i=0; $i &lt; 5; $i++) &#123; sleep(1); echo &quot;task runing. --- &#123;$i&#125;\n&quot;; &#125; return &quot;task end&quot;;&#125;);/** * 只有在task进程中调用了finish方法或者return了结果，才会触发finish */$serv-&gt;on(&apos;Finish&apos;, function ($serv, $taskId, $data) &#123; echo &quot;finish received data &apos;&#123;$data&#125;&apos;\n&quot;;&#125;); 关闭123$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123; echo &quot;Client &#123;$fd&#125; close connection\n&quot;;&#125;); 执行程序1$serv-&gt;start(); 客户端还是用我们上一篇简单的Server Client中的client.php。执行查看 client 结果：12$ php client.php This is a message from server. 执行查看 server 结果：123456789101112$ php index.php new client connected.Get Message From Client 1:hello server.worker continue run.task start. --- from worker id: 3.Client 1 close connectiontask runing. --- 0task runing. --- 1task runing. --- 2task runing. --- 3task runing. --- 4finish received data &apos;task end&apos; 从上边 server 执行的结果可以看出，task执行已经在 close 之后了，这样就知道什么是异步任务了吧。总结一下应用场景： 没有耗时任务的情况下，worker直接运行，无需开启task 对于耗时的任务，可以在worker内调用task函数，把异步任务投递给task进程进行处理，task进程的数量取决于task_worker_num的配置 task进程内可以选择调用finish方法或者return，来通知worker进程此任务已完成，worker进程会在onFinish回调中对task的执行结果进一步处理。如果worker进程不关心任务的结果，finish就不需要做处理了。]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole 初识 简单的 Server Client]]></title>
    <url>%2F2017%2F08%2F01%2Fswoole-%E5%88%9D%E8%AF%86-%E7%AE%80%E5%8D%95%E7%9A%84-Server-Client%2F</url>
    <content type="text"><![CDATA[为了学 Swoole，我们在开始之前已经普及了很多的知识，这篇我们就要上手玩一把 Swoole，是不是感觉有点手痒了。。前边几篇分别记录了： 进程与线程 I/O 模型 网络通讯协议 socket 都是一些简单的网路基础知识，不过这些最好要牢记。然后就是 Swoole 扩展的安装： Swoole 扩展安装 Swoole server创建server 的创建其实非常简单，只需要我们在安装好扩展的基础上，实现以下代码就可以了。12// $serv = new swoole_server(string $host, int $port, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP);$serv = new swoole_server(&apos;127.0.0.1&apos;, 9501); swoole_server 类的构造函数一共有四个参数，上面我们填写了两个 ，还有两个有默认值，不填也可。swoole_server构造函数 @param $host // 监听的 IP @param $port // 监听的端口 @param int $mode // 运行模式，swoole提供了3种运行模式，默认为SWOOLE_PROCESS多进程模式 @param int $sock_type // Socket的类型,支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种，默认为SWOOLE_SOCK_TCP TCP 类型 设置swoole_server-&gt;set()函数用于设置swoole_server运行时的各项参数。服务器启动后通过$serv-&gt;setting来访问set函数设置的参数数组。具体有哪些设置，我们后边慢慢学习，现在我们先实现一个简单的例子。123$serv-&gt;set([ &apos;worker_num&apos; =&gt; 2,]); worker_num 设置启动的worker进程数量。swoole采用固定worker进程的模式。PHP代码中是全异步非阻塞，worker_num配置为CPU核数的1-4倍即可。如果是同步阻塞，worker_num配置为100或者更高，具体要看每次请求处理的耗时和操作系统负载状况。 事件回调函数swoole_server-&gt;on()注册Server的事件回调函数。 第1个参数是回调的名称, 大小写不敏感，具体内容参考回调函数列表，事件名称字符串不要加on 第2个函数是回调的PHP函数，可以是函数名的字符串，类静态方法，对象方法数组，匿名函数 有新的客户端连接时，worker进程内会触发该回调123$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123; echo &quot;new client connected.\n&quot;;&#125;); server接收到客户端的数据后，worker进程内触发该回调1234$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123; echo &quot;Get Message From Client &#123;$fd&#125;:&#123;$data&#125;\n&quot;; $serv-&gt;send($fd, $data);&#125;); 客户端断开连接或者server主动关闭连接时 worker进程内调用123$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123; echo &quot;Client &#123;$fd&#125; close connection\n&quot;;&#125;); 启动server1$serv-&gt;start(); Swoole Client创建client 的创建一样非常简单1$client = new swoole_client(SWOOLE_SOCK_TCP); swoole_client 类的构造函数一共有三个参数。swoole_client构造函数 @param int $sock_type 指定socket的类型，支持TCP/UDP、TCP6/UDP6 4种 @param int $sync_type SWOOLE_SOCK_SYNC/SWOOLE_SOCK_ASYNC 同步/异步 @param string $connectionKey 链接的编号，用于长连接复用 建立连接1$client-&gt;connect(&apos;127.0.0.1&apos;, 9501) || exit(&quot;connect failed. Error: &#123;$client-&gt;errCode&#125;\n&quot;); 发送数据1$client-&gt;send(&quot;hello server.&quot;); 从服务端接收数据1$response = $client-&gt;recv(); 输出接受到的数据1echo $response . PHP_EOL; 关闭连接1$client-&gt;close(); Server 和 Client 通讯终端执行命令，将 server 挂起1$ php server.php 打开新的终端执行 client 程序，在此之前你可以使用一下命令查看 server 监听的9501端口的监听情况12$ netstat -an | grep 9501tcp4 0 0 127.0.0.1.9501 *.* LISTEN 从上边可以看到一些状态tcp4、LISTEN等关键信息执行 client 代码程序：12$ php client.php hello server. 运行 server的终端会显示如下：1234$ php server.php new client connected.Get Message From Client 1:hello server.Client 1 close connection 到这个地方我们已经简单的实现了 Swoole Server 和 Client 的链接通讯。]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole Socket篇]]></title>
    <url>%2F2017%2F08%2F01%2Fswoole-Socket%E7%AF%87%2F</url>
    <content type="text"><![CDATA[关于 PHP socket 的使用，我在之前的工作中使用过一些，自己也动手封装了关于 socket server 和 socket client 的类库，已共享到 GitHub 和码云上面： Github PHP simple-socket Oschina PHP simple-socket 当然也有更好的例如 workerman 之类的 socket 开源项目。但 socket 对于大部分 phper还是比较陌生的一个词语，百度上给出大部分网文关键字都是套接字，比较抽象难懂一些。socket即套接字，是用来与另一个进程进行跨网络通信的文件，说是“文件”，也很好理解哈，因为在linux中一切都可以理解为“文件”。比如客户端可以借助socket与服务器之间建立连接。你也可以把socket理解为一组函数库，它确实也就是一堆函数。我们知道，常见的网络应用都是基于Client-Server模型的。即一个服务器进程和多个客户端进程组合而成，如果你还理解为是一台电脑对另一台电脑，可以回去把进程/线程一文再看看了。在Client-Server模型中，服务器管理某种资源，并且通过对它管理的资源进行操作来为客户端提供服务。那Client和Server又如何实现通信呢？这就要利用socket一系列的函数实现了。基于套接字接口的网络应用的描述，用下面这张图来理解就好。 大致可以描述为： 服务器创建一个socket，绑定ip和端口，在该端口处进行监听，然后通过accept函数阻塞。当有新的客户端连接进来时，server接收客户端数据并处理数据，然后返回给客户端，客户端关闭连接，server关闭该客户端，一次连接交互完成。]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole 编译安装篇]]></title>
    <url>%2F2017%2F07%2F31%2Fswoole-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前边几篇文章，分别记录了 进程与线程 I/O 模型 网络通讯协议 其实都是为了我们更好的学习 Swoole 打下基础，Swoole 几乎涉及到网络开发的方方面面，但是这些可能不是每个 phper所具备的。学了那么多网络基础知识，下面我们开始慢慢的接触 Swoole，后边有需要补充的网络知识，也会文章记录。 环境安装部分我只针对我自己的电脑做安装记录，其他系统的同学可以网上找相关教程。 macOS Sierra 10.12.6 PHP 5.6.28 gcc make autoconf Swoole 2.0.7 编译安装 下载 Swoole 最新版本到本地，官网下载链接 下载好以后解压 终端执行编译：12345$ cd swoole$ phpize$ ./configure$ make $ sudo make install 执行完以上命令，中途没有报错的话，就表示已经安装完成。下面我们来检查一下到底有没有安装成功：1234$ php -m | grep swooleswoole$ php --ri swoole | grep VersionVersion =&gt; 2.0.7 到这里，已经完全没有问题了。如果你安装中碰到什么问题，可以留言，也可以直接联系，让我们共同应对问题，一起成长！]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole 网络通讯协议篇]]></title>
    <url>%2F2017%2F07%2F31%2Fswoole-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[平时我们打开一个浏览器，然后输入网址后回车，即展现了一个网页的内容。这是一个非常简单的操作。我们来简单的概括下背后的逻辑。 浏览器通过TCP/IP协议建立到服务器的TCP连接 客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档 服务器向客户端发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端 客户端与服务器断开，由客户端解释HTML文档，在客户端屏幕上渲染图形结果 表面上看这就是两台电脑之间进行的一种通信。更确切的说，是两台计算机上两个进程之间的通信。你打开浏览器相当于启动了一个浏览器进程，而服务端事先也启动了某个进程，在某个端口监听，时刻等待客户端的连接。 那么问题来了，为什么客户端可以请求到服务器呢？服务器上跑那么多服务，又是怎么知道客户端想要什么呢？其实答案很简单，因为有网络。计算机为了联网，就必须遵循通信协议。早期的互联网有很多协议，但是最重要的就非TCP协议和IP协议莫属了。所以，我们把互联网的协议简称为TCP/IP协议。 想必大家都有过这样的经历，客户端通过telnet连接服务器的时候，往往都需要一个ip地址和一个端口。如果客户端跟服务器之间有数据的交互，其过程大致是这样的： IP 协议IP协议负责把你本机的数据发送到服务端，数据被分割成一块一块的。然后通过IP包发送出去。IP包的特点是按块发送，但不保证能到达，也不保证数据块依次到达。如果是这样进行数据传输，服务器根本不能保证接收到的数据的完整性和顺序性，这样是不是就会有很大的问题呢？ TCP 协议于是乎，TCP协议应运而生，它是建立在IP协议之上，专门负责建立可靠连接，并保证数据包顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方顺序收到，如果出现丢包，则重新发送。这个时候再说TCP协议是一种面向连接、可靠的、基于IP之上的传出层协议就不难理解了吧。 TCP协议还有一个更重要的特点，它是基于数据流的。什么意思呢？这就好比客户端和服务端要进行数据交互，中间有一个管子连接着，这个时候交互数据就好比管子中的水，当数据在传输（水在流动）的过程中，服务端是无法知道哪段数据是我们想要的完整数据。怎么解决这一问题呢？这个时候就需要双方约定一个协议来解决了。再往后说就说到应用层协议了，比如http协议，我们姑且不谈。 UDP 协议TCP懂了，UDP自然就不难理解了。相对于TCP,使用UDP协议进行通信的最大区别就是，UDP不需要建立连接，给他一个ip和端口，就可以直接发送数据包了。但是，能不能成功到达就不知道了。虽然UDP传输不可靠，但是速度快。对于一些对数据要求不高的场景，使用UDP通信无疑是不错的选择。]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole I/O 模型]]></title>
    <url>%2F2017%2F07%2F31%2Fswoole-I-O-%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[I/O即Input/Output,输入和输出的意思。在计算机的世界里，涉及到数据交换的地方，比如磁盘、网络等，就需要I/O接口。通常，I/O是相对的。比如说你打开浏览器，通过网络I/O获取我们网站的网页，浏览器首先会往服务器发送请求，这是一个Output操作，随后服务器给浏览器返回信息，这就是一个Input操作。以上都是基于浏览器而言。但是，有些操作就比较特殊。比如程序在运行时，数据被加载在内存中，通过程序往磁盘写数据，对内存而言，这就是单方面的的Output。I/O模型通常有很多种，我们简单介绍下同步I/O和异步I/O。 同步I/O 实际上我们刚刚介绍的浏览器请求服务器的过程正是同步I/O的例子。 那我们再比如，假设我们要通过程序往磁盘写大量的数据，如果没有磁盘I/O操作，php程序在内存中执行的速度是非常快的，但是磁盘写数据的过程相对而言就是漫长的，CPU就需要等待磁盘I/O操作之后才能继续执行其他代码，像上面这两种情况，我们都称之为同步I/O。 php本身是单线程的，当php进程被挂起的时候，像上面的读取磁盘数据，往磁盘写数据，在I/O操作之前php代码就没办法继续执行了。因为I/O操作阻塞了当前线程，如果某用户也想从磁盘上读取或者写数据，就需要等待。 有些人要反驳了，这不对呀，我经历不是这样的，很多人可以同时访问我的网站，这没问题的。这个没必要纠结，php本身是单进程单线程的，用户可以同时访问你的网站实际上是web服务器的功劳。这就是我们之前讨论过的，如何解决多任务的问题。web服务器的进程模型暂时不多讨论，免得懵。如果不考虑web服务器，是不是当前进程一旦阻塞，其他人访问php都会被阻塞啦？答案是肯定的。要解决这个问题，又回到我们一直强调的多进程或者多线程。 但是，如果为了解决并发问题，系统开启了大量的进程，就像我们之前说的，操作系统在进程或者线程间切换同样会造成CPU大量的开销。有没有更好的解决方案呢？ 异步I/O答案就是异步I/O。我们再来强调一遍异步I/O是要解决什么问题的：同一线程内，执行一些耗时的任务时，其他代码是不能继续执行的，要等待该任务操作完之后才可以。 同步I/O和异步I/O区别同步I/O模型下，主线程只能被挂起等待，但是在异步I/O模型中，主线程发起I/O指令后，可以继续执行其他指令，没有被挂起，也没有切换线程的操作。由此看来，使用异步I/O明显可以提高了系统性能。 其实I/O模型远不止我们介绍的这两种，有兴趣的可以借助google更深层次的了解一下。]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole 进程与线程篇]]></title>
    <url>%2F2017%2F07%2F31%2Fswoole-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近公司的物联网设备架构有所调整，需要长连接保持，一直觊觎了很久的 Swoole 学习提上日程。至于 Swoole 是做什么的，Swoole官网给出了一堆很 NB 的介绍。总之你需要知道swoole是基于C开发的一个php扩展，类似你熟悉的Mysqli、cURL等等。但是swoole更强大，它几乎重新定义了php的高度，让php变得更加无可挑剔。也让phper们的前景更加辽阔！ 既然 Swoole 那边 NB 闪闪，感觉一副高大上的样子，那再学习之前必须要做好预习准备啦。下面的笔记借鉴了白狼栈的学习教程，有兴趣的同学可以付费认证的看上一遍，真的写的很不错！ 进程对于操作系统而言，进程就是一个任务，比方说你打开了一个记事本，那就启动了一个进程，打开了两个浏览器，就是另外开启了两个进程，简单的说一个进程至少要干一件事情。对于Linux 系统而言，如果你想查看当前系统中运行的进程，可以通过 ps命令进行查看：1$ ps aux | grep php 执行以上命令，我能够看到我机器上运行的 PHP 进程：12345$ ps aux | grep phpwww 2051 0.0 0.0 2484400 2572 ?? S 9:08上午 0:00.05 php-fpmwww 2050 0.0 0.0 2484528 2976 ?? S 9:08上午 0:00.16 php-fpmwww 2049 0.0 0.0 2471088 396 ?? Ss 9:08上午 0:00.68 php-fpmwww 59050 0.0 0.0 2442020 1968 s001 S+ 3:52下午 0:00.00 grep php 至于后边一堆时间什么的，如果不知道什么意思，建议看下鸟哥的 Linux 基础。 线程有些情况下，一个进程会同时做一些事情，比如说word。它可以同时进行打字、拼写检查等操作。注意这里我们说的同时进行。像这样，在一个进程内部，同时运行着多个“子任务”，我们就可以把这些子任务称之为“线程”。即进程是由多个线程组成的，一个进程至少要有一个线程。实际上，线程是操作系统最小的执行单元。 多任务的实现试想一下，如果我们要同时执行多个任务怎么办？ 根据上文的理解，我们可以： 启动多个进程 启动一个进程，并在该进程内启动多个线程 启动多个进程，每个进程内启动多个线程 多进程的实现熟悉 Apache 的同学其实很好理解。当父进程监听到有新的请求时，Apache 就回 fork出一个新的子进程来对之进行处理。Linux 的 fork（）函数通过系统调用即可实现创建一个与原进程几乎相同的进程。对于多任务，通常我们会设计Master-Worker模式，即一个Master进程负责分配任务，多个Worker进程负责执行任务。同理，如果是多线程，Master就是主线程，Worker就是子线程。 多进程与多线程的区别开始迷糊了对吧，那就理解一下多进程和多线程的区别吧，以便应对场景做出合适的选择。进程和线程的关系就像地主和佃户。地主，有土地（系统资源）；佃户，执行种地流程； 多进程的优点就是稳定性很高，如果一个进程挂了，不会影响其他子进程，当然，如果主进程挂了那就都玩完（主进程挂掉的可能性微乎其微，后面讲进程模型会说到）。而对于多线程，这个恐怕就是致命的缺点了，因为所有线程共享内存，如果某一个线程挂了，那这个进程几乎就崩溃了。 性能方面，不论是进程还是线程，如果启动太多，无疑都会带来CPU的调度问题，因为进程或者线程的切换，本身就非常耗费资源。数量达到一定程度的时候，CPU和内存就消耗殆尽，电脑就死机了。举一个例子：使用过windows的用户都知道，如果我们打开的软件越多（开启的进程也就越多），电脑就会越卡，甚至装死机没反应。 线程与进程相比，自然是要比进程更轻量一些，而且线程之间是共享内存的，所以不同线程之间的交互就显得容易实现。而对于多进程之间的通信，需要借助消息队列，共享内存等复杂的方式才可以实现。 进程和线程一定要研究明白是怎么回事思考一下php、nginx、apache各自跟线程和进程是什么关系，可百度，可google，可下面留言。]]></content>
      <categories>
        <category>PHP</category>
        <category>Swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的评论系统]]></title>
    <url>%2F2017%2F07%2F28%2F%E6%96%B0%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[继多说关闭以后,网易又随之而去.这对于没有自己搭建评论系统的我来说,无疑是一个非常不愉快的消息.but,今天新的评论系统终于安装成功,经过了十几天的域名备案,大家又可以畅所欲言了.]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>微语</tag>
        <tag>胡侃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 请求(Requests)]]></title>
    <url>%2F2017%2F07%2F22%2FYii2-%E8%AF%B7%E6%B1%82-Requests%2F</url>
    <content type="text"><![CDATA[这篇不讲插件，讲一下 Yii2的请求（Requests），强行安利一波。 请求参数要获取请求参数，你可以调用 request 组件的 get() 方法和 post() 方法。 他们分别返回 $_GET 和 $_POST 的值。例如：12345678910111213141516171819$request = Yii::$app-&gt;request;$get = $request-&gt;get(); // 等价于: $get = $_GET;$id = $request-&gt;get(&apos;id&apos;); // 等价于: $id = isset($_GET[&apos;id&apos;]) ? $_GET[&apos;id&apos;] : null;$id = $request-&gt;get(&apos;id&apos;, 1); // 等价于: $id = isset($_GET[&apos;id&apos;]) ? $_GET[&apos;id&apos;] : 1;$post = $request-&gt;post(); // 等价于: $post = $_POST;$name = $request-&gt;post(&apos;name&apos;); // 等价于: $name = isset($_POST[&apos;name&apos;]) ? $_POST[&apos;name&apos;] : null;$name = $request-&gt;post(&apos;name&apos;, &apos;&apos;); // 等价于: $name = isset($_POST[&apos;name&apos;]) ? $_POST[&apos;name&apos;] : &apos;&apos;; 如果嫌每次都要这么写一大堆很麻烦的话，下面就教你一个简单的。首先你所有的Controller都要继承一个BaseController，然后在你的BaseController里添加一下方法：1234public function post($param = null, $default_value = null)&#123; return !$param ? Yii::$app-&gt;request-&gt;post() : Yii::$app-&gt;request-&gt;post($param, $default_value);&#125; 那么其他Controller用的时候就可以直接这样写：1234567public function actionIndex()&#123; // 无默认值 $name = $this-&gt;post(&apos;name&apos;); // 有默认值 $name = $this-&gt;post(&apos;name&apos;,&apos;ewan&apos;);&#125; 我上边只实例了 POST 请求，GET 请求同理，需要的话可以直接加上就可以了。 请求方法你可以通过 Yii::$app-&gt;request-&gt;method 表达式来获取当前请求使用的HTTP方法。 这里还提供了一整套布尔属性用于检测当前请求是某种类型。 例如：123456$request = Yii::$app-&gt;request;if ($request-&gt;isAjax) &#123; /* 该请求是一个 AJAX 请求 */ &#125;if ($request-&gt;isGet) &#123; /* 请求方法是 GET */ &#125;if ($request-&gt;isPost) &#123; /* 请求方法是 POST */ &#125;if ($request-&gt;isPut) &#123; /* 请求方法是 PUT */ &#125; 请求URLs假设被请求的URL是 http://example.com/admin/index.php/product?id=100，你可以像下面描述的那样获取URL的各个部分： yii\web\Request::url：返回 /admin/index.php/product?id=100, 此URL不包括host info部分。 yii\web\Request::absoluteUrl：返回 http://example.com/admin/index.php/product?id=100, 包含host infode的整个URL。 yii\web\Request::hostInfo：返回 http://example.com, 只有host info部分。 yii\web\Request::pathInfo：返回 /product， 这个是入口脚本之后，问号之前（查询字符串）的部分。 yii\web\Request::queryString：返回 id=100,问号之后的部分。 yii\web\Request::baseUrl：返回 /admin, host info之后， 入口脚本之前的部分。 yii\web\Request::scriptUrl：返回 /admin/index.php, 没有path info和查询字符串部分。 yii\web\Request::serverName：返回 example.com, URL中的host name。 yii\web\Request::serverPort：返回 80, 这是web服务中使用的端口。 HTTP头你可以通过 yii\web\Request::headers 属性返回的 header collection 获取HTTP头信息。 例如：1234567// $headers 是一个 yii\web\HeaderCollection 对象$headers = Yii::$app-&gt;request-&gt;headers;// 返回 Accept header 值$accept = $headers-&gt;get(&apos;Accept&apos;);if ($headers-&gt;has(&apos;User-Agent&apos;)) &#123; /* 这是一个 User-Agent 头 */ &#125; 请求组件也提供了支持快速访问常用头的方法，包括： yii\web\Request::userAgent：返回 User-Agent 头。 yii\web\Request::contentType：返回 Content-Type 头的值， Content-Type 是请求体中MIME类型数据。 yii\web\Request::acceptableContentTypes：返回用户可接受的内容MIME类型。 返回的类型是按照他们的质量得分来排序的。得分最高的类型将被最先返回。 yii\web\Request::acceptableLanguages：返回用户可接受的语言。 返回的语言是按照他们的偏好层次来排序的。第一个参数代表最优先的语言。 假如你的应用支持多语言，并且你想在终端用户最喜欢的语言中显示页面， 那么你可以使用语言协商方法 yii\web\Request::getPreferredLanguage()。 这个方法通过 yii\web\Request::acceptableLanguages 在你的应用中所支持的语言列表里进行比较筛选，返回最适合的语言。 提示: 你也可以使用 ContentNegotiator 过滤器进行动态确定哪些内容类型和语言应该在响应中使用。 这个过滤器实现了上面介绍的内容协商的属性和方法。 客户端信息你可以通过 yii\web\Request::userHost 和 yii\web\Request::userIP 分别获取host name和客户机的IP地址， 例如：12$userHost = Yii::$app-&gt;request-&gt;userHost;$userIP = Yii::$app-&gt;request-&gt;userIP;]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 文件上传插件]]></title>
    <url>%2F2017%2F07%2F22%2FYii2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[文件上传的需求也是必不可少，带飞一波。 文件上传插件 yii2-widget-fileinputyii2-widget-fileinput小部件是基于Krajee的Bootstrap FileInput JQuery插件的定制文件输入小部件。想了解的话，可以点连接进入 GitHub 查看详细信息。 安装切换到项目目录下1$ cd project 安装方法一执行 composer安装1$ composer require kartik-v/yii2-widget-fileinput &quot;@dev&quot; 安装方法二在项目目录下的composer.json文件中如下内容12345&quot;require&quot;: &#123; ..., &quot;kartik-v/yii2-widget-fileinput&quot;: &quot;@dev&quot;, ...&#125; 执行composer更新1$ composer update 使用 FileInput 插件插件的使用可以分为两种，一种是独立的使用，一种是结合 Yii2的ActiveForm组件使用 独立使用直接调用，在视图文件中写入如下代码：12345678use kartik\file\FileInput;echo &apos;&lt;label class=&quot;control-label&quot;&gt;Add Attachments&lt;/label&gt;&apos;;echo FileInput::widget([ &apos;model&apos; =&gt; $model, &apos;attribute&apos; =&gt; &apos;attachment_1&apos;, &apos;options&apos; =&gt; [&apos;multiple&apos; =&gt; true]]); 结合ActiveForm表单组件使用12345use kartik\file\FileInput;echo $form-&gt;field($model, &apos;avatar&apos;)-&gt;widget(FileInput::classname(), [ &apos;options&apos; =&gt; [&apos;accept&apos; =&gt; &apos;image/*&apos;],]);]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 时间插件]]></title>
    <url>%2F2017%2F07%2F22%2FYii2-%E6%97%B6%E9%97%B4%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目开发中难免会用到时间插件，这里我找了一个使用比较广泛的时间插件。用法如下： 时间插件 yii2-widget-datetimepickeryii2-widget-datetimepicker小部件是一个用于引导DateTimePicker插件的Yii 2包装器，它具有各种增强功能。想了解的话，可以点连接进入 GitHub 查看详细信息。 安装切换到项目目录下1$ cd project 安装方法一执行 composer安装1$ composer require kartik-v/yii2-widget-datetimepicker &quot;*&quot; 安装方法二在项目目录下的composer.json文件中如下内容12345&quot;require&quot;: &#123; ..., &quot;kartik-v/yii2-widget-datetimepicker&quot;: &quot;*&quot;, ...&#125; 执行composer更新1$ composer update 使用 DateTimePicker 插件插件的使用可以分为两种，一种是独立的使用，一种是结合 Yii2的ActiveForm组件使用 独立使用直接调用，在视图文件中写入如下代码：12345678910111213use kartik\datetime\DateTimePicker;echo &apos;&lt;label&gt;Start Date/Time&lt;/label&gt;&apos;;echo DateTimePicker::widget([ &apos;name&apos; =&gt; &apos;datetime_10&apos;, &apos;options&apos; =&gt; [&apos;placeholder&apos; =&gt; &apos;Select operating time ...&apos;], &apos;convertFormat&apos; =&gt; true, &apos;pluginOptions&apos; =&gt; [ &apos;format&apos; =&gt; &apos;d-M-Y g:i A&apos;, &apos;startDate&apos; =&gt; &apos;01-Mar-2014 12:00 AM&apos;, &apos;todayHighlight&apos; =&gt; true ]]); 结合ActiveForm表单组件使用123456789101112131415161718&lt;?phpuse kartik\datetime\DateTimePicker;?&gt;&lt;?php $form = ActiveForm::begin(); ?&gt;&lt;?= $form-&gt;field($model, &apos;created_at&apos;)-&gt;widget(DateTimePicker::classname(), [ &apos;options&apos; =&gt; [&apos;placeholder&apos; =&gt; &apos;&apos;], &apos;pluginOptions&apos; =&gt; [ &apos;autoclose&apos; =&gt; true, &apos;format&apos; =&gt; &apos;yyyy-mm-dd hh:ii&apos;, &apos;startDate&apos; =&gt; &apos;01-Mar-2014 12:00 AM&apos;, &apos;todayHighlight&apos; =&gt; true ] ]);?&gt;&lt;?php ActiveForm::end(); ?&gt;]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 批量插入]]></title>
    <url>%2F2017%2F07%2F21%2FYii2-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在使用Yii2开发的过程中难免会遇到批量插入的问题，下边实例一下批量插入的操作。12345678910111213$goods_model = new Goods();# 获取表名$table_name = $goods_model-&gt;tableName();# 要插入数据的字段 $fields = [&apos;name&apos;,&apos;price&apos;]；$fields = $goods_model-&gt;attributes();array_shift($fields);# 要插入的数据，这里要自己拼装，要和字段对应上$data = [[&apos;电视机&apos;，2999]，[&apos;电脑&apos;，3888]];# 返回总插入条数$total_num = Yii::$app-&gt;db-&gt;createCommand()-&gt;batchInsert($table_name, $fields, $data)-&gt;execute(); 批量插入的时候最好和 model 事务搭配，这样可以保证数据的完整性，也方便检查错误。]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache 无法启动]]></title>
    <url>%2F2017%2F07%2F20%2FApache-%E5%9B%A0%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[今天我一台 Windows 测试机 WAMP 的 Apache 无法启动，找了一下原因，原来 Apache 上某个监听的端口被占用，导致无法启动。下面把发现问题，和解决问题的思路写一下。 问题：WAMP 的 Apache 无法启动重启电脑后，打开 WAMP 一直显示橙色的图标，显示有一个程序无法启动。 问题原因：Apache 因监听端口被占用无法启动试了下 PHP 等正常运行无误，确认是 Apache 的问题，但是不知道为什么启动不了。 手动启动 Apache我打开终端，将 Apache 的运行文件\wamp64\bin\apache\apache2.4.23\bin\httpd.exe拖到终端中执行，显示一下错误：12345$ D:\wamp64\bin\apache\apache2.4.23\bin\httpd.exe(OS 10048)通常每个套接字地址(协议/网络地址/端口)只允许使用一次。 : AH00072: make_sock: could not bind to address 0.0.0.0:8080AH00451: no listening sockets available, shutting downAH00015: Unable to open logs 此处可以看出错误，是因为 Apache 监听的8080端口被别的程序占用，导致无法启动。 解决问题：使 Apache 正常运行问题找到了就好办了，一下给出两种解决的办法。 第一种，更换 Apache 监听的8080端口至别的端口此种方法相对简单一些，如果在没有强制端口需求的情况下，也是最为推荐的方法。打开你的Apache 虚拟主机配置文件\wamp64\bin\apache\apache2.4.23\conf\extra\httpd-vhosts.com,找到冲突的端口配置，如下：12345&lt;VirtualHost *:8080&gt; ... ... ...&lt;/VirtualHost&gt; 将8080（冲突的端口）修改为其他的端口号，重启 WAMP 或者 Apache就可以正常运行了。 第二种，kill 掉占用冲突端口的程序比如你就想使用这个端口，或者有强制需求要用这个端口，那就需要干掉占用这个端口的程序了。 找到占用冲突端口的进程号在终端执行命令，查看机器端口占用情况：1$ netstat -ano 会显示如下内容：123456789101112活动连接 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 976 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:2343 0.0.0.0:0 LISTENING 1972 TCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 3732 TCP 0.0.0.0:3389 0.0.0.0:0 LISTENING 1532 TCP 0.0.0.0:3580 0.0.0.0:0 LISTENING 2100 TCP 0.0.0.0:3582 0.0.0.0:0 LISTENING 2620 TCP 0.0.0.0:8080 0.0.0.0:0 LISTENING 3348 TCP 0.0.0.0:9418 0.0.0.0:0 LISTENING 4848 通过上面的内容我们会看到监听8080端口的PID（进程号） 为3348。 干掉 PID 为3348的程序右击桌面底部的工具栏，选择启动任务管理器，然后点击服务，找到 PID 为3348的程序，右击选择停止服务，这样就可以了。右击工具栏--&gt;启动任务管理器--&gt;服务--&gt;右击 PID 为3348的服务--&gt;停止服务重启 WAMP 或者 Apache就可以正常运行了。 其实解决问题并不难，重要的是我们怎么样才能正确的找到问题的所在，这需要我们平时要树立一套比较合理的处理的问题的思路，要做一个有思想的开发者!]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>WAMP</tag>
        <tag>计算机</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 底部修改]]></title>
    <url>%2F2017%2F07%2F20%2FHexo-%E5%BA%95%E9%83%A8%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[如果你想将博客底部修改的话，找到/themes/next/layout/_partials/footer.swig，你可以按照你想要的内容编写 HTML 代码，就想我这样：12345678910111213141516171819&#123;% if theme.copyright %&#125;&lt;div class=&quot;powered-by&quot;&gt; &lt;span class=&quot;links-of-author-item&quot;&gt; &lt;a href=&quot;https://github.com/yangyiyuan&quot; target=&quot;_blank&quot; title=&quot;GitHub&quot;&gt; &lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;/i&gt; GitHub &lt;/a&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;theme-info&quot;&gt; &lt;span class=&quot;links-of-author-item&quot;&gt; &lt;a href=&quot;http://www.iooeo.com/about/&quot; target=&quot;_blank&quot; title=&quot;杨依园&quot;&gt; &lt;i class=&quot;fa fa-fw fa-hand-o-right&quot;&gt;&lt;/i&gt; 做一个有思想的开发者---杨依园 &lt;/a&gt; &lt;/span&gt;&lt;/div&gt;&#123;% endif %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 文章版权转载链接]]></title>
    <url>%2F2017%2F07%2F20%2FHexo-%E6%96%87%E7%AB%A0%E7%89%88%E6%9D%83%E8%BD%AC%E8%BD%BD%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[如果文章末尾需要添加版权信息和转载链接的话，找到/hemes/next/layout/_macro/post.swig，找到其中的打赏部分代码，如下所示：12345&lt;div&gt; &#123;% if ! is_index %&#125; &#123;% include &apos;reward.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改成下面这个样子：12345678910&lt;div align=&quot;center&quot;&gt; &#123;% if not is_index %&#125; &lt;div class=&quot;copyright&quot;&gt; &lt;p&gt;&lt;span&gt; &lt;b&gt;本文地址：&lt;/b&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;br/&gt;&lt;b&gt;转载请注明出处，谢谢！&lt;/b&gt; &lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &#123;% include &apos;reward.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 头像圆形并旋转]]></title>
    <url>%2F2017%2F07%2F20%2FHexo-Next-%E5%A4%B4%E5%83%8F%E5%9C%86%E5%BD%A2%E5%B9%B6%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[将头像显示成圆形，鼠标放上去有旋转效果，就像我的一样.找到/themes/next/source/css/_common/components/sidebar/sidebar-author.styl做以下修改：12345678910111213141516171819202122232425262728293031323334353637383940.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; # 头像圆形样式 /* start */ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125;# 头像旋转事件/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 表单提交错误调试]]></title>
    <url>%2F2017%2F07%2F20%2FYii2-%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在使用yii 开发项目的时候经常碰到一些数据插入时提交失败的情况，为了更精准的找到错误，yii 给我提供一下方法，用以调试12echo current(array_values($model-&gt;getFirstErrors()));exit; model调用load()方法时出错时，用这个方法也可以]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Python 版本切换]]></title>
    <url>%2F2017%2F07%2F20%2FMac-Python-%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Mac 上自带的 Python 版本是2.7的，对于编程语言的发展来说，每一个大的版本更新都有很大的改变，所以我碰到了版本切换的问题。 下载安装新版本首先去官网下载一个最新的Python 版本，下载链接下载好以后下一步下一步安装就可以了。 切换 Python 版本安装好以后不代表就完成版本切换了。不信的话，你可以终端执行一下1$ python -V 显示的还是2.7（老版本）的版本，那下面就开始切换吧 首先要找到你新版本安装的路径/usr/local/bin/python3 修改软链接到你所安装的python版本中：默认python命令是在/usr/bin/目录下 12$ sudo mv /usr/bin/python /usr/bin/python2.7.0$ sudo ln -s /usr/local/bin/python3 /usr/bin/python #把系统默认python命令改成python3 完成以后在终端输入python -V即可查看python版本了，反正我是是最新的版本了。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 开篇]]></title>
    <url>%2F2017%2F07%2F20%2Fpython-%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Python 是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议 。Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用扩展类库时可能需要考虑平台问题，某些可能不提供跨平台的实现。由于没有实际项目运用，后边的文章权当是学习笔记了，可能只是一些基础的知识点，从各种博客文档中都能找得到，但写下自己的学习心得还是有必要的，希望在以后能有项目去运用到，这样我所学习的就不仅仅是一些基础的知识点了。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 新建菜单(menu) 存放归档文章]]></title>
    <url>%2F2017%2F07%2F20%2FHexo-%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95-menu-%E5%AD%98%E6%94%BE%E5%BD%92%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[最近在看Python，想在首页上建一个名为Python的菜单，然后相关Python的文章都放在该分类下。本来的想法是点开 Python 菜单会显示像首页的一样的文章列表，但试了几次没有成功，索性就就采取了一种分类归档的方法，效果还可以。 生成 post(文章)时默认生成 categories 配置项在项目目录下找到/scaffolds/post.md，添加文章的 categories 的配置，如下12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: # 此处为文章标签categories: # 此处为文章分类--- 写文章时，配置 categories下面我开始写一篇关于 Python 的文章1$ hexo n &quot;python 开篇&quot; 文章里面配置 categories123456789---title: python 开篇date: 2017-07-20 10:22:43tags: - pythoncategories: - python---Python 是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。 此处我已经配置好了标签（tags）和分类（categories），下面生成一下静态页面1$ hexo g 这时你会发现/public/categories/文件夹下，已经生成了python的文件夹 首页显示 python 菜单这里就是要在博客首页上显示 python 菜单的时候了，首先打开你主题的配置文件/themes/next/_config.yml(我这里是用的 next)。找到menu ，做一下添加12345678menu: home: / categories: /categories/ archives: /archives/ tags: /tags/ python: /categories/python/ # 此处为新添加的菜单 guestbook: /guestbook about: /about/ 配置python菜单所用的图标12345678910111213menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat guestbook: pencil python: file-powerpoint-o # 此处为 python菜单的图片配置 菜单名称配置上面的步骤做完以后，如果你着急刷新页面看了效果，就会看到新菜单的名称是menu.python，显然不是我们想要的，那就继续往下看首先查看项目目录下的/_config.yml的language配置，我的是这样的1language: zh-Hans 然后去模板目录找到相应的语言配置文件/themes/languages/zh-Hans.yml，menu处添加一下配置123456789101112menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 guestbook: 留言 python: python # python菜单显示的名称 这样就算彻底完成了，赶紧去看看效果吧。以后写Python 相关的文章的话，只需要配置 categories 为 python 就可以自动归档到python 菜单下了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[评论系统相继关闭]]></title>
    <url>%2F2017%2F07%2F07%2F%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%9B%B8%E7%BB%A7%E5%85%B3%E9%97%AD%2F</url>
    <content type="text"><![CDATA[前段时间,多说系统宣布关闭停止服务,偶感还挺可惜的.最近折腾这上了网易跟帖,来替换多说,今天登陆网易跟帖后台,又看到了一个不好的消息 网易云跟贴停止服务公告亲爱的朋友们： 因公司业务发展需要，我们不得不遗憾地通知大家，云跟贴产品将于2017年8月1日停止服务。在此之前可以通过后台的数据导出功能导出自己站点的跟贴数据。感谢大家一直以来对云跟贴的支持与厚爱，对于此次产品关停给您带来的不便我们深表歉意，希望在网易其他产品与业务上，我们能继续为您服务！ 网易云跟贴 2017年7月6日]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>微语</tag>
        <tag>胡侃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lantern Mac版编译 免费]]></title>
    <url>%2F2017%2F07%2F07%2Flantern-Mac%E7%89%88%E7%BC%96%E8%AF%91-%E5%85%8D%E8%B4%B9%2F</url>
    <content type="text"><![CDATA[蓝灯,Mac版编译 HomebrewHomebrew,macOS 缺失的软件包管理器,没用过的可以过去了解一下Homebrewlantern之前先安装一下Homebrew,终端输入1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Homebrew安装完成以后,安装git,已安装的可以忽略1$ brew install git Node安装 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型,使其轻量又高效 Node.js 的包管理器 npm,是全球最大的开源库生态系统Node下载,选择Mac版下载,安装下一步下一步就行…. 其他预安装1234$ brew install go$ npm i gulp-cli -g$ npm install -g appdmg$ npm install -g svgexport lantern Mac编译找个文件夹把lantern下载下来可以直接用GitHub下载,cd到你放置lantern的文件夹,终端输入命令如下1$ git clone --depth=1 https://github.com/getlantern/lantern.git 下载以后123$ cd lantern$ export VERSION=9.9.9$ make darwin 编译的时候回出现以下错误根据错误信息指出的路径在lantern文件夹中找到对应的文件及行数 只需要把MaxIdleTime改为IdleConnTimeout 然后把下面紧接的调用EnforceMaxIdleTime()这个方法的语句注释掉 就改这两个文件中的4行就行,重新编译1$ make darwin 编译完成后,你会在你的lantern文件夹中找到名为lantern_darwin_amd64的文件,说明完全没问题了 运行然后在你的Mac上搜索一下lantern_darwin_amd64,双击打开就可以了]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>lantern</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+coding搭建个人博客 - 百度和Google收录篇]]></title>
    <url>%2F2017%2F07%2F04%2FHexo%2BGithub%2Bcoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20-%20%E7%99%BE%E5%BA%A6%E5%92%8CGoogle%E6%94%B6%E5%BD%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[网站地图 网站地图，又称站点地图，它就是一个页面，上面放置了网站上需要搜索引擎抓取的所有页面的链接（注：不是所有页面）。大多数人在网站上找不到自己所需要的信息时，可能会将网站地图作为一种补救措施。搜索引擎蜘蛛非常喜欢网站地图 Hexo博客生产站点地图进入Hexo博客根目录，安装百度和Google的站点地图生成插件12$ npm install hexo-generator-baidu-sitemap --save$ npm install hexo-generator-sitemap --save 在博客根目录的_config.yml配置文件种添加一下代码12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 编译部署博客代码12$ hexo generate$ hexo deploy 边已完成,你会发现你的博客编译完成的代码目录public种生成了baidusitemap.xml和sitemap.xml此时我们访问域名下面的这两个文件,看看有没有 http://www.iooeo.com/baidusitemap.xml http://www.iooeo.com/sitemap.xml 这样百度和Google的爬虫就可以通过这个来爬取你的博客内容了 查看博客是否已经被收录在百度和Google分别输入搜索:1site:iooeo.com 这里需要将iooeo.com换成你们自己的域名 百度验证网站 百度链接提交 在链接提交输入框中输入你的域名,点击提交即可 验证站点1234567点击站点管理,依次输入信息第二步*验证网站*,选择文件验证,下载验证文件将验证文件放在所应用的主题的source下`/themes/主题/source/`执行文件部署$ hexo generate$ hexo deploy部署完成之后点击立即验证或者直接访问,域名/百度验证文件名,下边是我的 http://www.iooeo.com/baidu_verify_a501VUvpmw.html 链接提交点击链接提交,选择网站如何选择链接提交方式12341、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。4、手动提交：一次性提交链接给百度，可以使用此种方式。 sitemap提交 这个时候需要用到上面生产的sitemap了,选择自动提交种的sitemap,将http://www.iooeo.com/baidusitemap.xml粘贴到输入框内,输入验证码,点击提交下面的列表就会出现你添加的sitemap链接了,这个时候状态栏显示的应该是等待,一般过几十秒刷新一下页面就会正常,然后百度就会自动的周期抓取你的sitemap 自动推送 安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。可以将下面代码添加到post模板中,这样每篇文章生成的时候都会有自动推送代码最直接的就是直接添加到主题目录下的layout/post.swig文件下 1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) &#123; bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; &#125; else &#123; bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 主动推送 主动推送最为快速的提交方式,是被百度收录最快的推送方式百度提供了主动推送的示例:支持curl、php、python、java、php、ruby等等方式,你可以自己选择一种进行主动推送具体使用帮助请看主动推送教程 Google验证网站Google站点提交入口添加站点…验证站点…下载文件…步骤基本跟百度一样…]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>coding</tag>
        <tag>Markdown</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+coding搭建个人博客 - 配置域名分流解析篇]]></title>
    <url>%2F2017%2F07%2F04%2FHexo%2BGithub%2Bcoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20-%20%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D%E5%88%86%E6%B5%81%E8%A7%A3%E6%9E%90%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前边我们已经分别介绍了,Hexo 本地安装,Hexo GitHub 代码部署,Hexo Coding 代码部署实现了通过外网访问自己的博客 Hexo 本地安装篇 Hexo GitHub 篇 Hexo Coding 篇 如果你没有自己的域名的话,可能就到此为止了,如果你有属于自己的域名的话,惊喜还在后面,请继续…. 项目内域名配置打开你的Hexo项目,在/source/目录下创建以CNAME为文件名称的文件内容:1www.iooeo.com www.iooeo.com是我的域名,此处该成你自己的就可以了.然后执行Hexo部署命令1$ hexo deploy 分别登陆Coding和GitHub,进入项目,点击项目的Pages 服务,绑定你的域名GitHub好像自动给添加了Coding更新了新版本以后,绑定域名必须要会员等级黄金以上,开始商业化了.白银级别的要经过Coding页面5秒钟跳转,而且国内访问GitHub也不是太慢了,现在建议直接走GitHub了,可以忽略Coding部分 域名服务商配置域名解析添加两条CNAME解析记录,主机记录分别是@和www,解析线路全部为默认,记录值全部为youName.github.io Coding没升级之前,Coding负责国内域名分流,GitHub负责国外域名分流,而且Coding访问稍微快一些. 但是可以这种模式没能继续下去,因为Coding已经走向商业化了.当然你要是选择付费升级会员的话,可以继续使用以下这种模式.12添加两条CNAME解析记录,主机记录分别是@和www,解析线路全部为默认,记录值全部为youName.coding.me,确保Coding上项目内Pages 服务已绑定域名添加两条CNAME解析记录,主机记录分别是@和www,解析线路全部为海外,记录值全部为youName.github.io]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>coding</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+coding搭建个人博客 - Coding 篇]]></title>
    <url>%2F2017%2F07%2F04%2FHexo%2BGithub%2Bcoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20-%20Coding%20%E7%AF%87%2F</url>
    <content type="text"><![CDATA[有Coding的直接登录,没有的Coding注册 创建仓库添加项目,填写项目名称/描述…当然这个名字的格式最好为youName(youName为你的Coding用户名)，例如我的为Mercis 配置SSH KeyGitHub篇已经讲过了,步骤差不多,现在直接将.ssh/id_rsa.pub的内容copy到Coding-&gt;个人设置-&gt;SSH 公匙,添加即可添加好SSH Key 以后测试,返回 Hi youName!…..表示成功1$ ssh -T git@git.coding.net 部署Hexo项目到Coding打开Hexo博客目录下的站点配置文件_config.yml，经过之前GitHub篇我们的配置已经是：1234deploy: type: git repo: git@github.com:Mercis/Mercis.github.io.git branch: master 现在需要改成这样:123456deploy: type: git repo: github: git@github.com:Mercis/Mercis.github.io.git coding: git@git.coding.net:mercis/mercis.git branch: master 这个地方值得注意的是当部署仓库有多个时,需要将repo改成键值对的格式,前面的名称可以规范为代码托管平台的名称,自己能区分就行,还是提示一下,yml 格式文件冒号(:)后面必须有一个空格执行Hexo部署命令,执行成功后,登录Coding项目已经有你Hexo项目文件了1$ hexo deploy 开启Coding Pages功能点击项目的Pages服务,部署来源选择master 分支,点击保存,访问http://youName.coding.me/就可以了,这样Coding部署已经正式完成了]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>coding</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+coding搭建个人博客 - GitHub 篇]]></title>
    <url>%2F2017%2F07%2F03%2FHexo%2BGithub%2Bcoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20-%20GitHub%20%E7%AF%87%2F</url>
    <content type="text"><![CDATA[有GitHub的直接登录,没有的GitHub注册 创建仓库仓库(Repository)用来放置代码文件,登录之后点击右上角加号,点击New repository创建时,只需要填写Repository name即可,当然这个名字的格式必须为youName.github.io(youName为你的Github用户名)，例如我的为Mercis.github.io 配置SSH Key为了防止每次部署需要输入密码的麻烦,这里使用SSH Key登录生成SSH Key,yourEmail@example.com 替换为你自己的邮箱,过程中需要输入密码等操作,可以全部回车使用默认的1$ ssh-keygen -t rsa -b 4096 -C &quot;yourEmail@example.com&quot; 完成之后,用户目录下回多一个.ssh文件夹,里面包含id_rsa和id_rsa.pub两个文件复制id_rsa.pub中的内容添加SSH key到GitHub123456进入GitHub账号设置页面左侧选择 **SSH and GPG keys**点击 **New SSH key** 或者 **Add SSH key**在&apos;Title&apos;字段中填写此SSH Key的名称，在&apos;Key&apos;字段中填写上面复制好的内容点击 **Add SSH key**输入账户密码确定操作 测试SSH Key 是否配置成功,返回 Hi youName!…..表示成功1$ ssh -T git@github.com 详细步骤请查看GitHub官方添加SSH Key教程 部署Hexo项目到GitHub部署之前,安装hexo-deployer-git插件1$ npm install hexo-deployer-git --save 打开Hexo博客目录下的站点配置文件_config.yml，修改部署配置：1234deploy: type: git repo: git@github.com:youName/youName.github.io.git branch: master 执行Hexo部署命令,执行成功后,登录GitHub项目已经有你Hexo项目文件了1$ hexo deploy 开启GitHub Pages功能因为youName.github.io项目名称是用的youName,所以GitHub Pages是默认配置好的 添加新文章创建文章1$ hexo new &quot;myNewPost&quot; 编辑文章内容打开Hexo博客目录下的source/_post/myNewPost.mdHexo 中文章是使用的Markdown语法，不知道MarkDown的自行百度,附送非官方链接语法说明12345678910111213---title: myNewPost #最后生成的页面Titletags: - tag1 - tag2 # 文章标签categories: - category1 #文章分类date: 2016-08-31 23:41:19 # 文章发表日期---这里是文章正文。可以写文章首页简介&lt;!--more--&gt;这里的内容是查看详情才显示的 编辑完新文章之后生成静态文件1$ hexo g 本地预览1$ hexo server 发布到GitHub1$ hexo deploy 然后就可以去你的youName.github.io查看一下啦….]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>coding</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+coding搭建个人博客 - Hexo 本地安装篇]]></title>
    <url>%2F2017%2F07%2F03%2FHexo%2BGithub%2Bcoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20-%20Hexo%20%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[之前自己摸摸索索把博客搭建好了,最近有人问我怎么搭建的,这里把搭建流程跟大家说下吧 开始前准备账号相关: GitHub Coding 域名 服务相关: Git Node.js Hexo 安装和配置Hexo官网1$ npm install hexo-cli -g 初始化Hexo博客目录,时间可能要久一点…1$ hexo init blog 安装依赖包12$ cd blog$ npm install 生成静态网站1$ hexo generate 本地测试,生成的链接localhost:4000,copy到浏览器直接访问就可以看到效果了.1$ hexo server 本地hexo安装已经完毕,可本地运行]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>coding</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 安装AdminLTE后台主题资源包]]></title>
    <url>%2F2017%2F03%2F31%2FYii2%20%E5%AE%89%E8%A3%85AdminLTE%E5%90%8E%E5%8F%B0%E4%B8%BB%E9%A2%98%E8%B5%84%E6%BA%90%E5%8C%85%2F</url>
    <content type="text"><![CDATA[为了快捷开发后台和界面的统一,这里我们引入了AdminLTE主题资源包AdminLTE的学习请移至dmstr/yii2-adminlte-asset 安装使用composer安装1$ composer require dmstr/yii2-adminlte-asset &quot;2.*&quot; 使用主题方式一复制整个vendor/dmstr/yii2-adminlte-asset/example-views/yiisoft/yii2-app目录下的layouts目录和site目录到backend/views,覆盖原始文件 方式二在backend/config/main.php中添加一下配置123456789&apos;components&apos; =&gt; [ &apos;view&apos; =&gt; [ &apos;theme&apos; =&gt; [ &apos;pathMap&apos; =&gt; [ &apos;@app/views&apos; =&gt; &apos;@vendor/dmstr/yii2-adminlte-asset/example-views/yiisoft/yii2-app&apos; ], ], ],], 查看效果如果你backend下没有做任何操作的情况下,你会看到登陆页面已经变了.如果想看一下AdminLTE主题的具体效果,将backend/controllers/SiteController.php做一下修改暂时将行为方法注释12345678910111213141516171819202122232425262728public function behaviors() &#123; return [ /** * 注释此处,阻止行为方式,查看AdminLTE主题模板效果 &apos;access&apos; =&gt; [ &apos;class&apos; =&gt; AccessControl::className(), &apos;rules&apos; =&gt; [ [ &apos;actions&apos; =&gt; [&apos;login&apos;, &apos;error&apos;], &apos;allow&apos; =&gt; true, ], [ &apos;actions&apos; =&gt; [&apos;logout&apos;, &apos;index&apos;], &apos;allow&apos; =&gt; true, &apos;roles&apos; =&gt; [&apos;@&apos;], ], ], ], */ &apos;verbs&apos; =&gt; [ &apos;class&apos; =&gt; VerbFilter::className(), &apos;actions&apos; =&gt; [ &apos;logout&apos; =&gt; [&apos;post&apos;], ], ], ]; &#125; 然后访问首页,就可以看到AdminLTE主题的具体效果 AdminLTE学习 主题一些简单的页面实例,及学习文档也可以查看vendor/almasaeed2010/adminlte/index.html 主题实例vendor/almasaeed2010/adminlte/pages]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 自动存储更新显示数据库时间戳]]></title>
    <url>%2F2017%2F03%2F31%2FYii2%20%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[之前我们terms表中有两个时间字段create_at和update_at,现在我们来操作一下,使create_at和update_at在存储时自动更新它的时间戳属性 自动存储更新时间戳属性这里我们使用TimestampBehavior先不要管行为不行为,今天就是要时间戳属性自动存储更新 方式一现在我们开始操作/thesaurus/frontend/models/Terms.php,首先别忘了1use yii\behaviors\TimestampBehavior; 然后定义方法behaviors12345678910111213141516171819/** * @inheritdoc */ public function behaviors() &#123; return [ [ &apos;class&apos; =&gt; TimestampBehavior::className(), &apos;attributes&apos; =&gt; [ # 添加之前 ActiveRecord::EVENT_BEFORE_INSERT =&gt; [&apos;create_at&apos;, &apos;update_at&apos;], # 修改之前 ActiveRecord::EVENT_BEFORE_UPDATE =&gt; [&apos;update_at&apos;] ], # 字段值 &apos;value&apos; =&gt; time() ] ]; &#125; 方式二配合下面的 afterFind 格式化时间最佳123456789101112131415161718/** * @inheritdoc */ public function rules() &#123; return [ # 自动补全添加时间和修改时间,配合 afterFind 方法转换格式化时间 [&apos;create_at&apos;, &apos;filter&apos;, &apos;filter&apos; =&gt; function () &#123; return $this-&gt;create_at ? strtotime($this-&gt;create_at) : time(); &#125;], [&apos;update_at&apos;, &apos;filter&apos;, &apos;filter&apos; =&gt; function () &#123; return $this-&gt;update_at ? strtotime($this-&gt;update_at) : time(); &#125;], [[&apos;name&apos;], &apos;required&apos;], [[&apos;create_at&apos;, &apos;update_at&apos;], &apos;integer&apos;], [[&apos;name&apos;], &apos;string&apos;, &apos;max&apos; =&gt; 32], ]; &#125; 这个完成以后我们打开/thesaurus/frontend/views/terms/create.php看到以下代码123&lt;?= $this-&gt;render(&apos;_form&apos;, [ &apos;model&apos; =&gt; $model, ]) ?&gt; 然后我们找到/thesaurus/frontend/views/terms/_form.php,把Form表单的create_at和update_at的input框删除掉,只留下name然后我们打开local.thef.com/index.php?r=terms,点击Create Terms按钮,表单页面是不是只剩下name一览了,添加一个试试 显示格式化时间再让我们回到local.thef.com/index.php?r=terms,是不是已经有我们已经添加的数据了,但是时间是有了,感觉有点不对啊,我也觉得是,有办法继续打开/thesaurus/frontend/models/Terms.php添加如下方法123456789/** * @inheritdoc */ public function afterFind() &#123; parent::afterFind(); $this-&gt;create_at = date(&apos;Y-m-d H:i:s&apos;, $this-&gt;create_at); $this-&gt;update_at = date(&apos;Y-m-d H:i:s&apos;, $this-&gt;update_at); &#125; 再回头我们的local.thef.com/index.php?r=terms,这下是不是就看着顺眼了.虽然格式化时间的方法很多,但是我觉得这个够了….]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 Gii生成代码]]></title>
    <url>%2F2017%2F03%2F31%2FYii2%20Gii%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Gii是Yii中的一个模块,有此神器,撸代码都省了好多,简单的先用一下继续拿我们上边的例子来说访问local.thef.com/index.php?r=gii可以看到操作界面 生成Model输入Table Name(有提示,是不是很方便),自动补全Model Class Namespace这里只在frontend下使用,就小改一下 最后点击Preview,然后Generate完成,看看thesaurus/frontend/models/目录下是不是多了Terms.php 同理点击CRUD Generator,点击Preview,然后Generate完成 123456*Model Class*frontend\models\Terms*Search Model Class*frontend\models\TermsSearch*Controller Class*frontend\controllers\TermsController 生成文件: /thesaurus/frontend/models/TermsSearch.php /thesaurus/frontend/controllers/TermsController.php /thesaurus/frontend/views/terms/_form.php /thesaurus/frontend/views/terms/_search.php /thesaurus/frontend/views/terms/create.php /thesaurus/frontend/views/terms/index.php /thesaurus/frontend/views/terms/update.php /thesaurus/frontend/views/terms/view.php 然后访问 local.thef.com/index.php?r=terms 就可以进行你的增删查改了,biubiu,是不是很爽]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 数据库迁移]]></title>
    <url>%2F2017%2F03%2F31%2FYii2%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[描述在开发和维护一个数据库驱动的应用程序时,数据库的结构会随代码的改变而改变. Yii 提供了一个 数据库迁移功,该功能可以记录数据库的变化, 以便使数据库和源代码一起受版本控制.Yii 提供了一整套的迁移命令行工具，通过这些工具你可以: 创建新的迁移 提交迁移 恢复迁移 重新提交迁移 现实迁移历史和状态 下面我简单用一下,至于更复杂的应用会在后期的更新中补充掉 实操先看下帮助12$ cd thesaurus$ php yii migrate -h 最重要的是下面这段12345678- migrate/create Creates a new migration.- migrate/down Downgrades the application by reverting old migrations.- migrate/history Displays the migration history.- migrate/mark Modifies the migration history to the specified version.- migrate/new Displays the un-applied new migrations.- migrate/redo Redoes the last few migrations.- migrate/to Upgrades or downgrades till the specified version.- migrate/up (default) Upgrades the application by applying new migrations. 出于好奇心,我们先create一个表试试看看1$ php yii migrate/create create_terms_table 提示创建一个新的迁移文件,输入yes看到New migration created successfully.表示成功生成的文件在/thesaurus/console/migrations/mxxxxxx_xxxxxx_create_terms_table.php,打开编辑terms所需字段 我这里添加了name和create_at,update_at字段,上边的属性各位估计也能看明白,下边执行迁移1$ php yii migrate 安装提示输入yes,看到Migrated up successfully说明成功,通过数据库工具Navicat Premium可以看到数据库中多了三个表migration,terms,user,其中migration是用来记录迁移历史记录的,user是项目初始化中自带的(也就是你刚刚登陆不成功那个user表),terms当然使我们自己创建的剩下的命令就不做过多演示了,记住几个比较常用,完全无压力1234- migrate/create 创建新的迁移.- migrate/down 恢复上一个迁移.- migrate/history 显示迁移历史和状态.- migrate 提交迁移]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 配置数据库连接]]></title>
    <url>%2F2017%2F03%2F31%2FYii2%20%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[本人习惯将数据库连接信息,及一些安全性信息写到系统的环境变量里 一是代码中没有明文的数据库账号密码等一些安全敏感性信息 二是逼格比较高 三是代码统一,配置好终身所有项目受用,没必要再去管开发环境生产环境配置啥的 本人终端为macOS一般环境变量配置在.bash_profile,Linux一般在/etc/profile,配置格式如下1234$ export DB_TYPE=mysql$ export DB_HOST=192.168.0.3$ export DB_USER=root$ .... 基于以上,项目中配置信息都在mian.php文件中配置,至于后端和前端的不同配置,就在backend/config/main.php和frontend/config/main.php中配置配置好以后点击local.thef.com的Login,账号密码随便输入,点击Login,报错了?!那就对了,错误信息是说thesaurus数据库中没有user表,如果是其他错误那就不正常了,这一节就到此了,下一节简单的讲一下Yii2的数据库迁移.]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2 创建应用]]></title>
    <url>%2F2017%2F03%2F31%2FYii2%20%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[环境 macOS 10.12.3 php version: 5.6.28 nginx version: nginx/1.8.0 mysql version: 5.7.16 composer version: 1.3.2 安装开发环境安装,这里就不做太多讲解,如有需要请移至本人博客Ewan’s Blog.composer 安装以及更换国内镜像请移至Packagist / Composer 切换到一个可通过 Web 访问的目录，执行如下命令即可安装 Yii ：12$ composer global require &quot;fxp/composer-asset-plugin:^1.2.0&quot;$ composer create-project yiisoft/yii2-app-advanced thesaurus 本文全篇以高级的应用程序模板为基础,thesaurus 为实例项目名称.(安装的过程时间稍长,可以出去抽根烟)安装好以后,初始化项目程序12$ cd thesaurus/$ php init 选择 0(Development)输入 yes 即可配置Nginx web访问服务,这里就不做多解释 local.theb.com (后端服务访问URL) local.thef.com (前端服务访问URL) 配置好以后记得添加本地hosts和重启Nginx或者Apache以上操作完成以后,通过浏览器访问local.theb.com和local.thef.com 显示一下即为安装成功]]></content>
      <categories>
        <category>PHP</category>
        <category>Yii2</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网协议总结(二)]]></title>
    <url>%2F2016%2F12%2F14%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[互联网协议总结(一)]]></title>
    <url>%2F2016%2F12%2F13%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[互联网协议入门每天重复搬砖的动作,发现很多底层的基础只是都有点忘了…补一下喽,这里参照阮一峰的博客梳理一下互联网的核心是一系列的协议,总称为”互联网协议”(Internet Protocol Suite).它们对电脑如何连接和组网,做出了详尽的规定.理解了这些协议,就理解了互联网的原理. 概述1.1 五层模型 互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。如何分层有不同的模型，有的模型分七层，有的分四层。个人觉得把互联网分成五层，比较容易解释。如图所示,越往下面的层,越靠近硬件;越往上面的层,越靠近用户. 1.2 层与协议 每一层都是为了完成一种功能.为了实现这些功能,就需要大家都遵守共同的规则.大家都遵守的规则,就叫做”协议”(protocol).互联网的每一层都定义了很多协议.这些协议的总称,就叫做”互联网协议”(Internet Protocol Suite).它是互联网的核心. 实体层 Physical Layer 从最底下的一层开始.计算机要组网,当然是先把电脑连接起来,可以用光缆,电缆,双绞线,无线电波等方式.这就叫做”实体层”,他就是把电脑连接起来的物理手段.它主要规定了网络的一些电气特性,作用是负责传送0和1的电信号. 链接层 Link Layer3.1 定义 单纯的0和1没有任何意义,必须规定解读方式:多少个电信号算一组?每个信号位有什么意义?这就是”链接层”的功能,它在”实体层”的上方,确定了0和1的分组方式. 3.2 以太网协议 早期的时候,每家公司都有自己的电信号分组方式.逐渐的一种叫做”以太网”(Ethernet)的协议,占据了主导地位.以太网规定,一组电信号构成一个数据包,叫做”帧”(Frame).每一帧分成两个部分:标头(head)和数据(data).“标头”包含数据包的一些说明项,比如发送者,接受者,数据类型等等;”数据”则是数据包的具体内容.“标头”的长度,固定为18字节.”数据”长度,最短为46字节,最长为1500字节.因此,整个”帧”最短为64字节,最长为1518字节,如果数据很长,就必须分割成多个”帧”进行发送. 3.3 MAC地址 上面提到，以太网数据包的”标头”,包含了发送者和接受者的信息,那么,发送者和接受者是如何标识呢?以太网规定,连入网络的所有设备,都必须具有”网卡”接口.数据包必须是从一块网卡,传送到另一块网卡.网卡的地址,就是数据包的发送地址和接收地址,这叫做MAC地址.每块网卡出厂的时候,都有一个全世界独一无二的MAC地址,长度是48个二进制位,通常用12个十六进制数表示.前6个十六进制数是厂商编号,后6个是该厂商的网卡流水号.有了MAC地址,就可以定位网卡和数据包的路径了. 3.4 广播 定义地址只是第一步,后面还有更多的步骤.首先,一块网卡怎么会知道另一块网卡的MAC地址?回答是有一种ARP协议,可以解决这个问题.这个留到后面介绍,这里只需要知道,以太网数据包必须知道接收方的MAC地址,然后才能发送.其次,就算有了MAC地址,系统怎样才能把数据包准确的发送到接收方?回答是以太网采用了一种很”原始”的方式,它不是把数据包准确送到接收方,而是向本网络内所有计算机发送,让每台计算机自己判断,是否为接受方.上图中,1号计算机向2号计算机发送一个数据包,同一个子网络的3号,4号,5号计算机都会收到这个包.它们读取到这个包的”标头”,找到接收方的MAC地址,然后与自身的MAC地址相比较,如果两者相同,就接收这个包,做进一步处理,否则就丢弃这个包.这种发送方式就叫做”广播”(broadcasting).有了这个数据包的定义,网卡的MAC地址,广播的发送方式,”连接层”就可以在多台计算机之间传送数据了. 网络层 Network Layer4.1 网络层的由来 以太网协议,依靠MAC地址发送数据.理论上,单单依靠MAC地址,上海的网卡就可以找到洛杉矶的网卡了,技术上是可以实现的.但是,这样做有一个重大的缺点,以太网采用广播的发送方式发送数据包,所有成员人手一”包”,不仅效率低,而且局限在发送者所在的子网络.这就是说,如果两台计算机不在同一个子网络,广播是传不过去的.这种设计是合理的,否则互联网上每一台计算机都会收到所有的”包”,那会引起灾难.互联网是无数子网络共同组成的一个巨型网络,很难想象上海和洛杉矶的电脑会在同一个子网络,这几乎是不可能的.因此,必须找到一种方法,能够区分哪些MAC地址属于同一个子网络,哪些不是.如果是同一子网络,就采用广播的方式发送,否则就采用”路由”的方式发送.(“路由”的意思,是指如何向不同的子网络发送数据包,这是一个很大的主题,本文不涉及.)遗憾的是,MAC地址本身无法做到这一点,它只与厂商有关,与所出网络无关.这就导致了”网络层”的诞生,它的作用是引进一套新的地址,使得我们能区分不同的计算机是否属于同一个自网络.这套地址就叫做”网络地址”,简称”网址”.于是,”网络层”出现以后,每台计算机有了两种地址,一种是MAC地址,另一种是网络地址.两种地址之间没有任何联系,MAC地址是绑定在网卡上的,网络地址则是管理员分配的,它们只是随机组合在一起.网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包发送到该子网络中的没押镖网卡.因此,从逻辑上可以推断,必定是先处理网络地址,然后再处理MAC地址. 4.2 IP协议 规定网络地址的协议,叫做IP协议.它所定义的地址,就被称为IP地址.目前,广泛采用的IP协议第四版,简称IPv4.这个版本规定,网络地址由32个二进制位组成.习惯上,我们分成4段的十进制数表示IP地址,从0.0.0.0一直到255.255.255.255.互联网上每一台计算机,都会分配到一个IP地址.这个地址分成两部分,前一部分代表网络,后一部分代表主机.比如,IP地址172.16.254.1,这是一个32位的地址,假定它的网络部分是前24位(172.16.254),那么主机部分就是后8位(最后一个1).处于同一子网络的计算机,它们的IP地址的网络部分必定是相同的,也就是说172.16.254.2应该与172.16.254.1处于同一个子网络.但是,问题在于单单从IP地址,我们无法判断网络部分.还是以172.16.254.1为例,它的网络部分,到底是前24位,还是前16位,甚至是前28位,从IP地址上是看不出来的.那么.怎样才能从IP地址,判断两台计算机是否属于同一个子网络呐?这就是要用到另一个参数”子网掩码”(subnet mask).所谓”子网掩码”,就是表示子网络特征的一个参数.它在形式上等同于IP地址,也就是一个32位的二进制数字,他的网络部分全部为1,主机部分全部为0.比如,IP地址172.16.254.1,如果已知网络部分是前24位,主机部分是后8位,那么子网掩码就是11111111.11111111.11111111.00000000,写成十进制就是255.255.255.0知道”子网掩码”,我们就能判断,任意两个IP地址是否处在同一个子网络.方法是将两个IP地址与子网掩码分别进行AND运算(两个数位都为1,运行结果为1,否则为0),然后比较结果是否相同,如果是的话,就表明它们在同一个子网络中,否则就不是.比如,一直IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0,请问它们是否在同一个子网络?两者与子网掩码分别进行AND运算,结果都是172.16.254.0,因此它们在同一个子网络.总结一下,IP协议的作用主要有两个,一个是为每一台计算机分配IP地址,另一个是确定哪些IP地址在同一个子网络. 4.3 IP数据包 根据IP协议发送的数据,就叫做IP数据包.不难想象,其中必定包括IP信息.但是前面说过,以太网数据包值包含MAC地址,并没有IP地址的栏位.那么是否需要修改数据包定义,再添加一个栏位呐?回答是不需要,我们可以把IP数据包直接放进意外网数据包的”数据”部分,因此完全不用修改以太网的规格.这就是互联网分层结构的好处:上层的变动完全不涉及下层的结构.具体来说,IP数据包也分为”标头”和”数据”两部分.“标头”部分主要包括版本,长度,IP地址等信息,”数据”部分则是IP数据包的具体内容,它放进以太网数据包后,以太网数据包就变成了下面这样.IP数据包的”标头”部分的长度为20~60字节,真个数据包的总长度为65535字节.因此,理论上,一个IP数据包的”数据”部分,最长为65515字节.前面说过,以太网数据包的”数据”部分,最长只有1500字节,因此,IP数据包超过了1500字节,它就需要分割成几个以太网数据包,发开发送了. 4.4 ARP协议 关于”网络层”,还有最后一点需要说明.因为IP数据包是放在以太网数据包里发送的,所以我们必须同时知道两个地址,一个是对方的MAC地址,另一个是对方的IP地址.通常情况下,对方的IP地址是已知的(后文会解释),但是我们不知道它的MAC地址.所以,我们需要一种机制,能够从IP地址得到MAC地址.这里又可以分成两种情况.第一种情况,如果两台主机不在同一个子网络,那么事实上没有办法得到对方的MAC地址,只能把数据包传送到两个子网络连接处的”网关”(gateway),让网关去处理.第二种情况,如果两台主机在同一个子网络,那么我们可以用ARP协议,得到对方的MAC地址.ARP协议也是发出一个数据包(包含在以太网数据包中),其中包含它所要查询主机的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个”广播”地址.它所在子网络的每一台主机,都会收到这个数据包,从中取出IP地址,与自身的IP地址进行比较.如果两者相同,都做出回复,向对方报告自己的MAC地址,否则就丢弃这个包.总之,有了ARP协议之后,我们就可以得到同一个子网络内的主机MAC地址,可以把数据包发送到任意一台主机之上了. 传输层 Transport Layer5.1 传输层的由来 有了MAC地址和IP地址,我们已经可以在互联网上任意两台主机上建立通信.接下来的问题是,同一台主机上有许多程序都需要用到网络,比如,你一边浏览网页,一边与朋友在线聊天.当一个数据包从互联网上发来的时候,你怎么知道,它是表示网页的内容,还是表示在线聊天的内容?也就是说,我们还需要一个参数,表示这个数据包到底供哪个程序(进程)使用.这个参数就叫做”端口”(port)，它其实是每一个使用网卡的程序的编号.每个数据包都发到主机的特定端口,所以不同的程序就能取到自己所需要的数据.“端口”是0到65535之间的一个整数,正好16个二进制位.0到1023的端口被系统占用,用户只能选用大于1023的端口.不管是浏览网页还是在线聊天,应用程序会随机选用一个端口,然后与服务器的相应端口联系.“传输层”的功能,就是建立”端口到端口”的通信.相比之下,”网络层”的功能是建立”主机到主机”的通信.只要确定主机和端口,我们就能实现程序之间的交流.因此,Unix系统就把主机+端口,叫做”套接字”(socket).有了它,就可以进行网络应用程序开发了. 5.2 UDP协议 现在,我们必须在数据包中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式几乎就是在数据前面,加上端口号.UDP数据包也,是由”标头”和”数据”两部分组成.“标头”部分主要定义了发出端口和接收端口,”数据”部分就是具体的内容.然后,把整个UDP数据包放入IP数据包的”数据”部分,而前面说过,IP数据包又是放在以太网数据包之中的,所以整个以太网数据包现在变成了下面这样:UDP数据包非常简单,”标头”部分一共只有8个字节,总长度不超过65535字节,正好放进一个IP数据包. 5.3 TCP协议 UDP协议的优点是比较简单,容易实现,但是缺点是可靠性较差,一旦数据包发出,无法知道对方是否收到.为了解决这个问题,提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为,它就是有确认机制的UDP协议,每发出一个数据包都要求确认.如果有一个数据包遗失,就收不到确认,发出方就知道有必要重发这个数据包了.因此,TCP协议能够确保数据不会遗失.它的缺点是过程复杂,实现困难,消耗较多的资源.TCP数据包和UDP数据包一样,都是内嵌在IP数据包的”数据”部分.TCP数据包没有长度限制,理论上可以无限长,但是为了保证网络的效率,通常TCP数据包的长度不会超过IP数据包的长度,以确保单个TCP数据包不必再分割. 应用层 Application Layer 应用程序收到”传输层”的数据,接下来就要进行解读.由于互联网是开放架构,数据来源五花八门,必须事先规定好格式,否则根本无法解读.“应用层”的作用,就是规定应用程序的数据格式.举例来说,TCP协议可以为各种各样的程序传递数据,比如Email,WWW,FTP等等.那么,必须有不同协议规定电子邮件,网页,FTP数据的格式.这些应用程序协议就构成了”应用层”.这是最高的一层,直接面对用户.它的数据就放在TCP数据包的”数据”部分.因此,现在的以太网的数据包就变成下面这样.至此,整个互联网的五层结构,自下而上全部讲完了.这是从系统的角度,解释互联网是如何构成的.]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>网络</tag>
        <tag>通讯协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git删除已提交的文件或文件夹]]></title>
    <url>%2F2016%2F12%2F12%2Fgit%E5%88%A0%E9%99%A4%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[今个写脚本测试的时候不小心将记录数据的文件提交上去了,研究了一下git忽略已提交的文件或者文件夹 12345$ git rm --cached logs/put_file.log$ vi .gitignore# .gitignore添加要忽略的文件$ logs/put_file.log$ git commit -m &quot;We really don&apos;t want Git to track this anymore!&quot; 这样就可以完成忽略已提交的文件或者文件夹了PS:文件夹的话使用logs/*]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AES加密解密]]></title>
    <url>%2F2016%2F12%2F06%2FAES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[AES （高级加密标准) 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 说下PHP的用法~~ 代码123456789101112131415161718192021222324252627282930313233&lt;?phpclass Security &#123; public static function encrypt($input, $key) &#123; $size = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB); $input = Security::pkcs5_pad($input, $size); $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, &apos;&apos;, MCRYPT_MODE_ECB, &apos;&apos;); $iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_RAND); mcrypt_generic_init($td, $key, $iv); $data = mcrypt_generic($td, $input); mcrypt_generic_deinit($td); mcrypt_module_close($td); $data = base64_encode($data); return $data; &#125; private static function pkcs5_pad ($text, $blocksize) &#123; $pad = $blocksize - (strlen($text) % $blocksize); return $text . str_repeat(chr($pad), $pad); &#125; public static function decrypt($sStr, $sKey) &#123; $decrypted= mcrypt_decrypt( MCRYPT_RIJNDAEL_128, $sKey, base64_decode($sStr), MCRYPT_MODE_ECB ); $dec_s = strlen($decrypted); $padding = ord($decrypted[$dec_s-1]); $decrypted = substr($decrypted, 0, -$padding); return $decrypted; &#125; &#125; 实例123456require_once(&apos;./security.php&apos;);$value = &quot;example&quot;;$key = &quot;1234567891234567&quot;; //16 Character Keyecho Security::encrypt($value, $key);echo Security::decrypt(Security::encrypt($value, $key), $key);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 深入浅出]]></title>
    <url>%2F2016%2F11%2F23%2FMySQL-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%2F</url>
    <content type="text"></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firing！！！]]></title>
    <url>%2F2016%2F11%2F17%2FFiring%EF%BC%81%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[经过两天的奋战，Ewan&#39;s Blog 终于与大家见面了。目前网站定位方向为技术性博客，可能稍后会有些栏目的调整，期待大家的关注。 之前也有做过自己的博客网站,经历了服务器到期,域名续费,赶上有段时间工作调整没时间整理,导致博客更新中断.而后一直有新建博客的想法,说到这个特别的感谢一下胖佳 在网站的搭建过程中的先锋精神和技术指导.还要感谢jarvan君和小白的技术指导,说句实在话jarvan君是我工作以来对我帮助最大的一位,之前一起住学校宿舍、一起在一家公司上班,生活中是个老大哥、工作中亦师亦友的这种关系令我享受在其中.当然上面提到胖佳和小白那两只货是我在北京性格上很合得来的哥们,为此哥几个一周撸五次串也不为过. 在北京学习的那几个月是我人生的一个转折点,更是我人生一个新的起点. 后续会陆续将之前整理的博客文章搬迁过来,也会发表一些新的文章出来供大家分享学习 既然有了一个好的起点，我们就跟要努力向前冲，Firing，Firing！！！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>微语</tag>
        <tag>胡侃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 存储例程]]></title>
    <url>%2F2015%2F03%2F23%2FMySQL-%E5%AD%98%E5%82%A8%E4%BE%8B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[好高兴啊，Ewan学习进行时。mysql存储例程学习总结拿来共享喽。 1.存储例程定义 存储在数据库服务器中的一组sql语句，通过在查询中调用一个指定的名称来执行这些sql语句命令。mysql存储例程实际上包含了存储过程和存储函数，他们被统称为存储例程。存储过程：存储过程支持select,insert,update和delete等sql命令的执行，还可以设置能在程序外引用的参数。存储函数：只支持select命令的执行，只接受输入参数，必须返回且只返回一个值，此外还可以旧爱那个存储函数直接嵌套到sql命令中。 2.为什么使用存储例程 我们都知道应用程序分为两种，一种是基于桌面一种是基于web，它们都使用一个MYSQL数据库并完成很多相同的任务。而这两种应用程序可能带来不易维护和易遭sql语句注入的弊端，针对这些难题，存储例程的数据库特性成为最常用的解决方案之一。 3.存储例程优点 1）一致性2）高性能3）安全性4）架构 4.存储过程基本语法create procedure (过程名)［过程参数...］ begin (内容，sql语句) end 调用：set @要设置的参数值call 参数名(@要设置的参数值)从另一个例程中调用例程：create procedure 进程名begincall 另一个进程名();end查看存储进程:show procedure status;一可以查看某个存储进程的详细:show procedure status like &#39;变量名&#39;\G;查看进程的创建语法:show create procedure 进程名;修改存储进程：alter procedure 进程名 .....删除存储进程：drop procedure 进程名;是不是很简单，下面来详细分解一下语法的具体参数:存储过程参数用在存储过程的定，共有三种类型in,out,inout如下：create procedure (过程名)［in/out/inout 参数名 数据类型］in：为默认值，使用该参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回。out：使用该参数的之的值在存储过程内部被改变，并返回。inout:使用该参数的值，调用时指定，并且可被改变并返回。 5.声明和设置变量 声明变量：这里使用到了declare，如下：declare 变量名 变量类型;设置变量：set 变量名=值;这里做下延伸：在mysql客户端使用用户变量，如下：select &#39;hello world!&#39; into @z; set @x=&#39;hello world!&#39;; set @c=1+1;执行：select …;这里要注意：1）变量名一般以@开头2）滥用用户变量会导致程序难以理解和管理 6.begin …end 创建多语句进程时，将语句放在begin end 中间。 7.条件(条件语句这里不做太多解释）if .....then ....elseif ...then ....end if;casewhen .... then :.....;when .... then :.....;end case;while.....end while;repeat ....end repeat;loop .....end loop; repeat是在执行操作后检查结果，而while是在执行前进行检查。oop循环不需要初始条件，这点和while 循环相似，同时和repeat循环一样不需要结束条件, leave语句的意义是离开循环。lables标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。iterate迭代,为了一些需要重复执行一组语句的任务。通过引用复合语句的标号,来从新开始复合语句。leave 在得到变量的值或特定任务的结果之后，可能希望通过leave命令立即退出循环或begin…end。 8.存储函数 字符串类：charset(str) //返回字串字符集concat (string2 [,... ]) //连接字串instr (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0lcase(string2 ) //转换成小写left (string2 ,length ) //从string2中的左边起取length个字符length (string ) //string长度load_file(file_name ) //从文件读取内容locate(substring , string [,start_position ] ) 同INSTR,但可指定开始位置lpad(string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为lengthltrim(string2 ) //去除前端空格repeat(string2 ,count ) //重复count次replace(str ,search_str ,replace_str ) //在str中用replace_str替换search_strrpad(string2 ,length ,pad) //在str后用pad补充,直到长度为lengthrtrim(string2 ) //去除后端空格strcmp (string1 ,string2 ) //逐字符比较两字串大小substring (str , position [,length ]) //从str的position开始,取length个字符 注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1trim([[BOTH|LEADING|TRAILING] [padding] FROM]string2) //去除指定位置的指定字符ucase(string2 ) //转换成大写right(string2,length) //取string2最后length个字符space(count) //生成count个空格数学类ABS (number2 ) //绝对值BIN (decimal_number ) //十进制转二进制CEILING (number2 ) //向上取整CONV(number2,from_base,to_base) //进制转换FLOOR (number2 ) //向下取整FORMAT (number,decimal_places ) //保留小数位数HEX (DecimalNumber ) //转十六进制 注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(&#39;DEF&#39;)返回4142143 也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19LEAST (number , number2 [,..]) //求最小值MOD (numerator ,denominator ) //求余POWER (number ,power ) //求指数RAND([seed]) //随机数ROUND (number [,decimals ]) //四舍五入,decimals为小数位数]日期时间类ADDTIME (date2 ,time_interval ) //将time_interval加到date2CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区CURRENT_DATE ( ) //当前日期CURRENT_TIME ( ) //当前时间CURRENT_TIMESTAMP ( ) //当前时间戳DATE (datetime ) //返回datetime的日期部分DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetimeDATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间DATEDIFF (date1 ,date2 ) //两个日期差DAY (date ) //返回日期的天DAYNAME (date ) //英文星期DAYOFWEEK (date ) //星期(1-7) ,1为星期天DAYOFYEAR (date ) //一年中的第几天EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串MAKETIME (hour ,minute ,second ) //生成时间串MONTHNAME (date ) //英文月份名NOW ( ) //当前时间SEC_TO_TIME (seconds ) //秒数转成时间STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示TIMEDIFF (datetime1 ,datetime2 ) //两个时间差TIME_TO_SEC (time ) //时间转秒数]WEEK (date_time [,start_of_week ]) //第几周YEAR (datetime ) //年份DAYOFMONTH(datetime) //月的第几天HOUR(datetime) //小时]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel安装]]></title>
    <url>%2F2014%2F10%2F13%2Flaravel%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[近期貌似对 laravel 有使用的需求，就自己安装了一次，发现对于有些人来说确实有点文档不够全面的感觉，现将具体的安装方法总结如下。Composer安装： Laravel 框架使用 Composer 来管理代码依赖性。在Windows操作系统中，你可以使用 Composer 的Windows安装工具(https://getcomposer.org/Composer-Setup.exe)。对PHP版本有要求(最好5.4.0以上)laravel安装：Composer安装完成后，在dos模式中，你的网站目录执行下面命令即可：1$ composer create-project laravel/laravel your-project-name Composer会自动帮你下载Laravel及安装。部署虚拟主机(Apache相关知识)：如果之前对Apache的配置环境没有设置过：(1) Apache配置设置，打开(路径看个人项目环境而定)1C:\wamp\bin\apache\apache2.4.9\conf\httpd.conf 第512~513行，将默认的虚拟主机设置打开(默认是关闭的，前边#去掉即可)12# Virtual hostsInclude conf/extra/httpd-vhosts.conf (2) 配置站点，打开(路径看个人项目环境而定)1C:\wamp\bin\apache\apache2.4.9\conf\extra\httpd-vhosts.conf 在其下方添加站点信息：123456&lt;VirtualHost *:80&gt; DocumentRoot &quot;c:/wamp/www/project/public&quot; ServerName laravel.dev ErrorLog &quot;logs/laravel.log&quot; CustomLog &quot;logs/laravel.log&quot; common&lt;/VirtualHost&gt; (3) 将站点指向项目目录，打开(路径看个人项目环境而定)C:\Windows\System32\drivers\etc\hosts在其下方添加站点信息：1$ 127.0.0.1 laravel.dev]]></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装dpkg错误解决方案]]></title>
    <url>%2F2014%2F09%2F17%2FMySQL%E5%AE%89%E8%A3%85dpkg%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Ewan在Ubuntu下安装MySQL的时候出现了一下错误问题： 1234567891011121314start: Job failed to startinvoke-rc.d: initscript mysql, action &quot;start&quot; failed.dpkg: error processing mysql-server-5.5 (--configure):subprocess installed post-installation script returned error exit status 1dpkg: dependency problems prevent configuration of mysql-server:mysql-server depends on mysql-server-5.5; however:Package mysql-server-5.5 is not configured yet.dpkg: error processing mysql-server (--configure):dependency problems - leaving unconfiguredNo apport report written because the error message indicates its a followup error from a previous failure.Errors were encountered while processing:mysql-server-5.5mysql-serverE: Sub-process /usr/bin/dpkg returned an error code (1) 经查证，现给出解决办法：删除MySQL前，先删除/var/lib/mysql和/etc/mysql 12345$ sudo rm /var/lib/mysql/ -R$ sudo rm /etc/mysql/ -R$ sudo apt-get autoremove mysql* --purge$ sudo apt-get remove apparmor$ sudo apt-get install mysql-server mysql-common]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Me]]></title>
    <url>%2F2014%2F09%2F14%2FAbout-Me%2F</url>
    <content type="text"><![CDATA[欢迎大家访问Ewan’s Blog：www.iooeo.com博主姓名：杨依园 | Ewan网名：バ 小丑男°乄° ?绰号：cola、杨一、一哥、猫叔、小杨、猿某人、酷头（莉姐送的~）扣扣：654846126邮箱：yuankess@sina.cn | 654846126@qq.com社交主页：www.iooeo.com | ewan.coding.me | yangyiyuan.github.io爱好：玩游戏、听歌、看电影、骑车、滑冰、瞎折腾 切换至炫酷版此处要用程序123456历程: &gt; 2014年09月11日购买域名 www.iooeo.com&gt; 购买空间 搭建环境&gt; 2014年09月15日开通第一个web网站 www.iooeo.com&gt; 2016年11月15日 www.iooeo.com 完成升级&gt; 未完待续......]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>微语</tag>
        <tag>胡侃</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 触发器]]></title>
    <url>%2F2014%2F03%2F02%2FMySQL-%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Ewan又来学习啦，mysql触发器个人学习感悟奉上。 1.触发器定义 sql server里面对某个表的一定的操作，触发某种条件而执行的一段程序。它是一个特殊的存储过程。 2.为什么使用触发器 1）强制业务规则2）审计跟踪 –用于跟踪网站区域流量3）验证4）完整性约束引用 –表的关系在项目整个生命周期中的稳定 3.触发器基本语法create trigger triggre_name trigger_time trigger_event on table_name for each row trigger_stmt; trigger_name：触发器名称；trigger_time：触发时机，取值为before 或after；trigger_event：触发事件，取值为 insert、update或 delete；table_name：建立触发器的表名;trigger_stmt：触发器程序体，可以是一句sql语句，或者用 begin 和 end 包含的多条sql语句。 4.before与after详解 before：(insert、update)可以对new进行修改，after不能对new进行修改。两者都不能修改old数据。表插入字段值需要用new计算，只能用before，在别的表中记录插入成功记录或统计插入的条数用after。after update 也就是执行完你的更新之后.再执行这个触发器的语句..before update 就是执行完这个触发器的语句,再执行你的更新.可以建立6种触发器，即：before insert、before update、before delete、after insert、after update、after delete**有一个限制是不能同时在一个表上建立2个相同类型的触发器，因此在一个表上最多建立6个触发器 5,trigger_event详解 msql除了对insert,update,delete 基本操作进行定义外，还定义了load data和replace语句，这两种语句也能引起上述6中类型的触发器的触发。load data 语句用于将一个文件装入到一个数据表中，相当与一系列的 insert 操作。replace语句一般来说和insert语句很像,只是在表中有primary key或unique 索引时，如果插入的数据和原来 primarykey或unique索引一致时，会先删除原来的数据，然后增加一条新数据，也就是说，一条 replace 语句有时候等价于一条 update。insert 型触发器：插入某一行时激活触发器，可能通过 insert、load data、replace 语句触发；update 型触发器：更改某一行时激活触发器，可能通过 update 语句触发；delete 型触发器：删除某一行时激活触发器，可能通过 delete、replace 语句触发。 6.begin … end详解 在mysql中，begin … end 语句的语法为：begin [statement_list] endstatement_list 代表一个或多个语句的列表，列表内的每条语句都必须用分号（;）来结尾。解释器遇到 statement_list 中的分号后就开始执行，然后会报出错误，因为没有找到和 begin匹配的enddelimiter命令，它是一条命令，不需要语句结束标识，语法为：delimiter new_delemiternew_delemiter 可以设为1个或多个长度的符号，默认的是分号（;），我们可以把它修改为其他符号，如管道符：delimiter |在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了管道符，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。 7.new与old详解 new关键字，和mysql中的 inserted和deleted类似，mysql中定义了new和old，用来表示触发器的所在表中，触发了触发器的那一行数据。具体地：在insert型触发器中，new 用来表示将要（before）或已经（after）插入的新数据；在 update型触发器中，old用来表示将要或已经被修改的原数据，new用来表示将要或已经修改为的新数据；在 delete 型触发器中，old用来表示将要或已经被删除的原数据；使用方法： new.columnName （columnName 为相应数据表某一列名）;另外，old 是只读的，而 new 则可以在触发器中使用 set 赋值，这样不会再次触发触发器，造成循环调用。 8.删除触发器 和删除数据库、删除表格一样，删除触发器的语法如下：drop trigger trigger_name;查看现有的触发器：show triggers\G; 9.触发器的执行顺序 我们建立的数据库一般都是 InnoDB 数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，mysql会回滚事务，如下：1)如果before触发器执行失败，sql无法正确执行。2)sql执行失败时，after型触发器不会触发。3)after类型的触发器执行失败，sql会回滚。 触发器可以大大减少只为确保数据库引用完整性和业务规则而编写的代码量。mysql视图学习至此告一段落，以上内容如有语法结构错误，请指出或给予相应的解决方案。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 视图]]></title>
    <url>%2F2013%2F11%2F13%2FMySQL-%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Ewan之前研究mysql实际操作，个人感悟拿来共享一下。1.视图定义 视图是从一个或几个基本表导出的虚拟表，意思就是说视图只是依附在基本表上的虚拟表。 2.视图与基本表的联系与区别 视图是基本表的查询结果，基本表的数据变了，视图的结果自然就改变了。当然试图改变也会影响到基本表。视图的增删改会影响基本表，但视图不总是能增删盖的哦。在视图的数据与基本表的数据一一对应的时候可以修改，但对于视图的insert应注意，视图必须包含基本表的中没有的默认值的列。 3.视图的优点 简化sql查询语句可以更好的进行权限把控适合大数据分表时使用 虽然大数据分表有很多种方法，但视图无疑是个不错的选择哦 4.视图的基本语法create view （视图名） as （select 语句）； 是不是很简单啊？但实际应用起来就不是表面这样喽5.视图的操作 修改视图alert view （视图名） as（select 语句）；删除视图drop view (视图名)； 6.使用algorithm属性优化mysql视图 在这里algorithm有3个设置可优化视图，分别是merge,temptable,undefined格式为：algorithm = merge/temptable/undefinedmerge算法使mysql将执行视图时传入的任何字句合并到视图的查询定义中，换句话说，视图定义和select查询语句会合并成新的查询语句。当视图指定temptable算法时，创建视图的同时创建视图相对应的temporary表，然后查询视图的语句会从该临时表查取数据。merge和temptable区别就是：merge最终查的是基本表，而temptable查的是虚拟表。merge算法效率要比temptable要高。undefined：顾名思义，为定义，系统会自动选择。 7.查看视图信息 可以使用：show create view (视图名)可以使用：DESCRIBE（视图名）可以使用：information_schema数据库包括一个views表，包含一下内容：select from information_schema.views\G 注意是G要大写* mysql视图学习至此告一段落，以上内容如有语法结构错误，请指出或给予相应的解决方案。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 优化篇之SQL优化]]></title>
    <url>%2F2013%2F11%2F13%2FMySQL-%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8BSQL%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[SQL优化优化SQL的一般步骤 1.通过show status和应用特点了解各种SQL的执行频率 通过SHOW STATUS可以提供服务器状态信息，也可以使用mysqladmin extended-status命令获得。SHOW STATUS可以根据需要显示session级别的统计结果和global级别的统计结果。以下几个参数对Myisam和Innodb存储引擎都计数：1). Com_select 执行select操作的次数，一次查询只累加1；2). Com_insert 执行insert操作的次数，对于批量插入的insert操作，只累加一次；3). Com_update 执行update操作的次数；4). Com_delete 执行delete操作的次数；以下几个参数是针对Innodb存储引擎计数的，累加的算法也略有不同：1). Innodb_rows_read select查询返回的行数；2). Innodb_rows_inserted执行Insert操作插入的行数；3). Innodb_rows_updated 执行update操作更新的行数；4). Innodb_rows_deleted 执行delete操作删除的行数；通过以上几个参数，可以很容易的了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的SQL大致的执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会累加。对于事务型的应用，通过Com_commit和Com_rollback可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。此外，以下几个参数便于我们了解数据库的基本情况：1). Connections 试图连接Mysql服务器的次数2). Uptime 服务器工作时间3). Slow_queries 慢查询的次数 2.定位执行效率较低的SQL语句 可以通过以下两种方式定位执行效率较低的SQL语句：1).可以通过慢查询日志定位那些执行效率较低的sql语句，用–log-slow-queries[=file_name]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。可以链接到管理维护中的相关章节。 3.通过EXPLAIN分析低效SQL的执行计划 通过以上步骤查询到效率低的SQL后，我们可以通过explain或者desc 获取MySQL如何执行SELECT语句的信息，包括select语句执行过程表如何连接和连接的次序。 explain可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的SELECT。mysql&gt;expain select * from table;select_type： select 类型table： 输出结果集的表type： 表示表的连接类型, 当表中仅有一行是type的值为system是最佳的连接类型； 当select操作中使用索引进行表连接时type的值为ref； 当select的表连接没有使用索引时，经常会看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。 possible_keys： 表示查询时,可以使用的索引列.key： 表示使用的索引key_len： 索引长度rows： 扫描范围Extra： 执行情况的说明和描述 12345+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+| 1 | SIMPLE | tab_serial | system | NULL | NULL | NULL | NULL | 0 | const row not found |+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+ 4.确定问题，并采取相应的优化措施 经过以上步骤，基本可以确认问题出现的原因，可以根据情况采取相应的措施，进行优化提高执行的效率。 索引问题 1.索引的存储分类 myisam表的数据文件和索引文件是自动分开的；innodb的数据和索引是存储在同一个表空间里面，但可以有多个文件组成。索引的存储类型目前只有两种（btree和hash），具体和表的模式相关：myisam btreeinnodb btreememory/heap hash，btreemysql目前不支持函数索引，只能对列的前一部分（length）进行索引，例：create index ind_test on table1(name(5))，对于char和varchar列，使用前缀索引将大大节省空间。 2.MySQL如何使用索引 索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高SELECT操作性能的最佳途径。 查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。下列情况下，Mysql不会使用已有的索引：1). 如果mysql估计使用索引比全表扫描更慢，则不使用索引。例如：如果key_part1均匀分布在1 和100之间，下列查询中使用索引就不是很好：SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 902). 如果使用heap表并且where条件中不用＝索引列，其他&gt; 、&lt;、 &gt;=、 &lt;=均不使用索引；3). 如果不是索引列的第一部分；4). 如果like是以％开始；5). 对where后边条件为字符串的一定要加引号，字符串如果为数字mysql会自动转为字符串，但是 不使用索引。 3.查看索引使用情况 如果索引正在工作，Handler_read_key的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。 Handler_read_rnd_next的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。语法： mysql&gt; show status like ‘Handler_read%’; 两个简单实用的优化方法 1.定期分析表 ANALYZE TABLE 语法：ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM, BDB和InnoDB表有作用。对于MyISAM表，本语句与使用myisamchk -a相当。CHECK TABLE 语法：CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}检查一个或多个表是否有错误。CHECK TABLE对MyISAM和InnoDB表有作用。对于MyISAM表，关键字统计数据被更新。 CHECK TABLE也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。CHECKSUM TABLE 语法：CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]报告一个表校验和。 2.使用optimize table OPTIMIZE TABLE 语法：OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表（含有VARCHAR, BLOB或TEXT列的表）进行了很多更改，则应使用OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的INSERT操作会重新使用旧的记录位置。您可以使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的碎片。 OPTIMIZE TABLE只对MyISAM, BDB和InnoDB表起作用。 常用SQL的优化 1.大批量插入数据 1). 对于Myisam类型的表，可以通过以下方式快速的导入大量的数据。ALTER TABLE tblname DISABLE KEYS; loading the data ALTER TABLE tblname ENABLE KEYS;这两个命令用来打开或者关闭Myisam表非唯一索引的更新。在导入大量的数据到一个非空的Myisam表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的Myisam表，默认就是先导入数据然后才创建索引的，所以不用进行设置。2). 而对于Innodb类型的表，这种方式并不能提高导入数据的效率。对于Innodb类型的表，我们有 以下几种方式可以提高导入的效率：a. 因为Innodb类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果Innodb表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。b. 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。c. 如果应用使用自动提交的方式，建议在导入前执行SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。 2.优化insert语句 1). 如果你同时从同一客户插入很多行，使用多个值表的INSERT语句。这比使用分开INSERT语句快 (在一些情况中几倍)。Insert into test values(1,2),(1,3),(1,4)„2). 如果你从不同客户插入很多行，能通过使用INSERT DELAYED语句得到更高的速度。Delayed的含 义是让insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘；这比每条语句分别插入要快的多；LOW_PRIORITY刚好相反，在所有其他用户对表的读写完后才进行插入；3). 将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）；4). 如果进行批量插入，可以增加bulk_insert_buffer_size变量值的方法来提高速度，但是，这只 能对myisam表使用；5). 当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT语句快20 倍；6). 根据应用情况使用replace语句代替insert；7). 根据应用情况使用ignore关键字忽略重复记录。 3.优化group by语句 默认情况下，MySQL排序所有GROUP BY col1，col2，….。查询的方法如同在查询中指定ORDER BY col1，col2，…。如果显式包括一个包含相同的列的ORDER BY子句，MySQL可以毫不减速地对它进行优化，尽管仍然进行排序。 如果查询包括GROUP BY但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。例如：INSERT INTO foo SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL; 4.优化order by语句 在某些情况中，MySQL可以使用一个索引来满足ORDER BY子句，而不需要额外的排序。where条件和order by使用相同的索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或者都是降序。例如：下列sql可以使用索引。SELECT * FROM t1 ORDER BY key_part1,key_part2,... SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC; SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;但是以下情况不使用索引：SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC；–order by的字段混合ASC和DESCSELECT * FROM t1 WHERE key2=constant ORDER BY key1；–用于查询行的关键字与ORDER BY中所使用的不相同SELECT * FROM t1 ORDER BY key1, key2；–对不同的关键字使用ORDER BY： 5.优化join语句 Mysql4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN).. 替代。 假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成:SELECT * FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )如果使用连接(JOIN).. 来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下:SELECT * FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL连接(JOIN).. 之所以更有效率一些，是因为 MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 6.mysql如何优化or条件 对于or子句，如果要利用索引，则or之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。 7查询优先还是更新（insert、update、delete）优先 MySQL还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。 我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。 下面我们提到的改变调度策略的方法主要是针对Myisam存储引擎的，对于Innodb存储引擎，语句的执行是由获得行锁的顺序决定的。 MySQL的默认的调度策略可用总结如下：1). 写入操作优先于读取操作。2). 对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。3). 对某张数据表的多个读取操作可以同时地进行。 MySQL提供了几个语句调节符，允许你修改它的调度策略：a. LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE。b. HIGH_PRIORITY关键字应用于SELECT和INSERT语句。c. DELAYED关键字应用于INSERT和REPLACE语句。如果写入操作是一个LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在LOW_PRIORITY写入操作永远被阻塞的情况。 SELECT查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的SELECT在正常的SELECT语句之前执行，因为这些语句会被写入操作阻塞。 如果你希望所有支持LOW_PRIORITY选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates选项来启动服务器。通过使用INSERT HIGH_PRIORITY来把INSERT语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。 8.使用SQL提示SELECT SQL_BUFFER_RESULTS ... 将强制MySQL生成一个临时结果集。只要所有临时结果集生成后，所有表上的锁定均被释放。这能在遇到表锁定问题时或要花很长时间将结果传给客户端时有所帮助。 当处理一个会让客户端耗费点时间才能处理的大结果集时，可以考虑使用SQL_BUFFER_RESULT 提示字。这样可以告诉MySQL将结果集保存在一个临时表中，这样可以尽早的释放各种锁。USE INDEX在你查询语句中表名的后面，添加USE INDEX 来提供你希望MySQ去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ...IGNORE INDEX如果你只是单纯的想让MySQL忽略一个或者多个索引，可以使用IGNORE INDEX作为Hint。Eg:SELECT * FROM mytale IGNORE INDEX (priority) ...FORCE INDEX为强制MySQL使用一个特定的索引，可在查询中使用FORCE INDEX作为Hint。Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ... 其他优化措施 使用持久的连接数据库以避免连接开销。 经常检查所有查询确实使用了必要的索引。 避免在频繁更新的表上执行复杂的SELECT查询，以避免与锁定表有关的由于读、写冲突发生的问题。 对于没有删除的行操作的MyISAM表，插入操作和查询操作可以并行进行，因为没有删除操作的表查 询期间不会阻塞插入操作．对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。 充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL需 要做的语法分析从而提高插入速度。 对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。 通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份 期间对应用的影响，可以在复制服务器上执行备份操作。 表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的影响，推荐通 过应用来实现字段的自增长。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>