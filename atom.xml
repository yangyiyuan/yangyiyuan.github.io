<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ewan&#39;s Blog</title>
  <subtitle>Ewan&#39;s Blog | 杨依园技术博客 | 专注于PHP，涉及MySQL，Linux，Web，Nginx，Apache，Phalcon，Laravel，Redis，PostgreSql，Composer，Beanstalkd，Swoole</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iooeo.com/"/>
  <updated>2016-12-13T07:56:38.000Z</updated>
  <id>http://www.iooeo.com/</id>
  
  <author>
    <name>Ewan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>互联网协议总结</title>
    <link href="http://www.iooeo.com/2016/12/13/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://www.iooeo.com/2016/12/13/互联网协议总结/</id>
    <published>2016-12-13T03:41:29.000Z</published>
    <updated>2016-12-13T07:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="互联网协议入门"><a href="#互联网协议入门" class="headerlink" title="互联网协议入门"></a>互联网协议入门</h2><p>每天重复搬砖的动作,发现很多底层的基础只是都有点忘了…补一下喽,这里参照<a href="http://www.ruanyifeng.com" target="_blank" rel="external">阮一峰</a>的博客梳理一下<br>互联网的核心是一系列的协议,总称为”互联网协议”(Internet Protocol Suite).它们对电脑如何连接和组网,做出了详尽的规定.理解了这些协议,就理解了互联网的原理.<br><a id="more"></a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>1.1 五层模型</p>
<blockquote>
<p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。<br>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。<br>如何分层有不同的模型，有的模型分七层，有的分四层。个人觉得把互联网分成五层，比较容易解释。<br><img src="http://image.beekka.com/blog/201205/bg2012052902.png" alt="互联网实现-h250"><br>如图所示,越往下面的层,越靠近硬件;越往上面的层,越靠近用户.</p>
</blockquote>
<p>1.2 层与协议</p>
<blockquote>
<p>每一层都是为了完成一种功能.为了实现这些功能,就需要大家都遵守共同的规则.<br>大家都遵守的规则,就叫做”协议”(protocol).<br>互联网的每一层都定义了很多协议.这些协议的总称,就叫做”互联网协议”(Internet Protocol Suite).它是互联网的核心.</p>
</blockquote>
<h3 id="实体层-Physical-Layer"><a href="#实体层-Physical-Layer" class="headerlink" title="实体层 Physical Layer"></a>实体层 Physical Layer</h3><blockquote>
<p>从最底下的一层开始.<br>计算机要组网,当然是先把电脑连接起来,可以用光缆,电缆,双绞线,无线电波等方式.<br><img src="http://image.beekka.com/blog/201205/bg2012052903.png" alt="计算机组网"><br>这就叫做”实体层”,他就是把电脑连接起来的物理手段.它主要规定了网络的一些电气特性,作用是负责传送0和1的电信号.</p>
</blockquote>
<h3 id="链接层-Link-Layer"><a href="#链接层-Link-Layer" class="headerlink" title="链接层 Link Layer"></a>链接层 Link Layer</h3><p>3.1 定义</p>
<blockquote>
<p>单纯的0和1没有任何意义,必须规定解读方式:多少个电信号算一组?每个信号位有什么意义?<br>这就是”链接层”的功能,它在”实体层”的上方,确定了0和1的分组方式.</p>
</blockquote>
<p>3.2 以太网协议</p>
<blockquote>
<p>早期的时候,每家公司都有自己的电信号分组方式.逐渐的一种叫做”以太网”(Ethernet)的协议,占据了主导地位.<br>以太网规定,一组电信号构成一个数据包,叫做”帧”(Frame).每一帧分成两个部分:标头(head)和数据(data).<br><img src="http://image.beekka.com/blog/201205/bg2012052904.png" alt="帧"><br>“标头”包含数据包的一些说明项,比如发送者,接受者,数据类型等等;”数据”则是数据包的具体内容.<br>“标头”的长度,固定为18字节.”数据”长度,最短为46字节,最长为1500字节.因此,整个”帧”最短为64字节,最长为1518字节,如果数据很长,就必须分割成多个”帧”进行发送.</p>
</blockquote>
<p>3.3 MAC地址</p>
<blockquote>
<p>上面提到，以太网数据包的”标头”,包含了发送者和接受者的信息,那么,发送者和接受者是如何标识呢?<br>以太网规定,连入网络的所有设备,都必须具有”网卡”接口.数据包必须是从一块网卡,传送到另一块网卡.网卡的地址,就是数据包的发送地址和接收地址,这叫做MAC地址.<br><img src="http://image.beekka.com/blog/201205/bg2012052905.jpg" alt="网卡"><br>每块网卡出厂的时候,都有一个全世界独一无二的MAC地址,长度是48个二进制位,通常用12个十六进制数表示.<br><img src="http://image.beekka.com/blog/201205/bg2012052906.png" alt="网卡"><br>前6个十六进制数是厂商编号,后6个是该厂商的网卡流水号.有了MAC地址,就可以定位网卡和数据包的路径了.</p>
</blockquote>
<p>3.4 广播</p>
<blockquote>
<p>定义地址只是第一步,后面还有更多的步骤.<br>首先,一块网卡怎么会知道另一块网卡的MAC地址?<br>回答是有一种ARP协议,可以解决这个问题.这个留到后面介绍,这里只需要知道,以太网数据包必须知道接收方的MAC地址,然后才能发送.<br>其次,就算有了MAC地址,系统怎样才能把数据包准确的发送到接收方?<br>回答是以太网采用了一种很”原始”的方式,它不是把数据包准确送到接收方,而是向本网络内所有计算机发送,让每台计算机自己判断,是否为接受方.<br><img src="http://image.beekka.com/blog/201205/bg2012052907.png" alt="数据包发送"><br>上图中,1号计算机向2号计算机发送一个数据包,同一个子网络的3号,4号,5号计算机都会收到这个包.它们读取到这个包的”标头”,找到接收方的MAC地址,然后与自身的MAC地址相比较,如果两者相同,就接收这个包,做进一步处理,否则就丢弃这个包.这种发送方式就叫做”广播”(broadcasting).<br>有了这个数据包的定义,网卡的MAC地址,广播的发送方式,”连接层”就可以在多台计算机之间传送数据了.</p>
</blockquote>
<h3 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层 Network Layer"></a>网络层 Network Layer</h3><p>4.1 网络层的由来</p>
<blockquote>
<p>以太网协议,依靠MAC地址发送数据.理论上,单单依靠MAC地址,上海的网卡就可以找到洛杉矶的网卡了,技术上是可以实现的.<br>但是,这样做有一个重大的缺点,以太网采用广播的发送方式发送数据包,所有成员人手一”包”,不仅效率低,而且局限在发送者所在的子网络.这就是说,如果两台计算机不在同一个子网络,广播是传不过去的.这种设计是合理的,否则互联网上每一台计算机都会收到所有的”包”,那会引起灾难.<br>互联网是无数子网络共同组成的一个巨型网络,很难想象上海和洛杉矶的电脑会在同一个子网络,这几乎是不可能的.<br><img src="http://image.beekka.com/blog/201205/bg2012052914.png" alt="Internet"><br>因此,必须找到一种方法,能够区分哪些MAC地址属于同一个子网络,哪些不是.如果是同一子网络,就采用广播的方式发送,否则就采用”路由”的方式发送.(“路由”的意思,是指如何向不同的子网络发送数据包,这是一个很大的主题,本文不涉及.)遗憾的是,MAC地址本身无法做到这一点,它只与厂商有关,与所出网络无关.<br>这就导致了”网络层”的诞生,它的作用是引进一套新的地址,使得我们能区分不同的计算机是否属于同一个自网络.这套地址就叫做”网络地址”,简称”网址”.<br>于是,”网络层”出现以后,每台计算机有了两种地址,一种是MAC地址,另一种是网络地址.两种地址之间没有任何联系,MAC地址是绑定在网卡上的,网络地址则是管理员分配的,它们只是随机组合在一起.<br>网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包发送到该子网络中的没押镖网卡.因此,从逻辑上可以推断,必定是先处理网络地址,然后再处理MAC地址.</p>
</blockquote>
<p>4.2 IP协议</p>
<blockquote>
<p>规定网络地址的协议,叫做IP协议.它所定义的地址,就被称为IP地址.<br>目前,广泛采用的IP协议第四版,简称IPv4.这个版本规定,网络地址由32个二进制位组成.<br><img src="http://image.beekka.com/blog/201205/bg2012052908.png" alt="IP"><br>习惯上,我们分成4段的十进制数表示IP地址,从0.0.0.0一直到255.255.255.255.<br>互联网上每一台计算机,都会分配到一个IP地址.这个地址分成两部分,前一部分代表网络,后一部分代表主机.比如,IP地址172.16.254.1,这是一个32位的地址,假定它的网络部分是前24位(172.16.254),那么主机部分就是后8位(最后一个1).处于同一子网络的计算机,它们的IP地址的网络部分必定是相同的,也就是说172.16.254.2应该与172.16.254.1处于同一个子网络.<br>但是,问题在于单单从IP地址,我们无法判断网络部分.还是以172.16.254.1为例,它的网络部分,到底是前24位,还是前16位,甚至是前28位,从IP地址上是看不出来的.<br>那么.怎样才能从IP地址,判断两台计算机是否属于同一个子网络呐?这就是要用到另一个参数”子网掩码”(subnet mask).<br>所谓”子网掩码”,就是表示子网络特征的一个参数.它在形式上等同于IP地址,也就是一个32位的二进制数字,他的网络部分全部为1,主机部分全部为0.比如,IP地址172.16.254.1,如果已知网络部分是前24位,主机部分是后8位,那么子网掩码就是11111111.11111111.11111111.00000000,写成十进制就是255.255.255.0<br>知道”子网掩码”,我们就能判断,任意两个IP地址是否处在同一个子网络.方法是将两个IP地址与子网掩码分别进行AND运算(两个数位都为1,运行结果为1,否则为0),然后比较结果是否相同,如果是的话,就表明它们在同一个子网络中,否则就不是.<br>比如,一直IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0,请问它们是否在同一个子网络?两者与子网掩码分别进行AND运算,结果都是172.16.254.0,因此它们在同一个子网络.<br>总结一下,IP协议的作用主要有两个,一个是为每一台计算机分配IP地址,另一个是确定哪些IP地址在同一个子网络.</p>
</blockquote>
<p>4.3 IP数据包</p>
<blockquote>
<p>根据IP协议发送的数据,就叫做IP数据包.不难想象,其中必定包括IP信息.<br>但是前面说过,以太网数据包值包含MAC地址,并没有IP地址的栏位.那么是否需要修改数据包定义,再添加一个栏位呐?<br>回答是不需要,我们可以把IP数据包直接放进意外网数据包的”数据”部分,因此完全不用修改以太网的规格.这就是互联网分层结构的好处:上层的变动完全不涉及下层的结构.<br>具体来说,IP数据包也分为”标头”和”数据”两部分.<br><img src="http://image.beekka.com/blog/201205/bg2012052909.png" alt="IP数据包"><br>“标头”部分主要包括版本,长度,IP地址等信息,”数据”部分则是IP数据包的具体内容,它放进以太网数据包后,以太网数据包就变成了下面这样.<br><img src="http://image.beekka.com/blog/201205/bg2012052910.png" alt="以太网数据包"><br>IP数据包的”标头”部分的长度为20~60字节,真个数据包的总长度为65535字节.因此,理论上,一个IP数据包的”数据”部分,最长为65515字节.前面说过,以太网数据包的”数据”部分,最长只有1500字节,因此,IP数据包超过了1500字节,它就需要分割成几个以太网数据包,发开发送了.</p>
</blockquote>
<p>4.4 ARP协议</p>
<blockquote>
<p>关于”网络层”,还有最后一点需要说明.<br>因为IP数据包是放在以太网数据包里发送的,所以我们必须同时知道两个地址,一个是对方的MAC地址,另一个是对方的IP地址.通常情况下,对方的IP地址是已知的(后文会解释),但是我们不知道它的MAC地址.<br>所以,我们需要一种机制,能够从IP地址得到MAC地址.<br>这里又可以分成两种情况.第一种情况,如果两台主机不在同一个子网络,那么事实上没有办法得到对方的MAC地址,只能把数据包传送到两个子网络连接处的”网关”(gateway),让网关去处理.<br>第二种情况,如果两台主机在同一个子网络,那么我们可以用ARP协议,得到对方的MAC地址.ARP协议也是发出一个数据包(包含在以太网数据包中),其中包含它所要查询主机的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个”广播”地址.它所在子网络的每一台主机,都会收到这个数据包,从中取出IP地址,与自身的IP地址进行比较.如果两者相同,都做出回复,向对方报告自己的MAC地址,否则就丢弃这个包.<br>总之,有了ARP协议之后,我们就可以得到同一个子网络内的主机MAC地址,可以把数据包发送到任意一台主机之上了.</p>
</blockquote>
<h3 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层 Transport Layer"></a>传输层 Transport Layer</h3><p>5.1 传输层的由来</p>
<blockquote>
<p>有了MAC地址和IP地址,我们已经可以在互联网上任意两台主机上建立通信.<br>接下来的问题是,同一台主机上有许多程序都需要用到网络,比如,你一边浏览网页,一边与朋友在线聊天.当一个数据包从互联网上发来的时候,你怎么知道,它是表示网页的内容,还是表示在线聊天的内容?<br>也就是说,我们还需要一个参数,表示这个数据包到底供哪个程序(进程)使用.这个参数就叫做”端口”(port)，它其实是每一个使用网卡的程序的编号.每个数据包都发到主机的特定端口,所以不同的程序就能取到自己所需要的数据.<br>“端口”是0到65535之间的一个整数,正好16个二进制位.0到1023的端口被系统占用,用户只能选用大于1023的端口.不管是浏览网页还是在线聊天,应用程序会随机选用一个端口,然后与服务器的相应端口联系.<br>“传输层”的功能,就是建立”端口到端口”的通信.相比之下,”网络层”的功能是建立”主机到主机”的通信.只要确定主机和端口,我们就能实现程序之间的交流.因此,Unix系统就把主机+端口,叫做”套接字”(socket).有了它,就可以进行网络应用程序开发了.</p>
</blockquote>
<p>5.2 UDP协议</p>
<blockquote>
<p>现在,我们必须在数据包中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式几乎就是在数据前面,加上端口号.<br>UDP数据包也,是由”标头”和”数据”两部分组成.<br><img src="http://image.beekka.com/blog/201205/bg2012052911.png" alt="UDP数据包"><br>“标头”部分主要定义了发出端口和接收端口,”数据”部分就是具体的内容.然后,把整个UDP数据包放入IP数据包的”数据”部分,而前面说过,IP数据包又是放在以太网数据包之中的,所以整个以太网数据包现在变成了下面这样:<br><img src="http://image.beekka.com/blog/201205/bg2012052912.png" alt="以太网数据包"><br>UDP数据包非常简单,”标头”部分一共只有8个字节,总长度不超过65535字节,正好放进一个IP数据包.</p>
</blockquote>
<p>5.3 TCP协议</p>
<blockquote>
<p>UDP协议的优点是比较简单,容易实现,但是缺点是可靠性较差,一旦数据包发出,无法知道对方是否收到.<br>为了解决这个问题,提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为,它就是有确认机制的UDP协议,每发出一个数据包都要求确认.如果有一个数据包遗失,就收不到确认,发出方就知道有必要重发这个数据包了.<br>因此,TCP协议能够确保数据不会遗失.它的缺点是过程复杂,实现困难,消耗较多的资源.<br>TCP数据包和UDP数据包一样,都是内嵌在IP数据包的”数据”部分.TCP数据包没有长度限制,理论上可以无限长,但是为了保证网络的效率,通常TCP数据包的长度不会超过IP数据包的长度,以确保单个TCP数据包不必再分割.</p>
</blockquote>
<h3 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层 Application Layer"></a>应用层 Application Layer</h3><blockquote>
<p>应用程序收到”传输层”的数据,接下来就要进行解读.由于互联网是开放架构,数据来源五花八门,必须事先规定好格式,否则根本无法解读.<br>“应用层”的作用,就是规定应用程序的数据格式.<br>举例来说,TCP协议可以为各种各样的程序传递数据,比如Email,WWW,FTP等等.那么,必须有不同协议规定电子邮件,网页,FTP数据的格式.这些应用程序协议就构成了”应用层”.<br>这是最高的一层,直接面对用户.它的数据就放在TCP数据包的”数据”部分.因此,现在的以太网的数据包就变成下面这样.<br><img src="http://image.beekka.com/blog/201205/bg2012052913.png" alt="以太网数据包"><br>至此,整个互联网的五层结构,自下而上全部讲完了.这是从系统的角度,解释互联网是如何构成的.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;互联网协议入门&quot;&gt;&lt;a href=&quot;#互联网协议入门&quot; class=&quot;headerlink&quot; title=&quot;互联网协议入门&quot;&gt;&lt;/a&gt;互联网协议入门&lt;/h2&gt;&lt;p&gt;每天重复搬砖的动作,发现很多底层的基础只是都有点忘了…补一下喽,这里参照&lt;a href=&quot;http://www.ruanyifeng.com&quot;&gt;阮一峰&lt;/a&gt;的博客梳理一下&lt;br&gt;互联网的核心是一系列的协议,总称为”互联网协议”(Internet Protocol Suite).它们对电脑如何连接和组网,做出了详尽的规定.理解了这些协议,就理解了互联网的原理.&lt;br&gt;
    
    </summary>
    
      <category term="计算机" scheme="http://www.iooeo.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="网络" scheme="http://www.iooeo.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机" scheme="http://www.iooeo.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="通讯协议" scheme="http://www.iooeo.com/tags/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>git删除已提交的文件或文件夹</title>
    <link href="http://www.iooeo.com/2016/12/12/git%E5%88%A0%E9%99%A4%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://www.iooeo.com/2016/12/12/git删除已提交的文件或文件夹/</id>
    <published>2016-12-12T06:50:51.000Z</published>
    <updated>2016-12-12T07:05:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今个写脚本测试的时候不小心将记录数据的文件提交上去了,研究了一下git忽略已提交的文件或者文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git rm --cached logs/put_file.log</div><div class="line">$ vi .gitignore</div><div class="line"># .gitignore添加要忽略的文件</div><div class="line">$ logs/put_file.log</div><div class="line">$ git commit -m &quot;We really don&apos;t want Git to track this anymore!&quot;</div></pre></td></tr></table></figure>
<p>这样就可以完成忽略已提交的文件或者文件夹了<br>PS:文件夹的话使用<code>logs/*</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今个写脚本测试的时候不小心将记录数据的文件提交上去了,研究了一下git忽略已提交的文件或者文件夹&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
      <category term="Git" scheme="http://www.iooeo.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.iooeo.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>AES加密解密</title>
    <link href="http://www.iooeo.com/2016/12/06/AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>http://www.iooeo.com/2016/12/06/AES加密解密/</id>
    <published>2016-12-06T01:23:27.000Z</published>
    <updated>2016-12-06T01:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AES-（高级加密标准"><a href="#AES-（高级加密标准" class="headerlink" title="AES （高级加密标准)"></a>AES （高级加密标准)</h1><p>  高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。<br>   说下PHP的用法~~<br><a id="more"></a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Security &#123;</div><div class="line">	public static function encrypt($input, $key) &#123;</div><div class="line">		$size = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);</div><div class="line">		$input = Security::pkcs5_pad($input, $size);</div><div class="line">		$td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, &apos;&apos;, MCRYPT_MODE_ECB, &apos;&apos;);</div><div class="line">		$iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_RAND); </div><div class="line">		mcrypt_generic_init($td, $key, $iv); </div><div class="line">		$data = mcrypt_generic($td, $input); </div><div class="line">		mcrypt_generic_deinit($td); </div><div class="line">		mcrypt_module_close($td); </div><div class="line">		$data = base64_encode($data); </div><div class="line">		return $data; </div><div class="line">	&#125; </div><div class="line"></div><div class="line">	private static function pkcs5_pad ($text, $blocksize) &#123; </div><div class="line">		$pad = $blocksize - (strlen($text) % $blocksize);</div><div class="line">		return $text . str_repeat(chr($pad), $pad);</div><div class="line">	&#125; </div><div class="line"></div><div class="line">	public static function decrypt($sStr, $sKey) &#123;</div><div class="line">		$decrypted= mcrypt_decrypt(</div><div class="line">			MCRYPT_RIJNDAEL_128,</div><div class="line">			$sKey, </div><div class="line">			base64_decode($sStr), </div><div class="line">			MCRYPT_MODE_ECB</div><div class="line">		);</div><div class="line">		$dec_s = strlen($decrypted); </div><div class="line">		$padding = ord($decrypted[$dec_s-1]); </div><div class="line">		$decrypted = substr($decrypted, 0, -$padding);</div><div class="line">		return $decrypted;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">require_once(&apos;./security.php&apos;);</div><div class="line"></div><div class="line">$value = &quot;example&quot;;</div><div class="line">$key = &quot;1234567891234567&quot;; //16 Character Key</div><div class="line">echo Security::encrypt($value, $key);</div><div class="line">echo Security::decrypt(Security::encrypt($value, $key), $key);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AES-（高级加密标准&quot;&gt;&lt;a href=&quot;#AES-（高级加密标准&quot; class=&quot;headerlink&quot; title=&quot;AES （高级加密标准)&quot;&gt;&lt;/a&gt;AES （高级加密标准)&lt;/h1&gt;&lt;p&gt;  高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。&lt;br&gt;   说下PHP的用法~~&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 深入浅出</title>
    <link href="http://www.iooeo.com/2016/11/23/MySQL-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"/>
    <id>http://www.iooeo.com/2016/11/23/MySQL-深入浅出/</id>
    <published>2016-11-23T04:41:54.000Z</published>
    <updated>2016-11-23T04:42:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL" scheme="http://www.iooeo.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="http://www.iooeo.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://www.iooeo.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Firing！！！</title>
    <link href="http://www.iooeo.com/2016/11/17/Firing%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://www.iooeo.com/2016/11/17/Firing！！！/</id>
    <published>2016-11-17T08:06:39.000Z</published>
    <updated>2016-11-17T08:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过两天的奋战，<code>Ewan&#39;s Blog</code> 终于与大家见面了。目前网站定位方向为技术性博客，可能稍后会有些栏目的调整，期待大家的关注。</p>
<p>之前也有做过自己的博客网站,经历了服务器到期,域名续费,赶上有段时间工作调整没时间整理,导致博客更新中断.而后一直有新建博客的想法,说到这个特别的感谢一下<a href="http://www.liuxiaojia.cc/" target="_blank" rel="external">胖佳</a> 在网站的搭建过程中的先锋精神和技术指导.还要感谢<a href="http://www.pythondev.org" target="_blank" rel="external">jarvan君</a>和<a href="http://old.tumiaoya.com/" target="_blank" rel="external">小白</a>的技术指导,说句实在话jarvan君是我工作以来对我帮助最大的一位,之前一起住学校宿舍、一起在一家公司上班,生活中是个老大哥、工作中亦师亦友的这种关系令我享受在其中.当然上面提到胖佳和小白那两只货是我在北京性格上很合得来的哥们,为此哥几个一周撸五次串也不为过.</p>
<p>在北京学习的那几个月是我人生的一个转折点,更是我人生一个新的起点.</p>
<p><em>后续会陆续将之前整理的博客文章搬迁过来,也会发表一些新的文章出来供大家分享学习</em></p>
<h3 id="既然有了一个好的起点，我们就跟要努力向前冲，Firing，Firing！！！"><a href="#既然有了一个好的起点，我们就跟要努力向前冲，Firing，Firing！！！" class="headerlink" title="既然有了一个好的起点，我们就跟要努力向前冲，Firing，Firing！！！"></a>既然有了一个好的起点，我们就跟要努力向前冲，Firing，Firing！！！</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过两天的奋战，&lt;code&gt;Ewan&amp;#39;s Blog&lt;/code&gt; 终于与大家见面了。目前网站定位方向为技术性博客，可能稍后会有些栏目的调整，期待大家的关注。&lt;/p&gt;
&lt;p&gt;之前也有做过自己的博客网站,经历了服务器到期,域名续费,赶上有段时间工作调整没时间整理,导致博
    
    </summary>
    
      <category term="杂谈" scheme="http://www.iooeo.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="微语" scheme="http://www.iooeo.com/tags/%E5%BE%AE%E8%AF%AD/"/>
    
      <category term="胡侃" scheme="http://www.iooeo.com/tags/%E8%83%A1%E4%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 存储例程</title>
    <link href="http://www.iooeo.com/2015/03/23/MySQL-%E5%AD%98%E5%82%A8%E4%BE%8B%E7%A8%8B/"/>
    <id>http://www.iooeo.com/2015/03/23/MySQL-存储例程/</id>
    <published>2015-03-23T04:07:59.000Z</published>
    <updated>2016-11-23T04:50:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>好高兴啊，Ewan学习进行时。mysql存储例程学习总结拿来共享喽。<br><a id="more"></a></p>
<ul>
<li><p>1.存储例程定义</p>
<blockquote>
<p>存储在数据库服务器中的一组sql语句，通过在查询中调用一个指定的名称来执行这些sql语句命令。mysql存储例程实际上包含了存储过程和存储函数，他们被统称为存储例程。<br>存储过程：存储过程支持select,insert,update和delete等sql命令的执行，还可以设置能在程序外引用的参数。<br>存储函数：只支持select命令的执行，只接受输入参数，必须返回且只返回一个值，此外还可以旧爱那个存储函数直接嵌套到sql命令中。</p>
</blockquote>
</li>
<li><p>2.为什么使用存储例程</p>
<blockquote>
<p>我们都知道应用程序分为两种，一种是基于桌面一种是基于web，它们都使用一个MYSQL数据库并完成很多相同的任务。而这两种应用程序可能带来不易维护和易遭sql语句注入的弊端，针对这些难题，存储例程的数据库特性成为最常用的解决方案之一。</p>
</blockquote>
</li>
<li><p>3.存储例程优点</p>
<blockquote>
<p>1）一致性<br>2）高性能<br>3）安全性<br>4）架构</p>
</blockquote>
</li>
<li><p>4.存储过程基本语法<br><code>create procedure (过程名)［过程参数...］
begin
(内容，sql语句)
end</code></p>
<blockquote>
<p>调用：<br><code>set @要设置的参数值</code><br><code>call  参数名(@要设置的参数值)</code><br>从另一个例程中调用例程：<br><code>create procedure 进程名</code><br><code>begin</code><br><code>call 另一个进程名();</code><br><code>end</code><br>查看存储进程:<br><code>show procedure status;</code><br>一可以查看某个存储进程的详细:<br><code>show procedure status like &#39;变量名&#39;\G;</code><br>查看进程的创建语法:<br><code>show create procedure 进程名;</code><br>修改存储进程：<br><code>alter procedure 进程名 .....</code><br>删除存储进程：<br><code>drop procedure 进程名;</code><br>是不是很简单，下面来详细分解一下语法的具体参数:<br>存储过程参数用在存储过程的定，共有三种类型in,out,inout如下：create procedure (过程名)［in/out/inout 参数名 数据类型］<br>in：为默认值，使用该参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回。<br>out：使用该参数的之的值在存储过程内部被改变，并返回。<br>inout:使用该参数的值，调用时指定，并且可被改变并返回。</p>
</blockquote>
</li>
<li><p>5.声明和设置变量</p>
<blockquote>
<p>声明变量：<br>这里使用到了declare，如下：<br><code>declare 变量名 变量类型;</code><br>设置变量：<br><code>set 变量名=值;</code><br>这里做下延伸：<br>在mysql客户端使用用户变量，如下：<br><code>select &#39;hello world!&#39; into @z;
set @x=&#39;hello world!&#39;;
set @c=1+1;</code><br>执行：select …;<br>这里要注意：<br>1）变量名一般以@开头<br>2）滥用用户变量会导致程序难以理解和管理</p>
</blockquote>
</li>
<li><p>6.begin …end</p>
<blockquote>
<p>创建多语句进程时，将语句放在begin end 中间。</p>
</blockquote>
</li>
<li><p>7.条件(条件语句这里不做太多解释）<br><code>if .....then ....</code><br><code>elseif ...then ....</code><br><code>end if;</code><br><code>case</code><br><code>when .... then  :</code><br><code>.....;</code><br><code>when .... then  :</code><br><code>.....;</code><br><code>end case;</code><br><code>while.....end while;</code><br><code>repeat ....end repeat;</code><br><code>loop .....end loop;</code></p>
<blockquote>
<p>repeat是在执行操作后检查结果，而while是在执行前进行检查。<br>oop循环不需要初始条件，这点和while 循环相似，同时和repeat循环一样不需要结束条件, leave语句的意义是离开循环。<br>lables标号可以用在begin repeat while 或者loop 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。<br>iterate迭代,为了一些需要重复执行一组语句的任务。<br>通过引用复合语句的标号,来从新开始复合语句。<br>leave 在得到变量的值或特定任务的结果之后，可能希望通过leave命令立即退出循环或begin…end。</p>
</blockquote>
</li>
<li><p>8.存储函数</p>
<blockquote>
<p>字符串类：<br><code>charset(str) //返回字串字符集</code><br><code>concat (string2 [,... ]) //连接字串</code><br><code>instr (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0</code><br><code>lcase(string2 ) //转换成小写</code><br><code>left (string2 ,length ) //从string2中的左边起取length个字符</code><br><code>length (string ) //string长度</code><br><code>load_file(file_name ) //从文件读取内容</code><br><code>locate(substring , string [,start_position ] ) 同INSTR,但可指定开始位置</code><br><code>lpad(string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为length</code><br><code>ltrim(string2 ) //去除前端空格</code><br><code>repeat(string2 ,count ) //重复count次</code><br><code>replace(str ,search_str ,replace_str ) //在str中用replace_str替换search_str</code><br><code>rpad(string2 ,length ,pad) //在str后用pad补充,直到长度为length</code><br><code>rtrim(string2 ) //去除后端空格</code><br><code>strcmp (string1 ,string2 ) //逐字符比较两字串大小</code><br><code>substring (str , position [,length ]) //从str的position开始,取length个字符 注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1</code><br><code>trim([[BOTH|LEADING|TRAILING] [padding] FROM]string2) //去除指定位置的指定字符</code><br><code>ucase(string2 ) //转换成大写</code><br><code>right(string2,length) //取string2最后length个字符</code><br><code>space(count) //生成count个空格</code><br>数学类<br><code>ABS (number2 ) //绝对值</code><br><code>BIN (decimal_number ) //十进制转二进制</code><br><code>CEILING (number2 ) //向上取整</code><br><code>CONV(number2,from_base,to_base) //进制转换</code><br><code>FLOOR (number2 ) //向下取整</code><br><code>FORMAT (number,decimal_places ) //保留小数位数</code><br><code>HEX (DecimalNumber ) //转十六进制 注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(&#39;DEF&#39;)返回4142143 也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19</code><br><code>LEAST (number , number2 [,..]) //求最小值</code><br><code>MOD (numerator ,denominator ) //求余</code><br><code>POWER (number ,power ) //求指数</code><br><code>RAND([seed]) //随机数</code><br><code>ROUND (number [,decimals ]) //四舍五入,decimals为小数位数]</code><br>日期时间类<br><code>ADDTIME (date2 ,time_interval ) //将time_interval加到date2</code><br><code>CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区</code><br><code>CURRENT_DATE ( ) //当前日期</code><br><code>CURRENT_TIME ( ) //当前时间</code><br><code>CURRENT_TIMESTAMP ( ) //当前时间戳</code><br><code>DATE (datetime ) //返回datetime的日期部分</code><br><code>DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间</code><br><code>DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetime</code><br><code>DATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间</code><br><code>DATEDIFF (date1 ,date2 ) //两个日期差</code><br><code>DAY (date ) //返回日期的天</code><br><code>DAYNAME (date ) //英文星期</code><br><code>DAYOFWEEK (date ) //星期(1-7) ,1为星期天</code><br><code>DAYOFYEAR (date ) //一年中的第几天</code><br><code>EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分</code><br><code>MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串</code><br><code>MAKETIME (hour ,minute ,second ) //生成时间串</code><br><code>MONTHNAME (date ) //英文月份名</code><br><code>NOW ( ) //当前时间</code><br><code>SEC_TO_TIME (seconds ) //秒数转成时间</code><br><code>STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示</code><br><code>TIMEDIFF (datetime1 ,datetime2 ) //两个时间差</code><br><code>TIME_TO_SEC (time ) //时间转秒数]</code><br><code>WEEK (date_time [,start_of_week ]) //第几周</code><br><code>YEAR (datetime ) //年份</code><br><code>DAYOFMONTH(datetime) //月的第几天</code><br><code>HOUR(datetime) //小时</code></p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好高兴啊，Ewan学习进行时。mysql存储例程学习总结拿来共享喽。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.iooeo.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="http://www.iooeo.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://www.iooeo.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>laravel安装</title>
    <link href="http://www.iooeo.com/2014/10/13/laravel%E5%AE%89%E8%A3%85/"/>
    <id>http://www.iooeo.com/2014/10/13/laravel安装/</id>
    <published>2014-10-13T09:58:50.000Z</published>
    <updated>2016-11-17T10:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期貌似对 <code>laravel</code> 有使用的需求，就自己安装了一次，发现对于有些人来说确实有点文档不够全面的感觉，现将具体的安装方法总结如下。<br>Composer安装：</p>
<blockquote>
<p>Laravel 框架使用 Composer 来管理代码依赖性。<br>在Windows操作系统中，你可以使用 Composer 的Windows安装工具(<a href="https://getcomposer.org/Composer-Setup.exe)。" target="_blank" rel="external">https://getcomposer.org/Composer-Setup.exe)。</a><br>对PHP版本有要求(最好5.4.0以上)<br>laravel安装：<br>Composer安装完成后，在dos模式中，你的网站目录执行下面命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ composer create-project laravel/laravel your-project-name</div></pre></td></tr></table></figure></p>
</blockquote>
<p>Composer会自动帮你下载Laravel及安装。<br>部署虚拟主机(Apache相关知识)：<br>如果之前对Apache的配置环境没有设置过：<br>(1) Apache配置设置，打开(路径看个人项目环境而定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\wamp\bin\apache\apache2.4.9\conf\httpd.conf</div></pre></td></tr></table></figure></p>
<p>第512~513行，将默认的虚拟主机设置打开(默认是关闭的，前边#去掉即可)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Virtual hosts</div><div class="line">Include conf/extra/httpd-vhosts.conf</div></pre></td></tr></table></figure></p>
<p>(2) 配置站点，打开(路径看个人项目环境而定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\wamp\bin\apache\apache2.4.9\conf\extra\httpd-vhosts.conf</div></pre></td></tr></table></figure></p>
<p>在其下方添加站点信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;VirtualHost *:80&gt;</div><div class="line">        DocumentRoot &quot;c:/wamp/www/project/public&quot;</div><div class="line">        ServerName laravel.dev</div><div class="line">        ErrorLog &quot;logs/laravel.log&quot;</div><div class="line">        CustomLog &quot;logs/laravel.log&quot; common</div><div class="line">&lt;/VirtualHost&gt;</div></pre></td></tr></table></figure></p>
<p>(3) 将站点指向项目目录，打开(路径看个人项目环境而定)C:\Windows\System32\drivers\etc\hosts<br>在其下方添加站点信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ 127.0.0.1         laravel.dev</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期貌似对 &lt;code&gt;laravel&lt;/code&gt; 有使用的需求，就自己安装了一次，发现对于有些人来说确实有点文档不够全面的感觉，现将具体的安装方法总结如下。&lt;br&gt;Composer安装：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Laravel 框架使用 Composer
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://www.iooeo.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装dpkg错误解决方案</title>
    <link href="http://www.iooeo.com/2014/09/17/MySQL%E5%AE%89%E8%A3%85dpkg%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://www.iooeo.com/2014/09/17/MySQL安装dpkg错误解决方案/</id>
    <published>2014-09-17T09:39:04.000Z</published>
    <updated>2016-11-17T09:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>Ewan在Ubuntu下安装MySQL的时候出现了一下错误问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">start: Job failed to start</div><div class="line">invoke-rc.d: initscript mysql, action &quot;start&quot; failed.</div><div class="line">dpkg: error processing mysql-server-5.5 (--configure):</div><div class="line">subprocess installed post-installation script returned error exit status 1</div><div class="line">dpkg: dependency problems prevent configuration of mysql-server:</div><div class="line">mysql-server depends on mysql-server-5.5; however:</div><div class="line">Package mysql-server-5.5 is not configured yet.</div><div class="line">dpkg: error processing mysql-server (--configure):</div><div class="line">dependency problems - leaving unconfigured</div><div class="line">No apport report written because the error message indicates its a followup error from a previous failure.</div><div class="line">Errors were encountered while processing:</div><div class="line">mysql-server-5.5</div><div class="line">mysql-server</div><div class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</div></pre></td></tr></table></figure>
</li>
<li><p>经查证，现给出解决办法：<br>删除MySQL前，先删除/var/lib/mysql和/etc/mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo rm /var/lib/mysql/ -R</div><div class="line">$ sudo rm /etc/mysql/ -R</div><div class="line">$ sudo apt-get autoremove mysql* --purge</div><div class="line">$ sudo apt-get remove apparmor</div><div class="line">$ sudo apt-get install mysql-server mysql-common</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ewan在Ubuntu下安装MySQL的时候出现了一下错误问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div
    
    </summary>
    
      <category term="MySQL" scheme="http://www.iooeo.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="http://www.iooeo.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://www.iooeo.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统下搭建lnmp环境</title>
    <link href="http://www.iooeo.com/2014/09/17/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BAlnmp%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.iooeo.com/2014/09/17/Ubuntu系统下搭建lnmp环境/</id>
    <published>2014-09-17T09:01:25.000Z</published>
    <updated>2016-11-17T09:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境：Ubuntu12-04-64"><a href="#环境：Ubuntu12-04-64" class="headerlink" title="环境：Ubuntu12.04 64"></a>环境：Ubuntu12.04 64</h3><ul>
<li><p>登录以后首先更新一下源列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt-get update</div></pre></td></tr></table></figure>
</li>
<li><p>然后安装nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install nginx</div><div class="line">$ /etc/init.d/nginx start --启动ngnix</div><div class="line">$ /etc/init.d/nginx stop --停止ngnix</div><div class="line">$ /etc/init.d/nginx restart --重启ngnix</div><div class="line">$ service ngnix restart --重启ngnix</div></pre></td></tr></table></figure>
</li>
<li><p>安装PHP及相关扩展 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install php5-cli php5-common php5-fpm php5-cgi php5-mysql php5-gd php5-sqlite libssh2-php</div><div class="line">$ service php5-fpm restart --重启php</div></pre></td></tr></table></figure>
</li>
<li><p>配置Ngnix站点检测PHP环境，Ngnix的站点配置文件在/etc/ngnix/conf.d/或/etc/ngnix/sites-enabled/(初始默认)目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi /etc/nginx/sites-enabled/default</div></pre></td></tr></table></figure>
</li>
<li><p>打开初始的配置文件default做一下更改（内容替换或按下面的配置自己更改）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server&#123;</div><div class="line">	listen 80;</div><div class="line">	root /var/www;</div><div class="line">	index index.php index.html index.htm;</div><div class="line">	server_name localhost;</div><div class="line">	location / &#123;</div><div class="line">		try_files $uri $uri/ /index.html;</div><div class="line">	&#125;</div><div class="line">	location ~ \.php$ &#123;</div><div class="line">		fastcgi_pass 127.0.0.1:9000;</div><div class="line">		fastcgi_index index.php;</div><div class="line">		fastcgi_param SCRIPT_FILENAME /var/www$fastcgi_script_name;</div><div class="line">		include /etc/nginx/fastcgi_params;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>保存后在/var/目录下创建www目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir www</div></pre></td></tr></table></figure>
</li>
<li><p>创建文件index.php</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi index.php</div></pre></td></tr></table></figure>
</li>
<li><p>index.php内容检测PHP环境（内容如下）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">phpinfo();</div></pre></td></tr></table></figure>
</li>
<li><p>保存退出，重启nginx和php（命令在上边）</p>
</li>
<li>在浏览器输入localhost，出现PHP环境及扩展配置说明以上安装成功。</li>
<li><p>安装MySQL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install mysql-server-5.5 mysql-client-5.5</div></pre></td></tr></table></figure>
</li>
<li><p>中间要记住自己设定的MySQL密码，安装成功以后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysql -uroot -p</div></pre></td></tr></table></figure>
</li>
<li><p>输入密码进入MySQL数据库代表安装成功。<br>本人安装的时候出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ E:/usr/bin/dpkg returned an error code ...</div></pre></td></tr></table></figure>
</li>
<li><p>错误字样，解决问题见本站<a href="http://www.iooeo.com/2016/11/17/MySQL%E5%AE%89%E8%A3%85dpkg%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">MySQL安装dpkg错误解决方案</a>。 </p>
</li>
<li><p>配置MySQL远程连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ vi /etc/mysql/my.cnf --打开MySQL配置文件找到bind-address = 127.0.0.1，前边加上#，注释掉。</div><div class="line">$ service mysql restart --重启MySQL服务</div></pre></td></tr></table></figure>
</li>
<li><p>进入MySQL，做权限修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mysql -uroot -p mysql </div><div class="line">$ &gt; grant all on *.* root@&apos;%&apos; identified by &apos;你的密码&apos;;</div><div class="line">$ &gt; flush privilefes;</div><div class="line">$ &gt; exit</div></pre></td></tr></table></figure>
</li>
<li><p>至此完毕</p>
</li>
<li>建议重启一遍Ngnix、PHP、MySQL，开发环境就可以正式投入使用了。</li>
<li>尊重原创请挂连接，在此感谢<a href="http://old.tumiaoya.com/" target="_blank" rel="external">小白</a>、<a href="http://www.pythondev.org" target="_blank" rel="external">jarvan君</a>、以及广大奉献资料的网友们。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;环境：Ubuntu12-04-64&quot;&gt;&lt;a href=&quot;#环境：Ubuntu12-04-64&quot; class=&quot;headerlink&quot; title=&quot;环境：Ubuntu12.04 64&quot;&gt;&lt;/a&gt;环境：Ubuntu12.04 64&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登
    
    </summary>
    
      <category term="Linux" scheme="http://www.iooeo.com/categories/Linux/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Linux" scheme="http://www.iooeo.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://www.iooeo.com/tags/MySQL/"/>
    
      <category term="LNMP" scheme="http://www.iooeo.com/tags/LNMP/"/>
    
      <category term="Ngnix" scheme="http://www.iooeo.com/tags/Ngnix/"/>
    
  </entry>
  
  <entry>
    <title>About Me</title>
    <link href="http://www.iooeo.com/2014/09/14/About-Me/"/>
    <id>http://www.iooeo.com/2014/09/14/About-Me/</id>
    <published>2014-09-14T08:42:17.000Z</published>
    <updated>2016-11-17T09:57:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎大家访问Ewan’s Blog：<code>www.iooeo.com</code><br>博主姓名：<code>杨依园</code> | <code>Ewan</code><br>网名：<code>バ 小丑男°乄° 　　　?</code><br>绰号：<code>cola</code>、<code>杨一</code>、<code>一哥</code>、<code>猫叔</code>、<code>小杨</code>、<code>猿某人</code>、<code>酷头（莉姐送的~）</code><br>扣扣：<code>654846126</code><br>邮箱：<code>yuankess@sina.cn</code> | <code>654846126@qq.com</code><br>社交主页：<code>www.iooeo.com</code> | <code>ewan.coding.me</code> | <code>yangyiyuan.github.io</code><br>爱好：<code>玩游戏</code>、<code>听歌</code>、<code>看电影</code>、<code>骑车</code>、<code>滑冰</code>、<code>瞎折腾</code></p>
<h2 id="切换至炫酷版"><a href="#切换至炫酷版" class="headerlink" title="切换至炫酷版"></a><em><a href="http://www.iooeo.com/about/">切换至炫酷版</a></em></h2><h3 id="此处要用程序"><a href="#此处要用程序" class="headerlink" title="此处要用程序"></a>此处要用程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">历程: </div><div class="line">&gt; 2014年09月11日购买域名 www.iooeo.com</div><div class="line">&gt; 购买空间 搭建环境</div><div class="line">&gt; 2014年09月15日开通第一个web网站 www.iooeo.com</div><div class="line">&gt; 2016年11月15日 www.iooeo.com 完成升级</div><div class="line">&gt; 未完待续......</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎大家访问Ewan’s Blog：&lt;code&gt;www.iooeo.com&lt;/code&gt;&lt;br&gt;博主姓名：&lt;code&gt;杨依园&lt;/code&gt; | &lt;code&gt;Ewan&lt;/code&gt;&lt;br&gt;网名：&lt;code&gt;バ 小丑男°乄° 　　　?&lt;/code&gt;&lt;br&gt;绰号：&lt;code&gt;co
    
    </summary>
    
      <category term="杂谈" scheme="http://www.iooeo.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="微语" scheme="http://www.iooeo.com/tags/%E5%BE%AE%E8%AF%AD/"/>
    
      <category term="胡侃" scheme="http://www.iooeo.com/tags/%E8%83%A1%E4%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 触发器</title>
    <link href="http://www.iooeo.com/2014/03/02/MySQL-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://www.iooeo.com/2014/03/02/MySQL-触发器/</id>
    <published>2014-03-02T02:20:42.000Z</published>
    <updated>2016-11-23T03:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ewan又来学习啦，mysql触发器个人学习感悟奉上。"><a href="#Ewan又来学习啦，mysql触发器个人学习感悟奉上。" class="headerlink" title="Ewan又来学习啦，mysql触发器个人学习感悟奉上。"></a>Ewan又来学习啦，mysql触发器个人学习感悟奉上。</h2><ul>
<li><p>1.触发器定义</p>
<blockquote>
<p>sql server里面对某个表的一定的操作，触发某种条件而执行的一段程序。它是一个特殊的存储过程。</p>
</blockquote>
</li>
<li><p>2.为什么使用触发器</p>
<blockquote>
<p>1）强制业务规则<br>2）审计跟踪 –用于跟踪网站区域流量<br>3）验证<br>4）完整性约束引用 –表的关系在项目整个生命周期中的稳定</p>
</blockquote>
</li>
<li><p>3.触发器基本语法<br><code>create trigger triggre_name trigger_time trigger_event on table_name for each row trigger_stmt;</code></p>
<blockquote>
<p>trigger_name：触发器名称；<br>trigger_time：触发时机，取值为before 或after；<br>trigger_event：触发事件，取值为 insert、update或 delete；<br>table_name：建立触发器的表名;<br>trigger_stmt：触发器程序体，可以是一句sql语句，或者用 begin 和 end 包含的多条sql语句。</p>
</blockquote>
</li>
<li><p>4.before与after详解</p>
<blockquote>
<p>before：(insert、update)可以对new进行修改，after不能对new进行修改。两者都不能修改old数据。<br>表插入字段值需要用new计算，只能用before，在别的表中记录插入成功记录或统计插入的条数用after。<br>after update 也就是执行完你的更新之后.再执行这个触发器的语句..<br>before update 就是执行完这个触发器的语句,再执行你的更新.<br>可以建立6种触发器，即：before insert、before update、before delete、after insert、after update、after delete<br><strong>**</strong>有一个限制是不能同时在一个表上建立2个相同类型的触发器，因此在一个表上最多建立6个触发器</p>
</blockquote>
</li>
<li><p>5,trigger_event详解</p>
<blockquote>
<p>msql除了对insert,update,delete 基本操作进行定义外，还定义了load data和replace语句，这两种语句也能引起<br>上述6中类型的触发器的触发。<br>load data 语句用于将一个文件装入到一个数据表中，相当与一系列的 insert 操作。<br>replace语句一般来说和insert语句很像,只是在表中有primary key或unique 索引时，如果插入的数据和原来 primary<br>key或unique索引一致时，会先删除原来的数据，然后增加一条新数据，也就是说，一条 replace 语句有时候等价于一条 update。<br>insert 型触发器：插入某一行时激活触发器，可能通过 insert、load data、replace 语句触发；<br>update 型触发器：更改某一行时激活触发器，可能通过 update 语句触发；<br>delete 型触发器：删除某一行时激活触发器，可能通过 delete、replace 语句触发。</p>
</blockquote>
</li>
<li><p>6.begin … end详解</p>
<blockquote>
<p>在mysql中，begin … end 语句的语法为：<br><code>begin
[statement_list]
end</code><br>statement_list 代表一个或多个语句的列表，列表内的每条语句都必须用分号（;）来结尾。<br>解释器遇到 statement_list 中的分号后就开始执行，然后会报出错误，因为没有找到和 begin匹配的end<br>delimiter命令，它是一条命令，不需要语句结束标识，语法为：<br><code>delimiter new_delemiter</code><br>new_delemiter 可以设为1个或多个长度的符号，默认的是分号（;），我们可以把它修改为其他符号，如管道符：delimiter |<br>在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了管道符，才认为是语句结束。注意，使用完之后，我们还<br>应该记得把它给修改回来。</p>
</blockquote>
</li>
<li><p>7.new与old详解</p>
<blockquote>
<p>new关键字，和mysql中的 inserted和deleted类似，mysql中定义了new和old，用来表示<br>触发器的所在表中，触发了触发器的那一行数据。<br>具体地：<br>在insert型触发器中，new 用来表示将要（before）或已经（after）插入的新数据；<br>在 update型触发器中，old用来表示将要或已经被修改的原数据，new用来表示将要或已经修改为的新数据；<br>在 delete 型触发器中，old用来表示将要或已经被删除的原数据；<br>使用方法： new.columnName （columnName 为相应数据表某一列名）;<br>另外，old 是只读的，而 new 则可以在触发器中使用 set 赋值，这样不会再次触发触发器，造成循环调用。</p>
</blockquote>
</li>
<li><p>8.删除触发器</p>
<blockquote>
<p>和删除数据库、删除表格一样，删除触发器的语法如下：<br><code>drop trigger trigger_name;</code><br>查看现有的触发器：<br><code>show triggers\G;</code></p>
</blockquote>
</li>
<li><p>9.触发器的执行顺序</p>
<blockquote>
<p>我们建立的数据库一般都是 InnoDB 数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，mysql会回滚事务，如下：<br>1)如果before触发器执行失败，sql无法正确执行。<br>2)sql执行失败时，after型触发器不会触发。<br>3)after类型的触发器执行失败，sql会回滚。</p>
</blockquote>
</li>
</ul>
<h4 id="触发器可以大大减少只为确保数据库引用完整性和业务规则而编写的代码量。"><a href="#触发器可以大大减少只为确保数据库引用完整性和业务规则而编写的代码量。" class="headerlink" title="触发器可以大大减少只为确保数据库引用完整性和业务规则而编写的代码量。"></a>触发器可以大大减少只为确保数据库引用完整性和业务规则而编写的代码量。</h4><h4 id="mysql视图学习至此告一段落，以上内容如有语法结构错误，请指出或给予相应的解决方案。"><a href="#mysql视图学习至此告一段落，以上内容如有语法结构错误，请指出或给予相应的解决方案。" class="headerlink" title="mysql视图学习至此告一段落，以上内容如有语法结构错误，请指出或给予相应的解决方案。"></a>mysql视图学习至此告一段落，以上内容如有语法结构错误，请指出或给予相应的解决方案。</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ewan又来学习啦，mysql触发器个人学习感悟奉上。&quot;&gt;&lt;a href=&quot;#Ewan又来学习啦，mysql触发器个人学习感悟奉上。&quot; class=&quot;headerlink&quot; title=&quot;Ewan又来学习啦，mysql触发器个人学习感悟奉上。&quot;&gt;&lt;/a&gt;Ewan又
    
    </summary>
    
      <category term="MySQL" scheme="http://www.iooeo.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="http://www.iooeo.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://www.iooeo.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 视图</title>
    <link href="http://www.iooeo.com/2013/11/13/MySQL-%E8%A7%86%E5%9B%BE/"/>
    <id>http://www.iooeo.com/2013/11/13/MySQL-视图/</id>
    <published>2013-11-13T10:14:04.000Z</published>
    <updated>2016-11-17T23:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ewan之前研究mysql实际操作，个人感悟拿来共享一下。<br>1.视图定义</p>
<blockquote>
<p>视图是从一个或几个基本表导出的虚拟表，意思就是说视图只是依附在基本表上的虚拟表。</p>
</blockquote>
<p>2.视图与基本表的联系与区别</p>
<blockquote>
<p>视图是基本表的查询结果，基本表的数据变了，视图的结果自然就改变了。<br>当然试图改变也会影响到基本表。视图的增删改会影响基本表，但视图不总是能增删盖的哦。在视图的数据与基本表的数据一一对应的时候可以修改，但对于视图的insert应注意，视图必须包含基本表的中没有的默认值的列。</p>
</blockquote>
<p>3.视图的优点</p>
<blockquote>
<p>简化sql查询语句<br>可以更好的进行权限把控<br>适合大数据分表时使用   <em>虽然大数据分表有很多种方法，但视图无疑是个不错的选择哦</em></p>
</blockquote>
<p>4.视图的基本语法<br>create view （视图名） as （select 语句）； <em>是不是很简单啊？但实际应用起来就不是表面这样喽</em><br>5.视图的操作</p>
<blockquote>
<p>修改视图<br>alert view （视图名） as（select 语句）；<br>删除视图<br>drop view (视图名)；</p>
</blockquote>
<p>6.使用algorithm属性优化mysql视图</p>
<blockquote>
<p>在这里algorithm有3个设置可优化视图，分别是merge,temptable,undefined<br>格式为：<code>algorithm = merge/temptable/undefined</code><br>merge算法使mysql将执行视图时传入的任何字句合并到视图的查询定义中，换句话说，视图定义和select查询语句会合并成新的查询语句。<br>当视图指定temptable算法时，创建视图的同时创建视图相对应的temporary表，然后查询视图的语句会从该临时表查取数据。<br>merge和temptable区别就是：merge最终查的是基本表，而temptable查的是虚拟表。merge算法效率要比temptable要高。<br>undefined：顾名思义，为定义，系统会自动选择。</p>
</blockquote>
<p>7.查看视图信息</p>
<blockquote>
<p>可以使用：show create view (视图名)<br>可以使用：DESCRIBE（视图名）<br>可以使用：information_schema数据库包括一个views表，包含一下内容：<br>select <em> from information_schema.views\G  </em>注意是G要大写*</p>
</blockquote>
<p>mysql视图学习至此告一段落，以上内容如有语法结构错误，请指出或给予相应的解决方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ewan之前研究mysql实际操作，个人感悟拿来共享一下。&lt;br&gt;1.视图定义&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;视图是从一个或几个基本表导出的虚拟表，意思就是说视图只是依附在基本表上的虚拟表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.视图与基本表的联系与区别&lt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.iooeo.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="http://www.iooeo.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://www.iooeo.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 优化篇之SQL优化</title>
    <link href="http://www.iooeo.com/2013/11/13/MySQL-%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8BSQL%E4%BC%98%E5%8C%96/"/>
    <id>http://www.iooeo.com/2013/11/13/MySQL-优化篇之SQL优化/</id>
    <published>2013-11-12T23:40:22.000Z</published>
    <updated>2016-11-23T02:10:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="优化SQL的一般步骤"><a href="#优化SQL的一般步骤" class="headerlink" title="优化SQL的一般步骤"></a>优化SQL的一般步骤</h3><ul>
<li><p>1.通过show status和应用特点了解各种SQL的执行频率</p>
<blockquote>
<p>通过SHOW STATUS可以提供服务器状态信息，也可以使用<code>mysqladmin extended-status</code>命令获得。SHOW STATUS可以根据需要显示session级别的统计结果和global级别的统计结果。<br>以下几个参数对Myisam和Innodb存储引擎都计数：<br>1). Com_select 执行select操作的次数，一次查询只累加1；<br>2). Com_insert 执行insert操作的次数，对于批量插入的insert操作，只累加一次；<br>3). Com_update 执行update操作的次数；<br>4). Com_delete 执行delete操作的次数；<br>以下几个参数是针对Innodb存储引擎计数的，累加的算法也略有不同：<br>1). Innodb_rows_read select查询返回的行数；<br>2). Innodb_rows_inserted执行Insert操作插入的行数；<br>3). Innodb_rows_updated 执行update操作更新的行数；<br>4). Innodb_rows_deleted 执行delete操作删除的行数；<br>通过以上几个参数，可以很容易的了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的SQL大致的执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会累加。<br>对于事务型的应用，通过Com_commit和Com_rollback可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。<br>此外，以下几个参数便于我们了解数据库的基本情况：<br>1). Connections 试图连接Mysql服务器的次数<br>2). Uptime    服务器工作时间<br>3). Slow_queries 慢查询的次数</p>
</blockquote>
</li>
<li><p>2.定位执行效率较低的SQL语句</p>
<blockquote>
<p>可以通过以下两种方式定位执行效率较低的SQL语句：<br>1).可以通过慢查询日志定位那些执行效率较低的sql语句，用–log-slow-queries[=file_name]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。可以链接到管理维护中的相关章节。</p>
</blockquote>
</li>
<li><p>3.通过EXPLAIN分析低效SQL的执行计划</p>
<blockquote>
<p>通过以上步骤查询到效率低的SQL后，我们可以通过explain或者desc 获取MySQL如何执行SELECT语句的信息，包括select语句执行过程表如何连接和连接的次序。  explain可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的SELECT。<br><code>mysql&gt;expain select * from table;</code><br>select_type： select 类型<br>table：   输出结果集的表<br>type：     表示表的连接类型, 当表中仅有一行是type的值为system是最佳的连接类型； 当select操作中使用索引进行表连接时type的值为ref；  当select的表连接没有使用索引时，经常会看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。<br> possible_keys： 表示查询时,可以使用的索引列.<br>key：    表示使用的索引<br>key_len：  索引长度<br>rows：   扫描范围<br>Extra：     执行情况的说明和描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+</div><div class="line">| id | select_type | table      | type   | possible_keys | key  | key_len | ref  | rows | Extra               |</div><div class="line">+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+</div><div class="line">|  1 | SIMPLE      | tab_serial | system | NULL          | NULL | NULL    | NULL |    0 | const row not found |</div><div class="line">+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>4.确定问题，并采取相应的优化措施</p>
<blockquote>
<p>经过以上步骤，基本可以确认问题出现的原因，可以根据情况采取相应的措施，进行优化提高执行的效率。</p>
</blockquote>
</li>
</ul>
<h3 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h3><ul>
<li><p>1.索引的存储分类</p>
<blockquote>
<p>myisam表的数据文件和索引文件是自动分开的；innodb的数据和索引是存储在同一个表空间里面，但可以有多个文件组成。<br>索引的存储类型目前只有两种（btree和hash），具体和表的模式相关：<br>myisam     btree<br>innodb     btree<br>memory/heap hash，btree<br>mysql目前不支持函数索引，只能对列的前一部分（length）进行索引，例：<br>create index ind_test on table1(name(5))，<br>对于char和varchar列，使用前缀索引将大大节省空间。</p>
</blockquote>
</li>
<li><p>2.MySQL如何使用索引</p>
<blockquote>
<p>索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高SELECT操作性能的最佳途径。 查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。<br>下列情况下，Mysql不会使用已有的索引：<br>1). 如果mysql估计使用索引比全表扫描更慢，则不使用索引。<br>例如：如果key_part1均匀分布在1 和100之间，下列查询中使用索引就不是很好：<br>SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90<br>2). 如果使用heap表并且where条件中不用＝索引列，其他&gt; 、&lt;、 &gt;=、 &lt;=均不使用索引；<br>3). 如果不是索引列的第一部分；<br>4). 如果like是以％开始；<br>5). 对where后边条件为字符串的一定要加引号，字符串如果为数字mysql会自动转为字符串，但是 不使用索引。</p>
</blockquote>
</li>
<li><p>3.查看索引使用情况</p>
<blockquote>
<p>如果索引正在工作，Handler_read_key的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。  Handler_read_rnd_next的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。<br>语法：  mysql&gt; show status like ‘Handler_read%’; </p>
</blockquote>
</li>
</ul>
<h3 id="两个简单实用的优化方法"><a href="#两个简单实用的优化方法" class="headerlink" title="两个简单实用的优化方法"></a>两个简单实用的优化方法</h3><ul>
<li><p>1.定期分析表</p>
<blockquote>
<p>ANALYZE TABLE 语法：<br><code>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code><br>本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM, BDB和InnoDB表有作用。对于MyISAM表，本语句与使用myisamchk -a相当。<br>CHECK TABLE 语法：<br><code>CHECK TABLE tbl_name [, tbl_name] ... [option] ...   option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</code><br>检查一个或多个表是否有错误。CHECK TABLE对MyISAM和InnoDB表有作用。对于MyISAM表，关键字统计数据被更新。  CHECK TABLE也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。<br>CHECKSUM TABLE 语法：<br><code>CHECKSUM TABLE tbl_name [, tbl_name] ... [ QUICK | EXTENDED ]</code><br>报告一个表校验和。</p>
</blockquote>
</li>
<li><p>2.使用optimize table</p>
<blockquote>
<p>OPTIMIZE TABLE  语法：<br><code>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code><br>如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表（含有VARCHAR, BLOB或TEXT列的表）进行了很多更改，则应使用OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的INSERT操作会重新使用旧的记录位置。您可以使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的碎片。  OPTIMIZE TABLE只对MyISAM, BDB和InnoDB表起作用。</p>
</blockquote>
</li>
</ul>
<h3 id="常用SQL的优化"><a href="#常用SQL的优化" class="headerlink" title="常用SQL的优化"></a>常用SQL的优化</h3><ul>
<li><p>1.大批量插入数据</p>
<blockquote>
<p>1). 对于Myisam类型的表，可以通过以下方式快速的导入大量的数据。<br><code>ALTER TABLE tblname DISABLE KEYS;
loading the data  
ALTER TABLE tblname ENABLE KEYS;</code><br>这两个命令用来打开或者关闭Myisam表非唯一索引的更新。在导入大量的数据到一个非空的Myisam表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的Myisam表，默认就是先导入数据然后才创建索引的，所以不用进行设置。<br>2). 而对于Innodb类型的表，这种方式并不能提高导入数据的效率。对于Innodb类型的表，我们有 以下几种方式可以提高导入的效率：<br>a. 因为Innodb类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果Innodb表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。<br>b. 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。<br>c. 如果应用使用自动提交的方式，建议在导入前执行SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p>
</blockquote>
</li>
<li><p>2.优化insert语句</p>
<blockquote>
<p>1). 如果你同时从同一客户插入很多行，使用多个值表的INSERT语句。这比使用分开INSERT语句快 (在一些情况中几倍)。<br><code>Insert into test values(1,2),(1,3),(1,4)„</code><br>2). 如果你从不同客户插入很多行，能通过使用INSERT DELAYED语句得到更高的速度。Delayed的含 义是让insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘；这比每条语句分别插入要快的多；LOW_PRIORITY刚好相反，在所有其他用户对表的读写完后才进行插入；<br>3). 将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）；<br>4). 如果进行批量插入，可以增加bulk_insert_buffer_size变量值的方法来提高速度，但是，这只 能对myisam表使用；<br>5). 当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT语句快20 倍；<br>6). 根据应用情况使用replace语句代替insert；<br>7). 根据应用情况使用ignore关键字忽略重复记录。</p>
</blockquote>
</li>
<li><p>3.优化group by语句</p>
<blockquote>
<p>默认情况下，MySQL排序所有GROUP BY col1，col2，….。查询的方法如同在查询中指定ORDER BY  col1，col2，…。如果显式包括一个包含相同的列的ORDER BY子句，MySQL可以毫不减速地对它进行优化，尽管仍然进行排序。  如果查询包括GROUP BY但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。<br>例如：<code>INSERT INTO foo  SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;</code></p>
</blockquote>
</li>
<li><p>4.优化order by语句</p>
<blockquote>
<p>在某些情况中，MySQL可以使用一个索引来满足ORDER BY子句，而不需要额外的排序。where条件和order by使用相同的索引，并且order by的顺序和索引顺序相同，并且order by的字段都是升序或者都是降序。<br>例如：下列sql可以使用索引。<br><code>SELECT * FROM t1 ORDER BY key_part1,key_part2,...   
SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;
SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</code><br>但是以下情况不使用索引：<br><code>SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC；</code><br>–order by的字段混合ASC和DESC<br><code>SELECT * FROM t1 WHERE key2=constant ORDER BY key1；</code><br>–用于查询行的关键字与ORDER BY中所使用的不相同<br><code>SELECT * FROM t1 ORDER BY key1, key2；</code><br>–对不同的关键字使用ORDER BY：</p>
</blockquote>
</li>
<li><p>5.优化join语句</p>
<blockquote>
<p>Mysql4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN).. 替代。  假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成:<br><code>SELECT * FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )</code><br>如果使用连接(JOIN).. 来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下:<br><code>SELECT * FROM customerinfo   LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID  WHERE salesinfo.CustomerID IS NULL</code><br>连接(JOIN).. 之所以更有效率一些，是因为 MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p>
</blockquote>
</li>
<li><p>6.mysql如何优化or条件<br>   对于or子句，如果要利用索引，则or之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</p>
</li>
<li><p>7查询优先还是更新（insert、update、delete）优先</p>
<blockquote>
<p>MySQL还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。  我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。  下面我们提到的改变调度策略的方法主要是针对Myisam存储引擎的，对于Innodb存储引擎，语句的执行是由获得行锁的顺序决定的。  MySQL的默认的调度策略可用总结如下：<br>1). 写入操作优先于读取操作。<br>2). 对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。<br>3). 对某张数据表的多个读取操作可以同时地进行。 MySQL提供了几个语句调节符，允许你修改它的调度策略：<br>a. LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE。<br>b. HIGH_PRIORITY关键字应用于SELECT和INSERT语句。<br>c. DELAYED关键字应用于INSERT和REPLACE语句。<br>如果写入操作是一个LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在LOW_PRIORITY写入操作永远被阻塞的情况。  SELECT查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的SELECT在正常的SELECT语句之前执行，因为这些语句会被写入操作阻塞。  如果你希望所有支持LOW_PRIORITY选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates选项来启动服务器。通过使用INSERT HIGH_PRIORITY来把INSERT语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。</p>
</blockquote>
</li>
<li><p>8.使用SQL提示<br><code>SELECT SQL_BUFFER_RESULTS ...</code></p>
<blockquote>
<p>将强制MySQL生成一个临时结果集。只要所有临时结果集生成后，所有表上的锁定均被释放。这能在遇到表锁定问题时或要花很长时间将结果传给客户端时有所帮助。    当处理一个会让客户端耗费点时间才能处理的大结果集时，可以考虑使用SQL_BUFFER_RESULT 提示字。这样可以告诉MySQL将结果集保存在一个临时表中，这样可以尽早的释放各种锁。<br><code>USE INDEX</code><br>在你查询语句中表名的后面，添加USE INDEX 来提供你希望MySQ去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。<br><code>Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ...</code><br><code>IGNORE INDEX</code><br>如果你只是单纯的想让MySQL忽略一个或者多个索引，可以使用IGNORE INDEX作为Hint。<br><code>Eg:SELECT * FROM mytale IGNORE INDEX (priority) ...</code><br><code>FORCE INDEX</code><br>为强制MySQL使用一个特定的索引，可在查询中使用FORCE INDEX作为Hint。<br><code>Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ...</code></p>
</blockquote>
</li>
</ul>
<h3 id="其他优化措施"><a href="#其他优化措施" class="headerlink" title="其他优化措施"></a>其他优化措施</h3><ul>
<li>使用持久的连接数据库以避免连接开销。</li>
<li>经常检查所有查询确实使用了必要的索引。  </li>
<li>避免在频繁更新的表上执行复杂的SELECT查询，以避免与锁定表有关的由于读、写冲突发生的问题。</li>
<li>对于没有删除的行操作的MyISAM表，插入操作和查询操作可以并行进行，因为没有删除操作的表查 询期间不会阻塞插入操作．对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。  </li>
<li>充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL需 要做的语法分析从而提高插入速度。</li>
<li>对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。  </li>
<li>通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份 期间对应用的影响，可以在复制服务器上执行备份操作。  </li>
<li>表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的影响，推荐通 过应用来实现字段的自增长。 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SQL优化&quot;&gt;&lt;a href=&quot;#SQL优化&quot; class=&quot;headerlink&quot; title=&quot;SQL优化&quot;&gt;&lt;/a&gt;SQL优化&lt;/h2&gt;&lt;h3 id=&quot;优化SQL的一般步骤&quot;&gt;&lt;a href=&quot;#优化SQL的一般步骤&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="MySQL" scheme="http://www.iooeo.com/categories/MySQL/"/>
    
    
      <category term="Linux" scheme="http://www.iooeo.com/tags/Linux/"/>
    
      <category term="MySQL" scheme="http://www.iooeo.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
