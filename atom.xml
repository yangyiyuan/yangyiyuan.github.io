<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ewan&#39;s Blog</title>
  <subtitle>Ewan&#39;s Blog | 杨依园技术博客 | 专注于PHP，涉及MySQL，Linux，Web，Nginx，Apache，Phalcon，Laravel，Redis，PostgreSql，Composer，Beanstalkd，Swoole</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iooeo.com/"/>
  <updated>2017-08-31T00:51:01.000Z</updated>
  <id>http://www.iooeo.com/</id>
  
  <author>
    <name>Ewan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Laravel 5.5 LTS 正式发布，Whoops Package 回归</title>
    <link href="http://www.iooeo.com/2017/08/31/Laravel-5-5-LTS-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8CWhoops-Package-%E5%9B%9E%E5%BD%92/"/>
    <id>http://www.iooeo.com/2017/08/31/Laravel-5-5-LTS-正式发布，Whoops-Package-回归/</id>
    <published>2017-08-31T00:41:37.000Z</published>
    <updated>2017-08-31T00:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ogpq2zwg5.bkt.clouddn.com/235826_LPCu_2896879.png" alt="Laravel 5.5"><br>Laravel 5.5 已发布，这是最新的长期支持版本（LTS），包含多项改进。<br>发行说明：<a href="https://laravel-news.com/laravel-5-5" target="_blank" rel="external">https://laravel-news.com/laravel-5-5</a></p>
<h2 id="部分亮点"><a href="#部分亮点" class="headerlink" title="部分亮点"></a>部分亮点</h2><h3 id="Whoops-Package-回归"><a href="#Whoops-Package-回归" class="headerlink" title="Whoops Package 回归"></a>Whoops Package 回归</h3><p>filp / whoops package 曾经出现在 V4 系列，用于在调试时提供优雅的堆栈跟踪，是一个错误处理框架。Laravel 5.5 版本 Whoops Package 正式回归。<br><img src="http://ogpq2zwg5.bkt.clouddn.com/000334_DCvs_2896879.png" alt="Whoops Package"></p>
<h3 id="Exception-Rendering"><a href="#Exception-Rendering" class="headerlink" title="Exception Rendering"></a>Exception Rendering</h3><p>5.5 无需额外的逻辑，可直接抛出异常，并进行响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">// throw new TerribleSongException($song) in a controller...</div><div class="line"></div><div class="line">namespace App\Exceptions;</div><div class="line"></div><div class="line">use App\Song;</div><div class="line"></div><div class="line">class TerribleSongException extends \Exception</div><div class="line">&#123;</div><div class="line">    /**</div><div class="line">     * @var \App\Song</div><div class="line">     */</div><div class="line">    protected $song;</div><div class="line"></div><div class="line">    public function __construct(Song $song)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;song = $song;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param \Illuminate\Http\Request $request</div><div class="line">     */</div><div class="line">    public function render($request)</div><div class="line">    &#123;</div><div class="line">        return response(&quot;The song &apos;&#123;$this-&gt;song-&gt;title&#125;&apos; by &apos;&#123;$this-&gt;song-&gt;artist&#125;&apos; is terrible.&quot;);    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义验证规则对象"><a href="#自定义验证规则对象" class="headerlink" title="自定义验证规则对象"></a>自定义验证规则对象</h3><p>Laravel 5.5 带来新的自定义验证规则对象，以此作为 Validator::extend 的替代方法。新规则的逻辑更一目了然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">namespace App\Rules;</div><div class="line"></div><div class="line">use Illuminate\Contracts\Validation\Rule;</div><div class="line"></div><div class="line">class CowbellValidationRule implements Rule</div><div class="line">&#123;</div><div class="line">    public function passes($attribute, $value)</div><div class="line">    &#123;</div><div class="line">        return $value &gt; 10;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function message()</div><div class="line">    &#123;</div><div class="line">        return &apos;:attribute needs more cowbell!&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用新规则后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">request()-&gt;validate([</div><div class="line">    &apos;cowbells&apos; =&gt; [new CowbellValidationRule],</div><div class="line">    &apos;more_cowbells&apos; =&gt; [function ($attribute, $value, $fail) &#123;</div><div class="line">        if ($value &lt;= 10) &#123;</div><div class="line">            $fail(&apos;:attribute needs more cowbell!&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;]</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<h3 id="Blade-if-指令"><a href="#Blade-if-指令" class="headerlink" title="Blade::if () 指令"></a>Blade::if () 指令</h3><p>新的指令包括 @auth and @guest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@auth</div><div class="line">    Welcome &#123;&#123; user()-&gt;name &#125;&#125;!</div><div class="line">@endauth</div><div class="line"></div><div class="line">@guest</div><div class="line">    Welcome Guest!</div><div class="line">@endguest</div></pre></td></tr></table></figure></p>
<h3 id="新的迁移命令：Fresh"><a href="#新的迁移命令：Fresh" class="headerlink" title="新的迁移命令：Fresh"></a>新的迁移命令：Fresh</h3><p>新的 migrate:fresh 命令会直接删除所有的表，然后运行迁移。通常在开发过程中，你也只需删除表，获取新数据库，和运行迁移。</p>
<hr>
<p>更多细节请直接查看<a href="https://laravel-news.com/laravel-5-5" target="_blank" rel="external">发行说明</a><br>Laravel 5.5 更多链接：</p>
<ul>
<li>升级文档：<a href="https://laravel.com/docs/5.5" target="_blank" rel="external">https://laravel.com/docs/5.5</a></li>
<li>版本说明 <a href="https://laravel.com/docs/5.5/releases" target="_blank" rel="external">https://laravel.com/docs/5.5/releases</a></li>
<li>升级指南：<a href="https://laravel.com/docs/5.5/upgrade" target="_blank" rel="external">https://laravel.com/docs/5.5/upgrade</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ogpq2zwg5.bkt.clouddn.com/235826_LPCu_2896879.png&quot; alt=&quot;Laravel 5.5&quot;&gt;&lt;br&gt;Laravel 5.5 已发布，这是最新的长期支持版本（LTS），包含多项改进。&lt;br&gt;发行说
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Laravel" scheme="http://www.iooeo.com/categories/PHP/Laravel/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://www.iooeo.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>CRC16 For PHP</title>
    <link href="http://www.iooeo.com/2017/08/13/CRC16-For-PHP/"/>
    <id>http://www.iooeo.com/2017/08/13/CRC16-For-PHP/</id>
    <published>2017-08-13T01:06:54.000Z</published>
    <updated>2017-08-13T02:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着物联网技术的发展和普及，作为最好的语言 PHP 也难免会遇上与硬件设备数据对接的情况。在数据通信领域中有一种查错校验码，CRC。<br>在 PHP 官网上搜索了一下，只提供 CRC32 的相关的函数，关于 CRC16 我自己封装了一个方法用于校验计算。然后我将代码整理了一番，已发布到 GitHub，有需要的同学可以去看下，或许我们可以共同维护他。项目地址<a href="https://github.com/yangyiyuan/CRC16ForPHP" target="_blank" rel="external">CRC16ForPHP</a><br><a id="more"></a><br>具体实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function crc16Modbus($str)</div><div class="line">&#123;</div><div class="line">    $data = pack(&apos;H*&apos;, $str);</div><div class="line">    $crc = 0xFFFF;</div><div class="line">    for ($i = 0; $i &lt; strlen($data); $i++) &#123;</div><div class="line">        $crc ^= ord($data[$i]);</div><div class="line">        for ($j = 8; $j != 0; $j--) &#123;</div><div class="line">            if (($crc &amp; 0x0001) != 0) &#123;</div><div class="line">                $crc &gt;&gt;= 1;</div><div class="line">                $crc ^= 0xA001;</div><div class="line">            &#125; else $crc &gt;&gt;= 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sprintf(&apos;%04X&apos;, $crc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo crc16(&apos;010301180001&apos;).PHP_EOL;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着物联网技术的发展和普及，作为最好的语言 PHP 也难免会遇上与硬件设备数据对接的情况。在数据通信领域中有一种查错校验码，CRC。&lt;br&gt;在 PHP 官网上搜索了一下，只提供 CRC32 的相关的函数，关于 CRC16 我自己封装了一个方法用于校验计算。然后我将代码整理了一番，已发布到 GitHub，有需要的同学可以去看下，或许我们可以共同维护他。项目地址&lt;a href=&quot;https://github.com/yangyiyuan/CRC16ForPHP&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CRC16ForPHP&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="CRC16" scheme="http://www.iooeo.com/tags/CRC16/"/>
    
  </entry>
  
  <entry>
    <title>swoole TCP服务器心跳维持方案</title>
    <link href="http://www.iooeo.com/2017/08/04/swoole-TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%83%E8%B7%B3%E7%BB%B4%E6%8C%81%E6%96%B9%E6%A1%88/"/>
    <id>http://www.iooeo.com/2017/08/04/swoole-TCP服务器心跳维持方案/</id>
    <published>2017-08-04T06:40:30.000Z</published>
    <updated>2017-08-04T07:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>正常情况下客户端中断TCP连接时，会发送一个FIN包，进行4次断开握手来通知服务器。但一些异常情况下，如客户端突然断电断网或者网络异常，服务器可能无法得知客户端已断开连接。<br>尤其是移动网络，TCP连接非常不稳定，所以需要一套机制来保证服务器和客户端之间连接的有效性。<br><a id="more"></a><br>Swoole扩展本身内置了这种机制，开发者只需要配置一个参数即可启用。Swoole在每次收到客户端数据会记录一个时间戳，当客户端在一定时间内未向服务器端发送数据，那服务器会自动切断连接。<br>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set(array(</div><div class="line">    &apos;heartbeat_check_interval&apos; =&gt; 60,</div><div class="line">    &apos;heartbeat_idle_time&apos; =&gt; 300,</div><div class="line">));</div></pre></td></tr></table></figure></p>
<p>上面的设置就是每60秒侦测一次心跳，一个TCP连接如果在300秒内未向服务器端发送数据，将会被切断。当然我这个长连接，这样做是为了回收进程。</p>
<p>高级用法：<br>使用<code>swoole_server::heartbeat()</code>函数手工检测心跳是否到期。此函数会返回闲置时间超过<code>heartbeat_idle_time</code>的所有TCP连接。程序中可以将这些连接做一些操作，如发送数据或关闭连接。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正常情况下客户端中断TCP连接时，会发送一个FIN包，进行4次断开握手来通知服务器。但一些异常情况下，如客户端突然断电断网或者网络异常，服务器可能无法得知客户端已断开连接。&lt;br&gt;尤其是移动网络，TCP连接非常不稳定，所以需要一套机制来保证服务器和客户端之间连接的有效性。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole 粘包 EOF 包头+包尾</title>
    <link href="http://www.iooeo.com/2017/08/03/swoole-%E7%B2%98%E5%8C%85-EOF/"/>
    <id>http://www.iooeo.com/2017/08/03/swoole-粘包-EOF/</id>
    <published>2017-08-03T07:20:25.000Z</published>
    <updated>2017-08-03T09:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在跟硬件开发的小伙伴测试的时候发现了一个非常有趣的问题，即Client 每次请求，Server 端我返回相同信息，但是有时候会出现两次或多次返回的数据堆叠到一起的现象。开始我还以为我代码写的有问题，仔细看了一下代码没问题啊，终究还是要相信科学。<br><a id="more"></a><br><img src="http://ogpq2zwg5.bkt.clouddn.com/TCP%20%E7%B2%98%E5%8C%85.png" alt="tcp 粘包"><br>经我多方查证，原来我们的问题是 TCP 粘包问题，下面科普一下。</p>
<h2 id="TCP-粘包"><a href="#TCP-粘包" class="headerlink" title="TCP 粘包"></a>TCP 粘包</h2><h3 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h3><p>在讨论 TCP 粘包的问题前，我们先理解一下长连接和短连接。<br><code>长连接</code></p>
<blockquote>
<p>Client 与 Server 先建立通讯连接，连接建立后不断开， 然后再进行数据发送和接收。</p>
</blockquote>
<p><code>短连接</code></p>
<blockquote>
<p>Client 与 Server 每进行一次数据收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个Client连接一个Server。</p>
</blockquote>
<h3 id="什么是-TCP-粘包"><a href="#什么是-TCP-粘包" class="headerlink" title="什么是 TCP 粘包"></a>什么是 TCP 粘包</h3><p>TCP 粘包是指<em>发送方发送的若干包数据</em> 到 <em>接收方接收时粘成一包</em>，从接收缓冲区看，<em>后一包数据的头紧接着前一包数据的尾</em>。</p>
<h3 id="TCP-出现粘包的原因"><a href="#TCP-出现粘包的原因" class="headerlink" title="TCP 出现粘包的原因"></a>TCP 出现粘包的原因</h3><ul>
<li>发送方：发送方需要等缓冲区满才发送出去，造成粘包</li>
<li>接收方：接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>
<h3 id="什么时候需要处理粘包"><a href="#什么时候需要处理粘包" class="headerlink" title="什么时候需要处理粘包"></a>什么时候需要处理粘包</h3><p><code>不处理：</code></p>
<blockquote>
<ul>
<li>短连接，每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题。</li>
<li>如果发送数据无结构，如文件传输被分成多个分组发送，也不用考虑粘包。</li>
</ul>
</blockquote>
<p><code>需处理：</code></p>
<blockquote>
<p>双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：<code>good morning</code>、<code>good evening</code>，如果发送方连续发了两个包出去，接收方可能就回收到<code>`good morninggood evening</code>很明显不是我们想要，需要处理。</p>
</blockquote>
<h2 id="Swoole-处理粘包"><a href="#Swoole-处理粘包" class="headerlink" title="Swoole 处理粘包"></a>Swoole 处理粘包</h2><p>既然了解了为什么会出现粘包现象和什么时候需要处理粘包，那下边就是想办法解决了。很显然我的需求得处理，很幸运 Swoole 已经提供了怎么解决粘包问题的方案。</p>
<h3 id="EOF-结束协议"><a href="#EOF-结束协议" class="headerlink" title="EOF 结束协议"></a>EOF 结束协议</h3><p>之前我在翻阅 Swoole 文档过程中，在看到 Server 配置选项的时候，看到过<code>open_eof_check</code>、<code>open_eof_split</code>、<code>package_eof</code>…配置的时候，搂了两眼，感觉很深奥的样子，就一眼带过了。现在才知道它们是用来干嘛的。<br>EOF，即指每一个数据包的结尾加一个EOF标记，表示数据包的结束，但是如果你的数据本身含有EOF标记，那就会造成收到的数据包不完整，所以开启EOF支持后，应避免数据中含有EOF标记。<br>Server 的 <code>open_eof_check</code>设置为<code>true</code>时，打开EOF检测，此选项将检测客户端连接发来的数据，当数据包结尾是指定的EOF字符串时才会投递给Worker进程。否则会一直拼接数据包，直到超过缓存区或者超时才会中止。当出错时swoole底层会认为是恶意连接，丢弃数据并强制关闭连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">	&apos;open_eof_check&apos; =&gt; true, //打开EOF检测</div><div class="line">	&apos;package_eof&apos; =&gt; &quot;\r\n&quot;, //设置EOF</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>常见的Memcache/SMTP/POP等协议都是以<code>\r\n</code>结束的，就可以使用以上配置。开启后可以保证Worker进程一次性总是收到一个或者多个完整的数据包。<br>虽然Swoole 已经帮我在服务端做了 EOF 结束协议，但是你不能保证客户端会一次性发过来几条数据，这样会出现一次性接受多个数据包的问题，因为EOF检测不会从数据中间查找eof字符串，所以Worker进程可能会同时收到多个数据包，需要在应用层代码中自行explode(“\r\n”, $data) 来拆分数据包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public function onReceive($serv, $fd, $fromId, $data)</div><div class="line">&#123;</div><div class="line">    $datas = explode(&quot;\r\n&quot;, $data);</div><div class="line">    foreach ($datas as $data)</div><div class="line">    &#123;</div><div class="line">        if(!$data)&#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        echo &quot;Server received data: &#123;$data&#125;&quot; . PHP_EOL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然我们可以自己拆分数据，但是Swoole1.7.15版本增加了<code>open_eof_split</code>，支持从数据中查找EOF，并切分数据，那我们何乐而不为呐?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">	&apos;open_eof_check&apos; =&gt; true, //打开EOF检测</div><div class="line">    &apos;package_eof&apos; =&gt; &quot;\r\n&quot;, //设置EOF</div><div class="line">	&apos;open_eof_split&apos; =&gt; true,</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>配置成上面这样，我们就不用自己在应用层代码中自行 <code>explode()</code>了。</p>
<h3 id="发送长度-固定包头和包尾"><a href="#发送长度-固定包头和包尾" class="headerlink" title="发送长度 固定包头和包尾"></a>发送长度 固定包头和包尾</h3><p>发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。<br>在这种协议下，我们的数据包的组成就是包头+包体。其中包头就是包体长度的二进制形式。比如我们本来想向服务端发送一段数据 “Just a test.” 共12个字符，现在我们要发送的数据就应该是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pack(&apos;N&apos;, strlen(&quot;Just a test.&quot;)) . &quot;Just a test.&quot;</div></pre></td></tr></table></figure></p>
<p><code>pack()</code>函数是将数据打包成二进制字符串，也就是我们的包头部分。<br>这样的话 Server 收到一个数据包（可能是多个完整的数据包）之后，会先解出包头指定的数据长度，然后按照这个长度取出后面的数据，如果一次性收到多个数据包，依次循环，如此就能保证Worker进程可以一次性收到一个完整的数据包。<br>Swoole 为我们提供一下几个配置选项：</p>
<ul>
<li><code>open_length_check</code>：打开包长检测特性</li>
<li><code>package_length_type</code>：长度字段的类型，固定包头中用一个4字节或2字节表示包体长度，文章最后给出详细长度值的类型</li>
<li><code>package_length_offset</code>：从第几个字节开始是长度，比如包头长度为120字节，第10个字节为长度值，这里填入9（从0开始计数）</li>
<li><code>package_body_offset</code>：从第几个字节开始计算长度，比如包头为长度为120字节，第10个字节为长度值，包体长度为1000。如果长度包含包头，这里填入0，如果不包含包头，这里填入120</li>
<li><code>package_max_length</code>：最大允许的包长度。因为在一个请求包完整接收前，需要将所有数据保存在内存中，所以需要做保护。避免内存占用过大。</li>
</ul>
<p>具体配置就写这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">    &apos;open_length_check&apos;     =&gt; true,      // 开启协议解析</div><div class="line">    &apos;package_length_type&apos;   =&gt; &apos;N&apos;,     // 长度字段的类型</div><div class="line">    &apos;package_length_offset&apos; =&gt; 0,       //第几个字节是包长度的值</div><div class="line">    &apos;package_body_offset&apos;   =&gt; 4,       //第几个字节开始计算长度</div><div class="line">    &apos;package_max_length&apos;    =&gt; 81920,  //协议最大长度</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>数据处理部分为这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public function onReceive($serv, $fd, $fromId, $data)</div><div class="line">&#123;</div><div class="line">    $info = unpack(&apos;N&apos;, $data);</div><div class="line">    $len = $info[1];</div><div class="line">    $body = substr($data, - $len);</div><div class="line">    echo &quot;server received data: &#123;$body&#125;\n&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成这些，这种方案就算完成了。</p>
<h4 id="package-length-type-长度值的类型"><a href="#package-length-type-长度值的类型" class="headerlink" title="package_length_type 长度值的类型"></a>package_length_type 长度值的类型</h4><p>长度值的类型，接受一个字符参数，与php的pack函数一致。目前swoole支持10种类型：</p>
<ul>
<li>c：有符号、1字节</li>
<li>C：无符号、1字节</li>
<li>s ：有符号、主机字节序、2字节</li>
<li>S：无符号、主机字节序、2字节</li>
<li>n：无符号、网络字节序、2字节 (常用)</li>
<li>N：无符号、网络字节序、4字节 (常用)</li>
<li>l：有符号、主机字节序、4字节（小写L）</li>
<li>L：无符号、主机字节序、4字节（大写L）</li>
<li>v：无符号、小端字节序、2字节</li>
<li>V：无符号、小端字节序、4字节</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在跟硬件开发的小伙伴测试的时候发现了一个非常有趣的问题，即Client 每次请求，Server 端我返回相同信息，但是有时候会出现两次或多次返回的数据堆叠到一起的现象。开始我还以为我代码写的有问题，仔细看了一下代码没问题啊，终究还是要相信科学。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>lantern 运行时关闭终端</title>
    <link href="http://www.iooeo.com/2017/08/03/lantern-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%85%B3%E9%97%AD%E7%BB%88%E7%AB%AF/"/>
    <id>http://www.iooeo.com/2017/08/03/lantern-运行时关闭终端/</id>
    <published>2017-08-03T03:34:39.000Z</published>
    <updated>2017-08-03T03:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇 Mac 上破解 lantern 的文章<a href="http://www.iooeo.com/2017/07/07/lantern-Mac%E7%89%88%E7%BC%96%E8%AF%91-%E5%85%8D%E8%B4%B9/">lantern Mac版编译 无限流量</a>。小伙伴胖佳说可以运行了，但是有个终端会一直开着，关闭掉以后 lantern 就终止执行了，也就不能翻墙了，今天想到了一个办法。<br><a id="more"></a><br>接着上篇文章继续，Mac上搜索一下lantern_darwin_amd64,双击打开以后，会出现一个终端，上边不停的有各种信息出现，此时我们是可以正常使用的。<br>但是一直开着个终端，有点不爽，首先我们把 lantern 执行终端滚到最上边会看到一下命令：<br><img src="http://ogpq2zwg5.bkt.clouddn.com/lantern%20%E6%89%A7%E8%A1%8C%E7%BB%88%E7%AB%AF.png" alt="lantern 执行终端"><br>其实我们就是想要<code>lantern_darwin_amd64</code>文件路径，然后你的<code>.bash_profile</code>或者<code>.profile</code>中添加以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias lantern=&apos;/Users/yangyiyuan/projects/landeng/lantern/lantern_darwin_amd64 &amp; exit&apos;</div></pre></td></tr></table></figure></p>
<p>将上边的文件路径换成你自己的就可以了，然后终端执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source .bash_profile</div></pre></td></tr></table></figure></p>
<p>这样就可以了，以后我们要启动蓝灯，直接打开终端执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lantern</div></pre></td></tr></table></figure></p>
<p>然后关闭窗口就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇 Mac 上破解 lantern 的文章&lt;a href=&quot;http://www.iooeo.com/2017/07/07/lantern-Mac%E7%89%88%E7%BC%96%E8%AF%91-%E5%85%8D%E8%B4%B9/&quot;&gt;lantern Mac版编译 无限流量&lt;/a&gt;。小伙伴胖佳说可以运行了，但是有个终端会一直开着，关闭掉以后 lantern 就终止执行了，也就不能翻墙了，今天想到了一个办法。&lt;br&gt;
    
    </summary>
    
      <category term="Mac" scheme="http://www.iooeo.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://www.iooeo.com/tags/Mac/"/>
    
      <category term="lantern" scheme="http://www.iooeo.com/tags/lantern/"/>
    
      <category term="VPN" scheme="http://www.iooeo.com/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>swoole 进程守护 日志保存</title>
    <link href="http://www.iooeo.com/2017/08/03/swoole-%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4-%E6%97%A5%E5%BF%97%E4%BF%9D%E5%AD%98/"/>
    <id>http://www.iooeo.com/2017/08/03/swoole-进程守护-日志保存/</id>
    <published>2017-08-03T02:56:59.000Z</published>
    <updated>2017-08-03T06:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>前边我已经学会了 Swoole 的 Server 和 Client，也用他们做了不同压力测试、并发测试等等。但是终究离应用到实际项目还差一步，因为没有开启进程守护，只要我的终端关掉了，程序也就中断执行了。<br><a id="more"></a><br>其实在写这篇之前，不依赖 Swoole 为我们提供的方法，如果 Linux 算熟悉的话，自己也能想到办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ php server.php &gt; server_log.log &amp;</div></pre></td></tr></table></figure></p>
<h2 id="进程守护-日志保存"><a href="#进程守护-日志保存" class="headerlink" title="进程守护 日志保存"></a>进程守护 日志保存</h2><p>但是既然 Swoole 给提供了，那我们就开看一下怎么用的吧。<br>将<code>daemonize</code>设置为<code>true</code>时，程序将转入后台作为守护进程运行。长时间运行的服务器端程序必须启用此项。如果不启用守护进程，当ssh终端退出后，程序将被终止运行。</p>
<ul>
<li>启用守护进程后，标准输入和输出会被重定向到 log_file</li>
<li>如果未设置log_file，将重定向到 /dev/null，所有打印屏幕的信息都会被丢弃</li>
</ul>
<p>代码实现，只要将我们之前讲过的 server 配置添加<code>daemonize</code> 和<code>log_file</code>即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">    &apos;worker_num&apos; =&gt; 1,</div><div class="line">    &apos;daemonize&apos; =&gt; true,</div><div class="line">    &apos;log_file&apos; =&gt; __DIR__ . &apos;/server.log&apos;</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>设置好以后，确认是够已经成功进行进程守护，可使用命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep server.php</div><div class="line">yangyiyuan       92904   0.0  0.0  2491660   2280   ??  S    10:54上午   0:00.00 php server.php</div><div class="line">yangyiyuan       92861   0.0  0.0  2491052   1596   ??  S    10:54上午   0:00.00 php server.php</div><div class="line">yangyiyuan       92857   0.0  0.0  2492280   1860   ??  Ss   10:54上午   0:00.27 php server.php</div><div class="line">yangyiyuan       98783   0.0  0.0  2423392    600 s001  R+    1:52下午   0:00.00 grep server.php</div></pre></td></tr></table></figure></p>
<p>此时执行我们的客户端文件，将会有日志输出到<code>server.log</code>文件中。</p>
<h2 id="重启进程"><a href="#重启进程" class="headerlink" title="重启进程"></a>重启进程</h2><p>一台繁忙的后端服务器随时都在处理请求，如果管理员通过kill进程方式来终止/重启服务器程序，可能导致刚好代码执行到一半终止。<br>这种情况下会产生数据的不一致。如交易系统中，支付逻辑的下一段是发货，假设在支付逻辑之后进程被终止了。会导致用户支付了货币，但并没有发货，后果非常严重。<br>Swoole提供了柔性终止/重启的机制，管理员只需要向<code>SwooleServer</code>发送特定的信号，Server的worker进程可以安全的结束。</p>
<ul>
<li><code>SIGTERM</code>: 向主进程/管理进程发送此信号服务器将安全终止,在PHP代码中可以调用<code>$serv-&gt;shutdown()</code>完成此操作</li>
<li><code>SIGUSR1</code>: 向主进程/管理进程发送<code>SIGUSR1</code>信号，将平稳地<code>restart</code>所有<code>worker</code>进程,在PHP代码中可以调用<code>$serv-&gt;reload()</code>完成此操作</li>
<li>swoole的<code>reload</code>有保护机制，当一次reload正在进行时，收到新的重启信号会丢弃</li>
<li>如果设置了user/group，Worker进程可能没有权限向master进程发送信息，这种情况下必须使用root账户，在shell中执行kill指令进行重启</li>
<li><code>reload</code>指令对<code>addProcess</code>添加的用户进程无效</li>
</ul>
<p>终端重启所有worker进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kill -USR1 主进程PID</div></pre></td></tr></table></figure></p>
<p>终端仅重启task进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kill -USR2 主进程PID</div></pre></td></tr></table></figure></p>
<p>注意事项：</p>
<blockquote>
<p>平滑重启只对onWorkerStart或onReceive等在Worker进程中include/require的PHP文件有效，Server启动前就已经include/require的PHP文件，不能通过平滑重启重新加载<br>对于Server的配置即$serv-&gt;set()中传入的参数设置，必须关闭/重启整个Server才可以重新加载<br>Server可以监听一个内网端口，然后可以接收远程的控制命令，去重启所有worker</p>
</blockquote>
<p>Reload有效范围：<br>Reload操作只能重新载入Worker进程启动后加载的PHP文件，建议使用get_included_files函数来列出哪些文件是在WorkerStart之前就加载的PHP文件，在此列表中的PHP文件，即使进行了reload操作也无法重新载入。比如要关闭服务器重新启动才能生效。<br>WorkerStart之前就加载的PHP文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;WorkerStart&apos;, function($serv, $workerId) &#123;</div><div class="line">    var_dump(get_included_files()); //此数组中的文件表示进程启动前就加载了，所以无法reload</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>重启无效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">require_once &apos;./Test.php&apos;;</div><div class="line">class Server&#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重启有效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;WorkerStart&apos;, function($serv, $workerId) &#123;</div><div class="line">        require_once(&quot;Test.php&quot;); //此处 Test.php重启有效</div><div class="line">        $this-&gt;_test = new Test;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前边我已经学会了 Swoole 的 Server 和 Client，也用他们做了不同压力测试、并发测试等等。但是终究离应用到实际项目还差一步，因为没有开启进程守护，只要我的终端关掉了，程序也就中断执行了。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole Worker进程</title>
    <link href="http://www.iooeo.com/2017/08/01/swoole-Worker%E8%BF%9B%E7%A8%8B/"/>
    <id>http://www.iooeo.com/2017/08/01/swoole-Worker进程/</id>
    <published>2017-08-01T07:46:55.000Z</published>
    <updated>2017-08-01T08:16:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在文章之前先看两张图片，试着去理解一下Swoole Server运行流程和进程/线程结构.<br><a id="more"></a></p>
<h2 id="运行流程图"><a href="#运行流程图" class="headerlink" title="运行流程图"></a>运行流程图</h2><p><img src="http://ogpq2zwg5.bkt.clouddn.com/swoole.jpg" alt="运行流程图"></p>
<h2 id="进程-线程结构图"><a href="#进程-线程结构图" class="headerlink" title="进程/线程结构图"></a>进程/线程结构图</h2><p><img src="http://ogpq2zwg5.bkt.clouddn.com/process.jpg" alt="进程/线程结构图"><br>为了能更好的理解Swoole Server 的运行流程，下面我们创一个简单的实例<em>server-process.php</em>配合上面的图片进行讲解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$serv = new swoole_server(&apos;127.0.0.1&apos;, 9501);</div><div class="line">$serv-&gt;set([</div><div class="line">    &apos;worker_num&apos; =&gt; 2,</div><div class="line">    &apos;task_worker_num&apos; =&gt; 1,</div><div class="line">]);</div><div class="line">$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123;</div><div class="line">&#125;);</div><div class="line">$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123;</div><div class="line">&#125;);</div><div class="line">$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123;</div><div class="line">&#125;);</div><div class="line">$serv-&gt;on(&apos;Task&apos;, function ($serv, $taskId, $fromId, $data) &#123;</div><div class="line">&#125;);</div><div class="line">$serv-&gt;on(&apos;Finish&apos;, function ($serv, $taskId, $data) &#123;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$serv-&gt;start();</div></pre></td></tr></table></figure></p>
<p>然后执行 ps 命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep server-process</div><div class="line">root     21843  xxx... php server-process.php</div><div class="line">root     21844  xxx... php server-process.php</div><div class="line">root     21846  xxx... php server-process.php</div><div class="line">root     21847  xxx... php server-process.php</div><div class="line">root     21848  xxx... php server-process.php</div><div class="line">root     21854  xxx... grep --color=auto server-process</div></pre></td></tr></table></figure></p>
<p>排除掉 grep 那条，一共有5条。<br>相比<em>Master-Worker</em>模式，swoole 的进程模型可以用<em>Master-Manager-Worker</em>来形容。即在<em>Master-Worker</em>的基础上又增加了一层Manager进程。</p>
<ul>
<li>1个 Master 进程</li>
<li>1个 Manager 进程    </li>
<li>2个 Worker 进程</li>
<li>1个 Task 进程</li>
</ul>
<p>Swoole 是一个多进程模式的框架（可以类比Nginx的进程模型），当启动一个Swoole应用时，一共会创建2 + n + m个进程，其中n为 Worker 进程数，m为TaskWorker进程数，2为一个 Master 进程和一个 Manager 进程，它们之间的关系如下图所示。<br><img src="http://ogpq2zwg5.bkt.clouddn.com/structure.png" alt="swoole 进程模型"><br>其中，Master进程为主进程，该进程会创建Manager进程、Reactor线程等工作进/线程。</p>
<ul>
<li>Reactor线程实际运行epoll实例，用于accept客户端连接以及接收客户端数据；</li>
<li>Manager进程为管理进程，该进程的作用是创建、管理所有的Worker进程和TaskWorker进程。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在文章之前先看两张图片，试着去理解一下Swoole Server运行流程和进程/线程结构.&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole Task Worker 篇</title>
    <link href="http://www.iooeo.com/2017/08/01/swoole-Task-Worker-%E7%AF%87/"/>
    <id>http://www.iooeo.com/2017/08/01/swoole-Task-Worker-篇/</id>
    <published>2017-08-01T06:51:52.000Z</published>
    <updated>2017-08-01T07:39:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>swoole_server-&gt;task</code>投递一个异步任务到 task_worker 池中。此函数是非阻塞的，执行完毕会立即返回。Worker 进程可以继续处理新的请求。使用Task功能，必须先设置 <em>task_worker_num</em>，并且必须设置 Server 的 <em>onTask</em> 和 <em>onFinish </em>事件回调函数。<br><a id="more"></a><br>注意事项：</p>
<ul>
<li>使用 task 必须为 Server 设置 <em>onTask</em> 和 <em>onFinish</em> 回调，否则 <code>swoole_server-&gt;start</code> 会失败</li>
<li>task 操作的次数必须小于 <em>onTask</em> 处理速度，如果投递容量超过处理能力，task 会塞满缓存区，导致 worker 进程发生阻塞。worker 进程将无法接收新的请求</li>
<li>使用 <em>addProcess</em> 添加的用户进程中无法使用 task 投递任务，请使用 <em>sendMessage</em> 接口与 Task 工作进程通信</li>
</ul>
<h2 id="Task-实例"><a href="#Task-实例" class="headerlink" title="Task 实例"></a>Task 实例</h2><h3 id="创建-Server"><a href="#创建-Server" class="headerlink" title="创建 Server"></a>创建 Server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501);</div></pre></td></tr></table></figure>
<h3 id="设置task-worker-num"><a href="#设置task-worker-num" class="headerlink" title="设置task_worker_num"></a>设置<em>task_worker_num</em></h3><p>设置<em>task_worker_num</em>是我们使用 task 中不可缺少的一点哦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">	&apos;worker_num&apos; =&gt; 2,</div><div class="line">	&apos;task_worker_num&apos; =&gt; 1,</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<h3 id="客户端链接回调"><a href="#客户端链接回调" class="headerlink" title="客户端链接回调"></a>客户端链接回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;new client connected.\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="接受客户端数据，使用-task"><a href="#接受客户端数据，使用-task" class="headerlink" title="接受客户端数据，使用 task"></a>接受客户端数据，使用 task</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123;</div><div class="line">    echo &quot;worker received data: &#123;$data&#125;\n&quot;;</div><div class="line">    // 投递一个任务到task进程中</div><div class="line">    $serv-&gt;task($data);</div><div class="line">    // 通知客户端server收到数据了</div><div class="line">    $serv-&gt;send($fd, &apos;This is a message from server.&apos;);</div><div class="line">    // 为了校验task是否是异步的，这里和task进程内都输出内容，看看谁先输出</div><div class="line">    echo &quot;worker continue run.\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="设置-Server-的-onTask-和-onFinish-事件回调函数"><a href="#设置-Server-的-onTask-和-onFinish-事件回调函数" class="headerlink" title="设置 Server 的 onTask 和 onFinish 事件回调函数"></a>设置 Server 的 <em>onTask</em> 和 <em>onFinish </em>事件回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * $serv swoole_server</div><div class="line"> * $taskId 投递的任务id,因为task进程是由worker进程发起，所以多worker多task下，该值可能会相同</div><div class="line"> * $fromId 来自那个worker进程的id</div><div class="line"> * $data 要投递的任务数据</div><div class="line"> */</div><div class="line">$serv-&gt;on(&apos;Task&apos;, function ($serv, $taskId, $fromId, $data) &#123;</div><div class="line">    echo &quot;task start. --- from worker id: &#123;$fromId&#125;.\n&quot;;</div><div class="line">    for ($i=0; $i &lt; 5; $i++) &#123; </div><div class="line">        sleep(1);</div><div class="line">        echo &quot;task runing. --- &#123;$i&#125;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    return &quot;task end&quot;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 只有在task进程中调用了finish方法或者return了结果，才会触发finish</div><div class="line"> */</div><div class="line">$serv-&gt;on(&apos;Finish&apos;, function ($serv, $taskId, $data) &#123;</div><div class="line">    echo &quot;finish received data &apos;&#123;$data&#125;&apos;\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;Client &#123;$fd&#125; close connection\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;start();</div></pre></td></tr></table></figure>
<p>客户端还是用我们上一篇<a href="http://www.iooeo.com/2017/08/01/swoole-%E5%88%9D%E8%AF%86-%E7%AE%80%E5%8D%95%E7%9A%84-Server-Client/">简单的Server Client</a>中的client.php。<br>执行查看 client 结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ php client.php </div><div class="line">This is a message from server.</div></pre></td></tr></table></figure></p>
<p>执行查看 server 结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ php index.php </div><div class="line">new client connected.</div><div class="line">Get Message From Client 1:hello server.</div><div class="line">worker continue run.</div><div class="line">task start. --- from worker id: 3.</div><div class="line">Client 1 close connection</div><div class="line">task runing. --- 0</div><div class="line">task runing. --- 1</div><div class="line">task runing. --- 2</div><div class="line">task runing. --- 3</div><div class="line">task runing. --- 4</div><div class="line">finish received data &apos;task end&apos;</div></pre></td></tr></table></figure></p>
<p>从上边 server 执行的结果可以看出，task执行已经在 close 之后了，这样就知道什么是异步任务了吧。<br>总结一下应用场景：</p>
<ul>
<li>没有耗时任务的情况下，worker直接运行，无需开启task</li>
<li>对于耗时的任务，可以在worker内调用task函数，把异步任务投递给task进程进行处理，task进程的数量取决于task_worker_num的配置</li>
<li>task进程内可以选择调用finish方法或者return，来通知worker进程此任务已完成，worker进程会在onFinish回调中对task的执行结果进一步处理。如果worker进程不关心任务的结果，finish就不需要做处理了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;swoole_server-&amp;gt;task&lt;/code&gt;投递一个异步任务到 task_worker 池中。此函数是非阻塞的，执行完毕会立即返回。Worker 进程可以继续处理新的请求。使用Task功能，必须先设置 &lt;em&gt;task_worker_num&lt;/em&gt;，并且必须设置 Server 的 &lt;em&gt;onTask&lt;/em&gt; 和 &lt;em&gt;onFinish &lt;/em&gt;事件回调函数。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole 初识 简单的 Server Client</title>
    <link href="http://www.iooeo.com/2017/08/01/swoole-%E5%88%9D%E8%AF%86-%E7%AE%80%E5%8D%95%E7%9A%84-Server-Client/"/>
    <id>http://www.iooeo.com/2017/08/01/swoole-初识-简单的-Server-Client/</id>
    <published>2017-08-01T03:21:13.000Z</published>
    <updated>2017-08-01T06:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了学 Swoole，我们在开始之前已经普及了很多的知识，这篇我们就要上手玩一把 Swoole，是不是感觉有点手痒了。。<br><a id="more"></a><br>前边几篇分别记录了：</p>
<ul>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AF%87/">进程与线程</a></li>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-I-O-%E6%A8%A1%E5%9E%8B/">I/O 模型</a></li>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E7%AF%87/">网络通讯协议</a></li>
<li><a href="http://www.iooeo.com/2017/08/01/swoole-Socket%E7%AF%87/">socket</a></li>
</ul>
<p>都是一些简单的网路基础知识，不过这些最好要牢记。<br>然后就是 Swoole 扩展的安装：</p>
<ul>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%AF%87/">Swoole 扩展安装</a></li>
</ul>
<h2 id="Swoole-server"><a href="#Swoole-server" class="headerlink" title="Swoole server"></a>Swoole server</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>server 的创建其实非常简单，只需要我们在安装好扩展的基础上，实现以下代码就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// $serv = new swoole_server(string $host, int $port, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP);</div><div class="line">$serv = new swoole_server(&apos;127.0.0.1&apos;, 9501);</div></pre></td></tr></table></figure></p>
<p>swoole_server 类的构造函数一共有四个参数，上面我们填写了两个 ，还有两个有默认值，不填也可。<br>swoole_server构造函数</p>
<ul>
<li>@param     $host         // 监听的 IP</li>
<li>@param     $port        // 监听的端口</li>
<li>@param int $mode        // 运行模式，swoole提供了3种运行模式，默认为SWOOLE_PROCESS多进程模式</li>
<li>@param int $sock_type    // Socket的类型,支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种，默认为SWOOLE_SOCK_TCP TCP 类型</li>
</ul>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p><code>swoole_server-&gt;set()</code>函数用于设置swoole_server运行时的各项参数。服务器启动后通过$serv-&gt;setting来访问set函数设置的参数数组。<br>具体有哪些设置，我们后边慢慢学习，现在我们先实现一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">    &apos;worker_num&apos; =&gt; 2,</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>worker_num 设置启动的worker进程数量。swoole采用固定worker进程的模式。<br>PHP代码中是全异步非阻塞，worker_num配置为CPU核数的1-4倍即可。如果是同步阻塞，worker_num配置为100或者更高，具体要看每次请求处理的耗时和操作系统负载状况。</p>
<h3 id="事件回调函数"><a href="#事件回调函数" class="headerlink" title="事件回调函数"></a>事件回调函数</h3><p><code>swoole_server-&gt;on()</code>注册Server的事件回调函数。</p>
<ul>
<li>第1个参数是回调的名称, 大小写不敏感，具体内容参考回调函数列表，事件名称字符串不要加on</li>
<li>第2个函数是回调的PHP函数，可以是函数名的字符串，类静态方法，对象方法数组，匿名函数</li>
</ul>
<p>有新的客户端连接时，worker进程内会触发该回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;new client connected.\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>server接收到客户端的数据后，worker进程内触发该回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123;</div><div class="line">    echo &quot;Get Message From Client &#123;$fd&#125;:&#123;$data&#125;\n&quot;;</div><div class="line">    $serv-&gt;send($fd, $data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>客户端断开连接或者server主动关闭连接时 worker进程内调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;Client &#123;$fd&#125; close connection\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="启动server"><a href="#启动server" class="headerlink" title="启动server"></a>启动server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;start();</div></pre></td></tr></table></figure>
<h2 id="Swoole-Client"><a href="#Swoole-Client" class="headerlink" title="Swoole Client"></a>Swoole Client</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>client 的创建一样非常简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$client = new swoole_client(SWOOLE_SOCK_TCP);</div></pre></td></tr></table></figure></p>
<p>swoole_client 类的构造函数一共有三个参数。<br>swoole_client构造函数</p>
<ul>
<li>@param int $sock_type 指定socket的类型，支持TCP/UDP、TCP6/UDP6 4种</li>
<li>@param int $sync_type SWOOLE_SOCK_SYNC/SWOOLE_SOCK_ASYNC  同步/异步</li>
<li>@param string $connectionKey 链接的编号，用于长连接复用</li>
</ul>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$client-&gt;connect(&apos;127.0.0.1&apos;, 9501) || exit(&quot;connect failed. Error: &#123;$client-&gt;errCode&#125;\n&quot;);</div></pre></td></tr></table></figure>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$client-&gt;send(&quot;hello server.&quot;);</div></pre></td></tr></table></figure>
<h3 id="从服务端接收数据"><a href="#从服务端接收数据" class="headerlink" title="从服务端接收数据"></a>从服务端接收数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$response = $client-&gt;recv();</div></pre></td></tr></table></figure>
<h3 id="输出接受到的数据"><a href="#输出接受到的数据" class="headerlink" title="输出接受到的数据"></a>输出接受到的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $response . PHP_EOL;</div></pre></td></tr></table></figure>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$client-&gt;close();</div></pre></td></tr></table></figure>
<h2 id="Server-和-Client-通讯"><a href="#Server-和-Client-通讯" class="headerlink" title="Server 和 Client 通讯"></a>Server 和 Client 通讯</h2><p>终端执行命令，将 server 挂起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ php server.php</div></pre></td></tr></table></figure></p>
<p>打开新的终端执行 client 程序，在此之前你可以使用一下命令查看 server 监听的9501端口的监听情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ netstat -an | grep 9501</div><div class="line">tcp4       0      0  127.0.0.1.9501         *.*                    LISTEN</div></pre></td></tr></table></figure></p>
<p>从上边可以看到一些状态<em>tcp4</em>、<em>LISTEN</em>等关键信息<br>执行 client 代码程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ php client.php </div><div class="line">hello server.</div></pre></td></tr></table></figure></p>
<p>运行 server的终端会显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ php server.php </div><div class="line">new client connected.</div><div class="line">Get Message From Client 1:hello server.</div><div class="line">Client 1 close connection</div></pre></td></tr></table></figure></p>
<blockquote>
<p>到这个地方我们已经简单的实现了 Swoole Server 和 Client 的链接通讯。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了学 Swoole，我们在开始之前已经普及了很多的知识，这篇我们就要上手玩一把 Swoole，是不是感觉有点手痒了。。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole Socket篇</title>
    <link href="http://www.iooeo.com/2017/08/01/swoole-Socket%E7%AF%87/"/>
    <id>http://www.iooeo.com/2017/08/01/swoole-Socket篇/</id>
    <published>2017-08-01T02:50:21.000Z</published>
    <updated>2017-08-01T03:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 PHP socket 的使用，我在之前的工作中使用过一些，自己也动手封装了关于 socket server 和 socket client 的类库，已共享到 GitHub 和码云上面：<br><a id="more"></a></p>
<ul>
<li><a href="https://github.com/yangyiyuan/simple-socket/tree/master" target="_blank" rel="external">Github PHP simple-socket</a></li>
<li><a href="https://gitee.com/ewan.yang/simple-socket" target="_blank" rel="external">Oschina PHP simple-socket</a></li>
</ul>
<p>当然也有更好的例如 workerman 之类的 socket 开源项目。<br>但 socket 对于大部分 phper还是比较陌生的一个词语，百度上给出大部分网文关键字都是<em>套接字</em>，比较抽象难懂一些。<br>socket即套接字，是用来与另一个进程进行跨网络通信的文件，说是“文件”，也很好理解哈，因为在linux中一切都可以理解为“文件”。比如客户端可以借助socket与服务器之间建立连接。你也可以把socket理解为一组函数库，它确实也就是一堆函数。<br>我们知道，常见的网络应用都是基于Client-Server模型的。即一个服务器进程和多个客户端进程组合而成，如果你还理解为是一台电脑对另一台电脑，可以回去把进程/线程一文再看看了。在Client-Server模型中，服务器管理某种资源，并且通过对它管理的资源进行操作来为客户端提供服务。<br>那Client和Server又如何实现通信呢？这就要利用socket一系列的函数实现了。<br>基于套接字接口的网络应用的描述，用下面这张图来理解就好。<br><img src="http://ogpq2zwg5.bkt.clouddn.com/217f4d714f-socket-client-server.png" alt="套接字接口的网络应用的描述"></p>
<p>大致可以描述为：</p>
<blockquote>
<p>服务器创建一个socket，绑定ip和端口，在该端口处进行监听，然后通过accept函数阻塞。<br>当有新的客户端连接进来时，server接收客户端数据并处理数据，然后返回给客户端，客户端关闭连接，server关闭该客户端，一次连接交互完成。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 PHP socket 的使用，我在之前的工作中使用过一些，自己也动手封装了关于 socket server 和 socket client 的类库，已共享到 GitHub 和码云上面：&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole  编译安装篇</title>
    <link href="http://www.iooeo.com/2017/07/31/swoole-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%AF%87/"/>
    <id>http://www.iooeo.com/2017/07/31/swoole-编译安装篇/</id>
    <published>2017-07-31T09:45:37.000Z</published>
    <updated>2017-07-31T10:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前边几篇文章，分别记录了</p>
<ul>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AF%87/">进程与线程</a></li>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-I-O-%E6%A8%A1%E5%9E%8B/">I/O 模型</a></li>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E7%AF%87/">网络通讯协议</a></li>
</ul>
<p>其实都是为了我们更好的学习 Swoole 打下基础，Swoole 几乎涉及到网络开发的方方面面，但是这些可能不是每个 phper所具备的。<br><a id="more"></a><br>学了那么多网络基础知识，下面我们开始慢慢的接触 Swoole，后边有需要补充的网络知识，也会文章记录。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>安装部分我只针对我自己的电脑做安装记录，其他系统的同学可以网上找相关教程。</p>
<ul>
<li>macOS Sierra 10.12.6</li>
<li>PHP 5.6.28</li>
<li>gcc</li>
<li>make</li>
<li>autoconf</li>
<li>Swoole 2.0.7</li>
</ul>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><ul>
<li>下载 Swoole 最新版本到本地，<a href="https://git.oschina.net/swoole/swoole/tree/v2.0.7" target="_blank" rel="external">官网下载链接</a></li>
<li>下载好以后解压</li>
</ul>
<p>终端执行编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cd swoole</div><div class="line">$ phpize</div><div class="line">$ ./configure</div><div class="line">$ make </div><div class="line">$ sudo make install</div></pre></td></tr></table></figure></p>
<p>执行完以上命令，中途没有报错的话，就表示已经安装完成。<br>下面我们来检查一下到底有没有安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ php -m | grep swoole</div><div class="line">swoole</div><div class="line">$ php --ri swoole | grep Version</div><div class="line">Version =&gt; 2.0.7</div></pre></td></tr></table></figure></p>
<p>到这里，已经完全没有问题了。如果你安装中碰到什么问题，可以留言，也可以直接联系，让我们共同应对问题，一起成长！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前边几篇文章，分别记录了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.iooeo.com/2017/07/31/swoole-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AF%87/&quot;&gt;进程与线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.iooeo.com/2017/07/31/swoole-I-O-%E6%A8%A1%E5%9E%8B/&quot;&gt;I/O 模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.iooeo.com/2017/07/31/swoole-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E7%AF%87/&quot;&gt;网络通讯协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实都是为了我们更好的学习 Swoole 打下基础，Swoole 几乎涉及到网络开发的方方面面，但是这些可能不是每个 phper所具备的。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole 网络通讯协议篇</title>
    <link href="http://www.iooeo.com/2017/07/31/swoole-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E7%AF%87/"/>
    <id>http://www.iooeo.com/2017/07/31/swoole-网络通讯协议篇/</id>
    <published>2017-07-31T09:11:46.000Z</published>
    <updated>2017-07-31T09:20:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时我们打开一个浏览器，然后输入网址后回车，即展现了一个网页的内容。这是一个非常简单的操作。我们来简单的概括下背后的逻辑。<br><a id="more"></a></p>
<ol>
<li>浏览器通过TCP/IP协议建立到服务器的TCP连接</li>
<li>客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档</li>
<li>服务器向客户端发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端</li>
<li>客户端与服务器断开，由客户端解释HTML文档，在客户端屏幕上渲染图形结果</li>
</ol>
<p>表面上看这就是两台电脑之间进行的一种通信。<br>更确切的说，是两台计算机上两个进程之间的通信。你打开浏览器相当于启动了一个浏览器进程，而服务端事先也启动了某个进程，在某个端口监听，时刻等待客户端的连接。</p>
<p><em>那么问题来了，为什么客户端可以请求到服务器呢？服务器上跑那么多服务，又是怎么知道客户端想要什么呢？</em><br>其实答案很简单，因为有网络。计算机为了联网，就必须遵循通信协议。早期的互联网有很多协议，但是最重要的就非TCP协议和IP协议莫属了。所以，我们把互联网的协议简称为TCP/IP协议。</p>
<p>想必大家都有过这样的经历，客户端通过telnet连接服务器的时候，往往都需要一个ip地址和一个端口。如果客户端跟服务器之间有数据的交互，其过程大致是这样的：</p>
<h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>IP协议负责把你本机的数据发送到服务端，数据被分割成一块一块的。然后通过IP包发送出去。IP包的特点是按块发送，但不保证能到达，也不保证数据块依次到达。<br>如果是这样进行数据传输，服务器根本不能保证接收到的数据的完整性和顺序性，这样是不是就会有很大的问题呢？</p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>于是乎，TCP协议应运而生，它是建立在IP协议之上，专门负责建立可靠连接，并保证数据包顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方顺序收到，如果出现丢包，则重新发送。<br>这个时候再说TCP协议是一种面向连接、可靠的、基于IP之上的传出层协议就不难理解了吧。</p>
<p>TCP协议还有一个更重要的特点，它是基于<em>数据流</em>的。<br>什么意思呢？这就好比客户端和服务端要进行数据交互，中间有一个管子连接着，这个时候交互数据就好比管子中的水，当数据在传输（水在流动）的过程中，服务端是无法知道哪段数据是我们想要的完整数据。怎么解决这一问题呢？这个时候就需要双方约定一个协议来解决了。再往后说就说到应用层协议了，比如http协议，我们姑且不谈。</p>
<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>TCP懂了，UDP自然就不难理解了。<br>相对于TCP,使用UDP协议进行通信的最大区别就是，UDP不需要建立连接，给他一个ip和端口，就可以直接发送数据包了。但是，能不能成功到达就不知道了。虽然UDP传输不可靠，但是速度快。对于一些对数据要求不高的场景，使用UDP通信无疑是不错的选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时我们打开一个浏览器，然后输入网址后回车，即展现了一个网页的内容。这是一个非常简单的操作。我们来简单的概括下背后的逻辑。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title> swoole I/O 模型</title>
    <link href="http://www.iooeo.com/2017/07/31/swoole-I-O-%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.iooeo.com/2017/07/31/swoole-I-O-模型/</id>
    <published>2017-07-31T08:49:12.000Z</published>
    <updated>2017-07-31T09:04:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>I/O即Input/Output,输入和输出的意思。在计算机的世界里，涉及到数据交换的地方，比如磁盘、网络等，就需要I/O接口。<br><a id="more"></a><br>通常，I/O是相对的。比如说你打开浏览器，通过网络I/O获取我们网站的网页，浏览器首先会往服务器发送请求，这是一个Output操作，随后服务器给浏览器返回信息，这就是一个Input操作。以上都是基于浏览器而言。但是，有些操作就比较特殊。比如程序在运行时，数据被加载在内存中，通过程序往磁盘写数据，对内存而言，这就是单方面的的Output。<br>I/O模型通常有很多种，我们简单介绍下同步I/O和异步I/O。</p>
<h2 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a>同步I/O</h2><ul>
<li>实际上我们刚刚介绍的浏览器请求服务器的过程正是同步I/O的例子。</li>
<li>那我们再比如，假设我们要通过程序往磁盘写大量的数据，如果没有磁盘I/O操作，php程序在内存中执行的速度是非常快的，但是磁盘写数据的过程相对而言就是漫长的，CPU就需要等待磁盘I/O操作之后才能继续执行其他代码，像上面这两种情况，我们都称之为同步I/O。</li>
</ul>
<p>php本身是单线程的，当php进程被挂起的时候，像上面的读取磁盘数据，往磁盘写数据，在I/O操作之前php代码就没办法继续执行了。<br>因为I/O操作阻塞了当前线程，如果某用户也想从磁盘上读取或者写数据，就需要等待。</p>
<p>有些人要反驳了，这不对呀，我经历不是这样的，很多人可以同时访问我的网站，这没问题的。<br>这个没必要纠结，php本身是单进程单线程的，用户可以同时访问你的网站实际上是web服务器的功劳。这就是我们之前讨论过的，如何解决多任务的问题。<br>web服务器的进程模型暂时不多讨论，免得懵。<br>如果不考虑web服务器，是不是当前进程一旦阻塞，其他人访问php都会被阻塞啦？答案是肯定的。要解决这个问题，又回到我们一直强调的多进程或者多线程。</p>
<p>但是，如果为了解决并发问题，系统开启了大量的进程，就像我们之前说的，操作系统在进程或者线程间切换同样会造成CPU大量的开销。有没有更好的解决方案呢？</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>答案就是异步I/O。我们再来强调一遍异步I/O是要解决什么问题的：<em>同一线程内，执行一些耗时的任务时，其他代码是不能继续执行的，要等待该任务操作完之后才可以。</em></p>
<h2 id="同步I-O和异步I-O区别"><a href="#同步I-O和异步I-O区别" class="headerlink" title="同步I/O和异步I/O区别"></a>同步I/O和异步I/O区别</h2><p>同步I/O模型下，主线程只能被挂起等待，但是在异步I/O模型中，主线程发起I/O指令后，可以继续执行其他指令，没有被挂起，也没有切换线程的操作。由此看来，使用异步I/O明显可以提高了系统性能。</p>
<blockquote>
<p>其实I/O模型远不止我们介绍的这两种，有兴趣的可以借助google更深层次的了解一下。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I/O即Input/Output,输入和输出的意思。在计算机的世界里，涉及到数据交换的地方，比如磁盘、网络等，就需要I/O接口。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole 进程与线程篇</title>
    <link href="http://www.iooeo.com/2017/07/31/swoole-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AF%87/"/>
    <id>http://www.iooeo.com/2017/07/31/swoole-进程与线程篇/</id>
    <published>2017-07-31T07:57:53.000Z</published>
    <updated>2017-07-31T09:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司的物联网设备架构有所调整，需要长连接保持，一直觊觎了很久的 Swoole 学习提上日程。<br>至于 Swoole 是做什么的，<a href="http://www.swoole.com/" target="_blank" rel="external">Swoole官网</a>给出了一堆很 NB 的介绍。总之你需要知道<br><a id="more"></a><br><code>swoole是基于C开发的一个php扩展，类似你熟悉的Mysqli、cURL等等。但是swoole更强大，它几乎重新定义了php的高度，让php变得更加无可挑剔。也让phper们的前景更加辽阔！</code></p>
<p>既然 Swoole 那边 NB 闪闪，感觉一副高大上的样子，那再学习之前必须要做好预习准备啦。下面的笔记借鉴了白狼栈的学习教程，有兴趣的同学可以付费认证的看上一遍，真的写的很不错！</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>对于操作系统而言，进程就是一个任务，比方说你打开了一个记事本，那就启动了一个进程，打开了两个浏览器，就是另外开启了两个进程，简单的说一个进程至少要干一件事情。<br>对于Linux 系统而言，如果你想查看当前系统中运行的进程，可以通过 ps命令进行查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep php</div></pre></td></tr></table></figure></p>
<p>执行以上命令，我能够看到我机器上运行的 PHP 进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep php</div><div class="line">www        2051   0.0  0.0  2484400   2572   ??  S     9:08上午   0:00.05 php-fpm</div><div class="line">www        2050   0.0  0.0  2484528   2976   ??  S     9:08上午   0:00.16 php-fpm</div><div class="line">www        2049   0.0  0.0  2471088    396   ??  Ss    9:08上午   0:00.68 php-fpm</div><div class="line">www       59050   0.0  0.0  2442020   1968 s001  S+    3:52下午   0:00.00 grep php</div></pre></td></tr></table></figure></p>
<p>至于后边一堆时间什么的，如果不知道什么意思，建议看下鸟哥的 Linux 基础。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>有些情况下，一个进程会同时做一些事情，比如说word。它可以同时进行打字、拼写检查等操作。注意这里我们说的同时进行。像这样，在一个进程内部，同时运行着多个“子任务”，我们就可以把这些子任务称之为“线程”。即进程是由多个线程组成的，一个进程至少要有一个线程。实际上，线程是操作系统最小的执行单元。</p>
<h2 id="多任务的实现"><a href="#多任务的实现" class="headerlink" title="多任务的实现"></a>多任务的实现</h2><p>试想一下，如果我们要同时执行多个任务怎么办？</p>
<p>根据上文的理解，我们可以：</p>
<ul>
<li>启动多个进程</li>
<li>启动一个进程，并在该进程内启动多个线程</li>
<li>启动多个进程，每个进程内启动多个线程</li>
</ul>
<h2 id="多进程的实现"><a href="#多进程的实现" class="headerlink" title="多进程的实现"></a>多进程的实现</h2><p>熟悉 Apache 的同学其实很好理解。<br>当父进程监听到有新的请求时，Apache 就回 fork出一个新的子进程来对之进行处理。<br>Linux 的 fork（）函数通过系统调用即可实现创建一个与原进程几乎相同的进程。对于多任务，通常我们会设计Master-Worker模式，即一个Master进程负责分配任务，多个Worker进程负责执行任务。同理，如果是多线程，Master就是主线程，Worker就是子线程。</p>
<h2 id="多进程与多线程的区别"><a href="#多进程与多线程的区别" class="headerlink" title="多进程与多线程的区别"></a>多进程与多线程的区别</h2><p>开始迷糊了对吧，那就理解一下多进程和多线程的区别吧，以便应对场景做出合适的选择。<br>进程和线程的关系就像地主和佃户。地主，有土地（系统资源）；佃户，执行种地流程；</p>
<ul>
<li><p>多进程的优点就是稳定性很高，如果一个进程挂了，不会影响其他子进程，当然，如果主进程挂了那就都玩完（主进程挂掉的可能性微乎其微，后面讲进程模型会说到）。而对于多线程，这个恐怕就是致命的缺点了，因为所有线程共享内存，如果某一个线程挂了，那这个进程几乎就崩溃了。</p>
</li>
<li><p>性能方面，不论是进程还是线程，如果启动太多，无疑都会带来CPU的调度问题，因为进程或者线程的切换，本身就非常耗费资源。数量达到一定程度的时候，CPU和内存就消耗殆尽，电脑就死机了。<br>举一个例子：使用过windows的用户都知道，如果我们打开的软件越多（开启的进程也就越多），电脑就会越卡，甚至装死机没反应。</p>
</li>
<li><p>线程与进程相比，自然是要比进程更轻量一些，而且线程之间是共享内存的，所以不同线程之间的交互就显得容易实现。而对于多进程之间的通信，需要借助消息队列，共享内存等复杂的方式才可以实现。</p>
</li>
</ul>
<blockquote>
<p>进程和线程一定要研究明白是怎么回事<br>思考一下php、nginx、apache各自跟线程和进程是什么关系，可百度，可google，可下面留言。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司的物联网设备架构有所调整，需要长连接保持，一直觊觎了很久的 Swoole 学习提上日程。&lt;br&gt;至于 Swoole 是做什么的，&lt;a href=&quot;http://www.swoole.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swoole官网&lt;/a&gt;给出了一堆很 NB 的介绍。总之你需要知道&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>新的评论系统</title>
    <link href="http://www.iooeo.com/2017/07/28/%E6%96%B0%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.iooeo.com/2017/07/28/新的评论系统/</id>
    <published>2017-07-28T07:08:41.000Z</published>
    <updated>2017-07-28T07:12:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>继多说关闭以后,网易又随之而去.这对于没有自己搭建评论系统的我来说,无疑是一个非常不愉快的消息.</code><br><code>but,今天新的评论系统终于安装成功,经过了十几天的域名备案,大家又可以畅所欲言了.</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;继多说关闭以后,网易又随之而去.这对于没有自己搭建评论系统的我来说,无疑是一个非常不愉快的消息.&lt;/code&gt;&lt;br&gt;&lt;code&gt;but,今天新的评论系统终于安装成功,经过了十几天的域名备案,大家又可以畅所欲言了.&lt;/code&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="杂谈" scheme="http://www.iooeo.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="微语" scheme="http://www.iooeo.com/tags/%E5%BE%AE%E8%AF%AD/"/>
    
      <category term="胡侃" scheme="http://www.iooeo.com/tags/%E8%83%A1%E4%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>Yii2 请求(Requests)</title>
    <link href="http://www.iooeo.com/2017/07/22/Yii2-%E8%AF%B7%E6%B1%82-Requests/"/>
    <id>http://www.iooeo.com/2017/07/22/Yii2-请求-Requests/</id>
    <published>2017-07-22T03:42:41.000Z</published>
    <updated>2017-07-22T04:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇不讲插件，讲一下 Yii2的请求（Requests），强行安利一波。<br><a id="more"></a></p>
<h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><p>要获取请求参数，你可以调用 <code>request</code> 组件的 <code>get()</code> 方法和 <code>post()</code> 方法。 他们分别返回 <code>$_GET 和</code> <code>$_POST</code> 的值。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$request = Yii::$app-&gt;request;</div><div class="line"></div><div class="line">$get = $request-&gt;get(); </div><div class="line">// 等价于: $get = $_GET;</div><div class="line"></div><div class="line">$id = $request-&gt;get(&apos;id&apos;);   </div><div class="line">// 等价于: $id = isset($_GET[&apos;id&apos;]) ? $_GET[&apos;id&apos;] : null;</div><div class="line"></div><div class="line">$id = $request-&gt;get(&apos;id&apos;, 1);   </div><div class="line">// 等价于: $id = isset($_GET[&apos;id&apos;]) ? $_GET[&apos;id&apos;] : 1;</div><div class="line"></div><div class="line">$post = $request-&gt;post(); </div><div class="line">// 等价于: $post = $_POST;</div><div class="line"></div><div class="line">$name = $request-&gt;post(&apos;name&apos;);   </div><div class="line">// 等价于: $name = isset($_POST[&apos;name&apos;]) ? $_POST[&apos;name&apos;] : null;</div><div class="line"></div><div class="line">$name = $request-&gt;post(&apos;name&apos;, &apos;&apos;);   </div><div class="line">// 等价于: $name = isset($_POST[&apos;name&apos;]) ? $_POST[&apos;name&apos;] : &apos;&apos;;</div></pre></td></tr></table></figure></p>
<p>如果嫌每次都要这么写一大堆很麻烦的话，下面就教你一个简单的。<br>首先你所有的<code>Controller</code>都要继承一个<code>BaseController</code>，然后在你的<code>BaseController</code>里添加一下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public function post($param = null, $default_value = null)</div><div class="line">&#123;</div><div class="line">    return !$param ? Yii::$app-&gt;request-&gt;post() : Yii::$app-&gt;request-&gt;post($param, $default_value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么其他<code>Controller</code>用的时候就可以直接这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public function actionIndex()</div><div class="line">&#123;</div><div class="line">	// 无默认值</div><div class="line">	$name = $this-&gt;post(&apos;name&apos;);</div><div class="line">	// 有默认值</div><div class="line">	$name = $this-&gt;post(&apos;name&apos;,&apos;ewan&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我上边只实例了 POST 请求，GET 请求同理，需要的话可以直接加上就可以了。</p>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>你可以通过 Yii::$app-&gt;request-&gt;method 表达式来获取当前请求使用的HTTP方法。 这里还提供了一整套布尔属性用于检测当前请求是某种类型。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$request = Yii::$app-&gt;request;</div><div class="line"></div><div class="line">if ($request-&gt;isAjax) &#123; /* 该请求是一个 AJAX 请求 */ &#125;</div><div class="line">if ($request-&gt;isGet)  &#123; /* 请求方法是 GET */ &#125;</div><div class="line">if ($request-&gt;isPost) &#123; /* 请求方法是 POST */ &#125;</div><div class="line">if ($request-&gt;isPut)  &#123; /* 请求方法是 PUT */ &#125;</div></pre></td></tr></table></figure></p>
<h2 id="请求URLs"><a href="#请求URLs" class="headerlink" title="请求URLs"></a>请求URLs</h2><p>假设被请求的URL是 <code>http://example.com/admin/index.php/product?id=100</code>，你可以像下面描述的那样获取URL的各个部分：</p>
<ul>
<li><code>yii\web\Request::url</code>：返回 <code>/admin/index.php/product?id=100</code>, 此URL不包括<code>host info</code>部分。</li>
<li><code>yii\web\Request::absoluteUrl</code>：返回 <code>http://example.com/admin/index.php/product?id=100</code>, 包含<code>host infode</code>的整个URL。</li>
<li><code>yii\web\Request::hostInfo</code>：返回 <code>http://example.com</code>, 只有<code>host info</code>部分。</li>
<li><code>yii\web\Request::pathInfo</code>：返回 <code>/product</code>， 这个是入口脚本之后，问号之前（查询字符串）的部分。</li>
<li><code>yii\web\Request::queryString</code>：返回 <code>id=100</code>,问号之后的部分。</li>
<li><code>yii\web\Request::baseUrl</code>：返回 <code>/admin</code>, <code>host info</code>之后， 入口脚本之前的部分。</li>
<li><code>yii\web\Request::scriptUrl</code>：返回 <code>/admin/index.php</code>, 没有<code>path info</code>和查询字符串部分。</li>
<li><code>yii\web\Request::serverName</code>：返回 <code>example.com</code>, URL中的<code>host name</code>。</li>
<li><code>yii\web\Request::serverPort</code>：返回 <code>80</code>, 这是<code>web</code>服务中使用的端口。</li>
</ul>
<h2 id="HTTP头"><a href="#HTTP头" class="headerlink" title="HTTP头"></a>HTTP头</h2><p>你可以通过 <code>yii\web\Request::headers</code> 属性返回的 <code>header collection</code> 获取<code>HTTP</code>头信息。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// $headers 是一个 yii\web\HeaderCollection 对象</div><div class="line">$headers = Yii::$app-&gt;request-&gt;headers;</div><div class="line"></div><div class="line">// 返回 Accept header 值</div><div class="line">$accept = $headers-&gt;get(&apos;Accept&apos;);</div><div class="line"></div><div class="line">if ($headers-&gt;has(&apos;User-Agent&apos;)) &#123; /* 这是一个 User-Agent 头 */ &#125;</div></pre></td></tr></table></figure></p>
<p>请求组件也提供了支持快速访问常用头的方法，包括：</p>
<ul>
<li><code>yii\web\Request::userAgent</code>：返回 <code>User-Agent</code> 头。</li>
<li><code>yii\web\Request::contentType</code>：返回 <code>Content-Type</code> 头的值， <code>Content-Type</code> 是请求体中MIME类型数据。</li>
<li><code>yii\web\Request::acceptableContentTypes</code>：返回用户可接受的内容MIME类型。 返回的类型是按照他们的质量得分来排序的。得分最高的类型将被最先返回。</li>
<li><code>yii\web\Request::acceptableLanguages</code>：返回用户可接受的语言。 返回的语言是按照他们的偏好层次来排序的。第一个参数代表最优先的语言。</li>
</ul>
<p>假如你的应用支持多语言，并且你想在终端用户最喜欢的语言中显示页面， 那么你可以使用语言协商方法 <code>yii\web\Request::getPreferredLanguage()</code>。 这个方法通过 <code>yii\web\Request::acceptableLanguages</code> 在你的应用中所支持的语言列表里进行比较筛选，返回最适合的语言。</p>
<blockquote>
<p>提示: 你也可以使用 ContentNegotiator 过滤器进行动态确定哪些内容类型和语言应该在响应中使用。 这个过滤器实现了上面介绍的内容协商的属性和方法。</p>
</blockquote>
<h2 id="客户端信息"><a href="#客户端信息" class="headerlink" title="客户端信息"></a>客户端信息</h2><p>你可以通过 <code>yii\web\Request::userHost</code> 和 <code>yii\web\Request::userIP</code> 分别获取<code>host name</code>和客户机的IP地址， 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$userHost = Yii::$app-&gt;request-&gt;userHost;</div><div class="line">$userIP = Yii::$app-&gt;request-&gt;userIP;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇不讲插件，讲一下 Yii2的请求（Requests），强行安利一波。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/categories/PHP/Yii2/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2 文件上传插件</title>
    <link href="http://www.iooeo.com/2017/07/22/Yii2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6/"/>
    <id>http://www.iooeo.com/2017/07/22/Yii2-文件上传插件/</id>
    <published>2017-07-22T03:22:58.000Z</published>
    <updated>2017-07-22T03:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>文件上传的需求也是必不可少，带飞一波。<br><a id="more"></a></p>
<h2 id="文件上传插件-yii2-widget-fileinput"><a href="#文件上传插件-yii2-widget-fileinput" class="headerlink" title="文件上传插件 yii2-widget-fileinput"></a>文件上传插件 yii2-widget-fileinput</h2><p><a href="https://github.com/yangyiyuan/yii2-widget-fileinput" target="_blank" rel="external">yii2-widget-fileinput</a>小部件是基于Krajee的Bootstrap FileInput JQuery插件的定制文件输入小部件。想了解的话，可以点连接进入 GitHub 查看详细信息。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>切换到项目目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd project</div></pre></td></tr></table></figure></p>
<h4 id="安装方法一"><a href="#安装方法一" class="headerlink" title="安装方法一"></a>安装方法一</h4><p>执行 <em>composer</em>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ composer require kartik-v/yii2-widget-fileinput &quot;@dev&quot;</div></pre></td></tr></table></figure></p>
<h4 id="安装方法二"><a href="#安装方法二" class="headerlink" title="安装方法二"></a>安装方法二</h4><p>在项目目录下的<em>composer.json</em>文件中如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;require&quot;: &#123;</div><div class="line">    ...,</div><div class="line">    &quot;kartik-v/yii2-widget-fileinput&quot;: &quot;@dev&quot;,</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行<em>composer</em>更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ composer update</div></pre></td></tr></table></figure></p>
<h2 id="使用-FileInput-插件"><a href="#使用-FileInput-插件" class="headerlink" title="使用 FileInput 插件"></a>使用 FileInput 插件</h2><p>插件的使用可以分为两种，一种是独立的使用，一种是结合 Yii2的ActiveForm组件使用</p>
<h4 id="独立使用"><a href="#独立使用" class="headerlink" title="独立使用"></a>独立使用</h4><p>直接调用，在视图文件中写入如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use kartik\file\FileInput;</div><div class="line"></div><div class="line">echo &apos;&lt;label class=&quot;control-label&quot;&gt;Add Attachments&lt;/label&gt;&apos;;</div><div class="line">echo FileInput::widget([</div><div class="line">    &apos;model&apos; =&gt; $model,</div><div class="line">    &apos;attribute&apos; =&gt; &apos;attachment_1&apos;,</div><div class="line">    &apos;options&apos; =&gt; [&apos;multiple&apos; =&gt; true]</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<h4 id="结合ActiveForm表单组件使用"><a href="#结合ActiveForm表单组件使用" class="headerlink" title="结合ActiveForm表单组件使用"></a>结合ActiveForm表单组件使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use kartik\file\FileInput;</div><div class="line"></div><div class="line">echo $form-&gt;field($model, &apos;avatar&apos;)-&gt;widget(FileInput::classname(), [</div><div class="line">    &apos;options&apos; =&gt; [&apos;accept&apos; =&gt; &apos;image/*&apos;],</div><div class="line">]);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件上传的需求也是必不可少，带飞一波。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/categories/PHP/Yii2/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2 时间插件</title>
    <link href="http://www.iooeo.com/2017/07/22/Yii2-%E6%97%B6%E9%97%B4%E6%8F%92%E4%BB%B6/"/>
    <id>http://www.iooeo.com/2017/07/22/Yii2-时间插件/</id>
    <published>2017-07-22T02:33:38.000Z</published>
    <updated>2017-07-22T03:19:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目开发中难免会用到时间插件，这里我找了一个使用比较广泛的时间插件。用法如下：<br><a id="more"></a></p>
<h2 id="时间插件-yii2-widget-datetimepicker"><a href="#时间插件-yii2-widget-datetimepicker" class="headerlink" title="时间插件 yii2-widget-datetimepicker"></a>时间插件 yii2-widget-datetimepicker</h2><p><a href="https://github.com/yangyiyuan/yii2-widget-datetimepicker" target="_blank" rel="external">yii2-widget-datetimepicker</a>小部件是一个用于引导DateTimePicker插件的Yii 2包装器，它具有各种增强功能。想了解的话，可以点连接进入 GitHub 查看详细信息。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>切换到项目目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd project</div></pre></td></tr></table></figure></p>
<h4 id="安装方法一"><a href="#安装方法一" class="headerlink" title="安装方法一"></a>安装方法一</h4><p>执行 <em>composer</em>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ composer require kartik-v/yii2-widget-datetimepicker &quot;*&quot;</div></pre></td></tr></table></figure></p>
<h4 id="安装方法二"><a href="#安装方法二" class="headerlink" title="安装方法二"></a>安装方法二</h4><p>在项目目录下的<em>composer.json</em>文件中如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;require&quot;: &#123;</div><div class="line">    ...,</div><div class="line">    &quot;kartik-v/yii2-widget-datetimepicker&quot;: &quot;*&quot;,</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行<em>composer</em>更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ composer update</div></pre></td></tr></table></figure></p>
<h2 id="使用-DateTimePicker-插件"><a href="#使用-DateTimePicker-插件" class="headerlink" title="使用 DateTimePicker 插件"></a>使用 DateTimePicker 插件</h2><p>插件的使用可以分为两种，一种是独立的使用，一种是结合 Yii2的ActiveForm组件使用</p>
<h4 id="独立使用"><a href="#独立使用" class="headerlink" title="独立使用"></a>独立使用</h4><p>直接调用，在视图文件中写入如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use kartik\datetime\DateTimePicker;</div><div class="line"></div><div class="line">echo &apos;&lt;label&gt;Start Date/Time&lt;/label&gt;&apos;;</div><div class="line">echo DateTimePicker::widget([</div><div class="line">    &apos;name&apos; =&gt; &apos;datetime_10&apos;,</div><div class="line">    &apos;options&apos; =&gt; [&apos;placeholder&apos; =&gt; &apos;Select operating time ...&apos;],</div><div class="line">    &apos;convertFormat&apos; =&gt; true,</div><div class="line">    &apos;pluginOptions&apos; =&gt; [</div><div class="line">        &apos;format&apos; =&gt; &apos;d-M-Y g:i A&apos;,</div><div class="line">        &apos;startDate&apos; =&gt; &apos;01-Mar-2014 12:00 AM&apos;,</div><div class="line">        &apos;todayHighlight&apos; =&gt; true</div><div class="line">    ]</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<h4 id="结合ActiveForm表单组件使用"><a href="#结合ActiveForm表单组件使用" class="headerlink" title="结合ActiveForm表单组件使用"></a>结合ActiveForm表单组件使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">use kartik\datetime\DateTimePicker;</div><div class="line">?&gt;</div><div class="line"></div><div class="line">&lt;?php $form = ActiveForm::begin(); ?&gt;</div><div class="line"></div><div class="line">&lt;?= $form-&gt;field($model, &apos;created_at&apos;)-&gt;widget(DateTimePicker::classname(), [</div><div class="line">        &apos;options&apos; =&gt; [&apos;placeholder&apos; =&gt; &apos;&apos;],</div><div class="line">        &apos;pluginOptions&apos; =&gt; [</div><div class="line">            &apos;autoclose&apos; =&gt; true,</div><div class="line">            &apos;format&apos; =&gt; &apos;yyyy-mm-dd hh:ii&apos;,</div><div class="line">            &apos;startDate&apos; =&gt; &apos;01-Mar-2014 12:00 AM&apos;,</div><div class="line">            &apos;todayHighlight&apos; =&gt; true</div><div class="line">        ]</div><div class="line">    ]);</div><div class="line">?&gt;</div><div class="line"></div><div class="line">&lt;?php ActiveForm::end(); ?&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目开发中难免会用到时间插件，这里我找了一个使用比较广泛的时间插件。用法如下：&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/categories/PHP/Yii2/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2 批量插入</title>
    <link href="http://www.iooeo.com/2017/07/21/Yii2-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"/>
    <id>http://www.iooeo.com/2017/07/21/Yii2-批量插入/</id>
    <published>2017-07-21T07:56:10.000Z</published>
    <updated>2017-07-22T02:33:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Yii2开发的过程中难免会遇到批量插入的问题，下边实例一下批量插入的操作。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$goods_model = new Goods();</div><div class="line"># 获取表名</div><div class="line">$table_name = $goods_model-&gt;tableName();</div><div class="line"></div><div class="line"># 要插入数据的字段 $fields = [&apos;name&apos;,&apos;price&apos;]；</div><div class="line">$fields = $goods_model-&gt;getAttributes();</div><div class="line">isset($fields[&apos;id&apos;]) &amp;&amp; unset($fields[&apos;id&apos;]);</div><div class="line"></div><div class="line"># 要插入的数据，这里要自己拼装，要和字段对应上</div><div class="line">$data = [[&apos;电视机&apos;，2999]，[&apos;电脑&apos;，3888]];</div><div class="line"></div><div class="line"># 返回总插入条数</div><div class="line">$total_num = Yii::$app-&gt;db-&gt;createCommand()-&gt;batchInsert($table_name, $fields, $data)-&gt;execute();</div></pre></td></tr></table></figure></p>
<p>批量插入的时候最好和 model 事务搭配，这样可以保证数据的完整性，也方便检查错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Yii2开发的过程中难免会遇到批量插入的问题，下边实例一下批量插入的操作。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/categories/PHP/Yii2/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2  molde模型相关使用技巧</title>
    <link href="http://www.iooeo.com/2017/07/21/Yii2-molde%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.iooeo.com/2017/07/21/Yii2-molde模型相关使用技巧/</id>
    <published>2017-07-21T05:24:51.000Z</published>
    <updated>2017-07-21T08:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理一些 Yii2 Model模型在开发中常用到的一些方法我技巧。<br><code>模型是 MVC 模式中的一部分， 是代表业务数据、规则和逻辑的对象。</code><br><a id="more"></a></p>
<h2 id="获取查询-SQL"><a href="#获取查询-SQL" class="headerlink" title="获取查询 SQL"></a>获取查询 SQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$query = User::find()-&gt;where([&apos;like&apos;, &apos;name&apos;, &apos;ewan%&apos;, false]);</div><div class="line"></div><div class="line">$commandQuery = clone $query;</div><div class="line">// SELECT * FROM `user` WHERE `name` LIKE &apos;ewan%&apos;</div><div class="line">echo $commandQuery-&gt;createCommand()-&gt;getRawSql();</div></pre></td></tr></table></figure>
<h2 id="简单查询技巧"><a href="#简单查询技巧" class="headerlink" title="简单查询技巧"></a>简单查询技巧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">where(): 添加查询条件。</div><div class="line">select(): 添加查询字段。</div><div class="line">with(): 该查询应执行的关系列表。</div><div class="line">indexBy(): 根据索引的列的名称查询结果。</div><div class="line">asArray(): 以数组的形式返回每条记录。</div><div class="line">orderBy(): 按指定字段排序。</div><div class="line"></div><div class="line">User::find()-&gt;one();	// 返回一条数据，返回对象；</div><div class="line">User::find()-&gt;column();	// 返回查询结果中的第一列的值,返回数组；</div><div class="line">User::find()-&gt;scalar();	// 返回查询结果的第一行中的第一列的值；</div><div class="line">User::find()-&gt;all();	// 返回所有记录数据；</div><div class="line">User::find()-&gt;count();	// 返回记录的数量；</div><div class="line">User::find()-&gt;sum(&apos;num&apos;);	// 返回指定字段（&apos;num&apos;）的总和；</div><div class="line">User::find()-&gt;average(&apos;num&apos;);	// 返回指定字段（&apos;num&apos;）的平均值；</div><div class="line">User::find()-&gt;min(&apos;num&apos;);	// 返回指定字段（&apos;num&apos;）的最小值；</div><div class="line">User::find()-&gt;max(&apos;num&apos;);	// 返回指定字段（&apos;num&apos;）的最大值；</div><div class="line">User::find()-&gt;exists();	// 返回一个值，该值指示查询结果是否有数据；</div></pre></td></tr></table></figure>
<p>关联查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User::hasOne()：返回对应关系的单条记录</div><div class="line">User::hasMany()：返回对应关系的多条记录</div></pre></td></tr></table></figure></p>
<h2 id="模型中事务处理"><a href="#模型中事务处理" class="headerlink" title="模型中事务处理"></a>模型中事务处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Yii::$app-&gt;db-&gt;transaction(function() &#123;</div><div class="line">    $order = new Order($customer);</div><div class="line">    $order-&gt;save();</div><div class="line">    $order-&gt;addItems($items);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><p>批量插入的问题，已经写了一篇<a href="http://www.iooeo.com/2017/07/21/Yii2-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/">《Yii2 批量插入》</a>,点击链接查看即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天整理一些 Yii2 Model模型在开发中常用到的一些方法我技巧。&lt;br&gt;&lt;code&gt;模型是 MVC 模式中的一部分， 是代表业务数据、规则和逻辑的对象。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/categories/PHP/Yii2/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/tags/Yii2/"/>
    
  </entry>
  
</feed>
