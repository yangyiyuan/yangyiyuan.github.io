<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ewan&#39;s Blog</title>
  <subtitle>Ewan&#39;s Blog | 杨依园技术博客 | 专注于PHP，涉及MySQL，Linux，Web，Nginx，Apache，Phalcon，Laravel，Redis，PostgreSql，Composer，Beanstalkd，Swoole</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iooeo.com/"/>
  <updated>2017-11-06T02:52:05.000Z</updated>
  <id>http://www.iooeo.com/</id>
  
  <author>
    <name>Ewan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThinkPHP V5.0.12 暨 5.1.0 RC3 版本发布</title>
    <link href="http://www.iooeo.com/2017/11/06/ThinkPHP-V5-0-12-%E6%9A%A8-5-1-0-RC3-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/"/>
    <id>http://www.iooeo.com/2017/11/06/ThinkPHP-V5-0-12-暨-5-1-0-RC3-版本发布/</id>
    <published>2017-11-06T02:41:04.000Z</published>
    <updated>2017-11-06T02:52:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>V5.1.0版本是继5.0版本之后又一个重大版本，ThinkPHP5.1在5.0的基础上对底层架构做了进一步的改进，引入新特性，并提升版本要求。</em><br><a id="more"></a><br>ThinkPHP5.1运行环境要求PHP5.6+，虽然不支持5.0的无缝升级，但升级过程并不复杂（<a href="https://www.kancloud.cn/manual/thinkphp5_1/354155" target="_blank" rel="external">请参考升级指导</a>）</p>
<h2 id="主要新特性"><a href="#主要新特性" class="headerlink" title="主要新特性"></a>主要新特性</h2><ul>
<li>引入容器和Facade支持</li>
<li>依赖注入完善和支持更多场景</li>
<li>重构的（对象化）路由</li>
<li>配置和路由目录独立</li>
<li>取消系统常量</li>
<li>助手函数增强</li>
<li>类库别名机制</li>
<li>模型和数据库增强</li>
<li>验证类增强</li>
<li>模板引擎改进</li>
<li>支持PSR-3日志规范</li>
</ul>
<h2 id="RC3对于之前版本主要更新如下："><a href="#RC3对于之前版本主要更新如下：" class="headerlink" title="RC3对于之前版本主要更新如下："></a>RC3对于之前版本主要更新如下：</h2><ul>
<li>改进redis驱动的get方法</li>
<li>修正Query类的alias方法</li>
<li>File类错误信息支持多语言</li>
<li>修正路由的额外参数解析</li>
<li>改进whereTime方法</li>
<li>改进Model类getAttr方法</li>
<li>改进App类的controller和validate方法支持多层</li>
<li>改进HasManyThrough类</li>
<li>修正软删除的restore方法</li>
<li>改进MorpthTo关联</li>
<li>改进数据库驱动类的parseKey方法</li>
<li>增加whereField动态查询方法</li>
<li>模型增加废弃字段功能</li>
<li>改进路由的after行为检查和before行为机制</li>
<li>改进路由分组的检查</li>
<li>修正mysql的json字段查询</li>
<li>取消Connection类的quote方法</li>
<li>改进命令行的支持</li>
<li>验证信息支持多语言</li>
<li>修正路由模型绑定</li>
<li>改进参数绑定类型对枚举类型的支持</li>
<li>修正模板的{$Think.version}输出</li>
<li>改进模板date函数解析</li>
<li>改进insertAll方法支持分批执行</li>
<li>Request类host方法支持反向代理</li>
<li>改进JumpResponse支持区分成功和错误模板</li>
<li>改进开启类库后缀后的关联外键自动识别问题</li>
<li>修正一对一关联的JOIN方式预载入查询问题</li>
<li>Query类增加hidden方法</li>
</ul>
<p><code>目前5.1版本尚处于RC阶段，仅供学习，请勿用于商业项目！</code><br><code>5.1完全开发手册：</code><a href="https://www.kancloud.cn/manual/thinkphp5_1/content" target="_blank" rel="external">https://www.kancloud.cn/manual/thinkphp5_1/content</a></p>
<p>5.0.12是一个修正版本，包含了上个版本发布以来的一些修正和完善，主要包括：</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li>上传类和验证类的多语言支持；</li>
<li>模型增加排除和废弃字段支持；</li>
<li>改进insertAll方法的分批处理；</li>
<li>改进对枚举类型的参数绑定支持；</li>
<li>修正社区反馈的问题；</li>
</ul>
<h2 id="数据库和模型"><a href="#数据库和模型" class="headerlink" title="数据库和模型"></a>数据库和模型</h2><ul>
<li>改进Connection类的getRealSql方法</li>
<li>改进append方法支持一对一关联的bind设置</li>
<li>改进whereTime查询</li>
<li>改进model类的<code>destroy</code>方法</li>
<li>修正softdelete</li>
<li>修正<code>chunk</code>方法对时间字段的支持</li>
<li>Collection类增加<code>push</code>方法</li>
<li>改进alias方法 </li>
<li>修正模型类的<code>append</code>处理</li>
<li>改进<code>appendRelationAttr</code>方法</li>
<li>改进HasManyThrough关联</li>
<li>改进MorphTo关联</li>
<li>模型增加废除字段<code>disuse</code>定义</li>
<li>增加排除字段方法<code>except</code></li>
<li>修正<code>has</code>方法 </li>
<li>改进参数绑定类型对枚举类型的支持</li>
<li>改进<code>insertAll</code>方法的分批处理</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>改进Loader类<code>controller</code>和<code>validate</code>方法 支持多层</li>
<li>验证提示信息支持多语言</li>
<li>File类错误信息支持多语言 </li>
<li>模板渲染异常处理</li>
<li>修正rest控制器</li>
<li>改进trace驱动</li>
<li>改进Cache类的<code>remember</code>方法 </li>
<li>改进<code>url_common_param</code>的情况下urlencode的问题</li>
<li>改进Url类</li>
<li>改进<code>exception_handle</code>配置参数对闭包的支持 </li>
<li>执行路由缓存命令前检测RUNTIME_PATH是否存在 </li>
<li>调整部分<code>CacheDriver::dec</code>在为空的时候递减的行为</li>
<li>优化移动端的显示</li>
<li>改进对JSON-Handle插件的支持</li>
<li>改进redis的<code>get</code>方法</li>
<li>改进Request类的<code>host</code>方法</li>
</ul>
<p><code>5.0.11可以无缝升级到5.0.12。</code></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li><a href="http://www.thinkphp.cn/down/1079.html" target="_blank" rel="external">核心版</a></li>
<li><a href="http://www.thinkphp.cn/down/1080.html" target="_blank" rel="external">完整版</a></li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>官方完全开发手册内容已经同步更新 <a href="http://www.kancloud.cn/manual/thinkphp5" target="_blank" rel="external">完全开发手册</a> <a href="http://www.kancloud.cn/special/thinkphp5_quickstart" target="_blank" rel="external">官方快速入门系列</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;V5.1.0版本是继5.0版本之后又一个重大版本，ThinkPHP5.1在5.0的基础上对底层架构做了进一步的改进，引入新特性，并提升版本要求。&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://www.iooeo.com/categories/PHP/ThinkPHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://www.iooeo.com/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>Yii2  molde模型相关使用技巧</title>
    <link href="http://www.iooeo.com/2017/11/03/Yii2-molde%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.iooeo.com/2017/11/03/Yii2-molde模型相关使用技巧/</id>
    <published>2017-11-03T01:35:51.000Z</published>
    <updated>2017-11-03T01:33:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理一些 Yii2 Model模型在开发中常用到的一些方法我技巧。<br><code>模型是 MVC 模式中的一部分， 是代表业务数据、规则和逻辑的对象。</code><br><a id="more"></a></p>
<h2 id="获取查询-SQL"><a href="#获取查询-SQL" class="headerlink" title="获取查询 SQL"></a>获取查询 SQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$query = User::find()-&gt;where([&apos;like&apos;, &apos;name&apos;, &apos;ewan%&apos;, false]);</div><div class="line"></div><div class="line">$commandQuery = clone $query;</div><div class="line">// SELECT * FROM `user` WHERE `name` LIKE &apos;ewan%&apos;</div><div class="line">echo $commandQuery-&gt;createCommand()-&gt;getRawSql();</div></pre></td></tr></table></figure>
<h2 id="简单查询技巧"><a href="#简单查询技巧" class="headerlink" title="简单查询技巧"></a>简单查询技巧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">where(): 添加查询条件。</div><div class="line">select(): 添加查询字段。</div><div class="line">with(): 该查询应执行的关系列表。</div><div class="line">indexBy(): 根据索引的列的名称查询结果。</div><div class="line">asArray(): 以数组的形式返回每条记录。</div><div class="line">orderBy(): 按指定字段排序。</div><div class="line"></div><div class="line">User::find()-&gt;one();	// 返回一条数据，返回对象；</div><div class="line">User::find()-&gt;column();	// 返回查询结果中的第一列的值,返回数组；</div><div class="line">User::find()-&gt;scalar();	// 返回查询结果的第一行中的第一列的值；</div><div class="line">User::find()-&gt;all();	// 返回所有记录数据；</div><div class="line">User::find()-&gt;count();	// 返回记录的数量；</div><div class="line">User::find()-&gt;sum(&apos;num&apos;);	// 返回指定字段（&apos;num&apos;）的总和；</div><div class="line">User::find()-&gt;average(&apos;num&apos;);	// 返回指定字段（&apos;num&apos;）的平均值；</div><div class="line">User::find()-&gt;min(&apos;num&apos;);	// 返回指定字段（&apos;num&apos;）的最小值；</div><div class="line">User::find()-&gt;max(&apos;num&apos;);	// 返回指定字段（&apos;num&apos;）的最大值；</div><div class="line">User::find()-&gt;exists();	// 返回一个值，该值指示查询结果是否有数据；</div></pre></td></tr></table></figure>
<p>关联查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User::hasOne()：返回对应关系的单条记录</div><div class="line">User::hasMany()：返回对应关系的多条记录</div></pre></td></tr></table></figure></p>
<h2 id="模型中事务处理"><a href="#模型中事务处理" class="headerlink" title="模型中事务处理"></a>模型中事务处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Yii::$app-&gt;db-&gt;transaction(function() &#123;</div><div class="line">    $order = new Order($customer);</div><div class="line">    $order-&gt;save();</div><div class="line">    $order-&gt;addItems($items);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><p>批量插入的问题，已经写了一篇<a href="http://www.iooeo.com/2017/07/21/Yii2-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/">《Yii2 批量插入》</a>,点击链接查看即可。</p>
<h2 id="表单验证两个字段选取一个"><a href="#表单验证两个字段选取一个" class="headerlink" title="表单验证两个字段选取一个"></a>表单验证两个字段选取一个</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public function rules()</div><div class="line">&#123;</div><div class="line">    return [</div><div class="line">        [[&apos;card_id&apos;, &apos;card_code&apos;], function ($attribute, $param) &#123; //至少要一个</div><div class="line">            if (empty($this-&gt;card_code) &amp;&amp; empty($this-&gt;card_id)) &#123;</div><div class="line">                $this-&gt;addError($attribute, &apos;card_id/card_code至少要填一个&apos;);</div><div class="line">            &#125;</div><div class="line">        &#125;, &apos;skipOnEmpty&apos; =&gt; false],</div><div class="line">    ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Like-模糊查询"><a href="#Like-模糊查询" class="headerlink" title="Like 模糊查询"></a>Like 模糊查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$query = User::find()-&gt;where([&apos;LIKE&apos;, &apos;name&apos;, &apos;ad%&apos;, false]); // SELECT * FROM `user` WHERE `name` LIKE &apos;ad%&apos;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天整理一些 Yii2 Model模型在开发中常用到的一些方法我技巧。&lt;br&gt;&lt;code&gt;模型是 MVC 模式中的一部分， 是代表业务数据、规则和逻辑的对象。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/categories/PHP/Yii2/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>Yii2 2.0.13 发布，高性能 PHP 框架</title>
    <link href="http://www.iooeo.com/2017/11/03/Yii2-2-0-13-%E5%8F%91%E5%B8%83%EF%BC%8C%E9%AB%98%E6%80%A7%E8%83%BD-PHP-%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.iooeo.com/2017/11/03/Yii2-2-0-13-发布，高性能-PHP-框架/</id>
    <published>2017-11-03T01:21:35.000Z</published>
    <updated>2017-11-03T01:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Yii2 2.0.13 发布了。Yii 2 完全根据 Yii 1.1 版本重写，后者是最流行的 PHP 框架之一。Yii 2 继承了 Yii 的简洁、快速、和高扩展性。Yii 2 需要 PHP 5.4，并且拥有现代 Web 应用开发中最好的实例和协议。<br><a id="more"></a></p>
<h2 id="主要更新内容："><a href="#主要更新内容：" class="headerlink" title="主要更新内容："></a>主要更新内容：</h2><ul>
<li>yii\web\DbSession 现依靠错误处理程序来显示错误。</li>
<li>允许移动任何大小的名称，但长度限制在 180 个字符</li>
<li>日志消息时间精确到毫秒</li>
</ul>
<h2 id="更新详情："><a href="#更新详情：" class="headerlink" title="更新详情："></a>更新详情：</h2><p><a href="http://www.yiiframework.com/news/149/yii-2-0-13-is-released/" target="_blank" rel="external">详情链接</a></p>
<h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><ul>
<li><a href="https://github.com/yiisoft/yii2/releases/download/2.0.13/yii-advanced-app-2.0.13.tgz" target="_blank" rel="external">yii-advanced-app-2.0.13.tgz</a></li>
<li><a href="https://github.com/yiisoft/yii2/releases/download/2.0.13/yii-basic-app-2.0.13.tgz" target="_blank" rel="external">yii-basic-app-2.0.13.tgz</a></li>
<li><a href="https://github.com/yiisoft/yii2/archive/2.0.13.zip" target="_blank" rel="external">Source code (zip)</a></li>
<li><a href="https://github.com/yiisoft/yii2/archive/2.0.13.tar.gz" target="_blank" rel="external">Source code (tar.gz)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yii2 2.0.13 发布了。Yii 2 完全根据 Yii 1.1 版本重写，后者是最流行的 PHP 框架之一。Yii 2 继承了 Yii 的简洁、快速、和高扩展性。Yii 2 需要 PHP 5.4，并且拥有现代 Web 应用开发中最好的实例和协议。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/categories/PHP/Yii2/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Yii2" scheme="http://www.iooeo.com/tags/Yii2/"/>
    
  </entry>
  
  <entry>
    <title>CakePHP 3.5.5 发布，PHP 开发框架</title>
    <link href="http://www.iooeo.com/2017/11/03/CakePHP-3-5-5-%E5%8F%91%E5%B8%83%EF%BC%8CPHP-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.iooeo.com/2017/11/03/CakePHP-3-5-5-发布，PHP-开发框架/</id>
    <published>2017-11-03T01:15:48.000Z</published>
    <updated>2017-11-03T01:20:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>CakePHP 3.5.5 发布了。CakePHP 是一个运用了诸如 ActiveRecord、Association Data Mapping、Front Controller 和 MVC 等著名设计模式的快速开发框架。该项目主要目标是提供一个可以让各种层次的 PHP 开发人员快速地开发出健壮的 Web 应用，而又不失灵活性。<br><a id="more"></a></p>
<h2 id="更新内容："><a href="#更新内容：" class="headerlink" title="更新内容："></a>更新内容：</h2><ul>
<li>SQLServer no longer reports double column lengths for NVARCHAR and NCHAR columns.</li>
<li>IntegrationTestSuite::enableCsrfToken() no longer emits errors when the  POST body is a string.</li>
<li>Response::getType() has been added as a replacement for  Response::type().</li>
<li>Network\Socket now supports explicit use of TLS1.1 and 1.2. Support for  SSL2 is deprecated and will be removed in 4.0.0.</li>
<li>IntegrationTestCase::assertResponseCode() now allows custom messages to be  set.</li>
<li>Cake\Http\Client\FormData::addFile() now adds parts as documented.</li>
<li>Router::$initialized is deprecated. As we migrate to routes being loaded  via middleware this property will no longer be in use.</li>
<li>TableSchema now provides more succinct debug information.</li>
</ul>
<p>更多内容请查看 <a href="https://github.com/cakephp/cakephp/compare/3.5.4...3.5.5" target="_blank" rel="external">changelog</a></p>
<h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><ul>
<li><a href="https://github.com/cakephp/cakephp/releases/download/3.5.5/cakephp-3-5-5.zip" target="_blank" rel="external">cakephp-3-5-5.zip</a></li>
<li><a href="https://github.com/cakephp/cakephp/archive/3.5.5.zip" target="_blank" rel="external">Source code (zip)</a></li>
<li><a href="https://github.com/cakephp/cakephp/archive/3.5.5.tar.gz" target="_blank" rel="external">Source code (tar.gz)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CakePHP 3.5.5 发布了。CakePHP 是一个运用了诸如 ActiveRecord、Association Data Mapping、Front Controller 和 MVC 等著名设计模式的快速开发框架。该项目主要目标是提供一个可以让各种层次的 PHP 开发人员快速地开发出健壮的 Web 应用，而又不失灵活性。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="CakePHP" scheme="http://www.iooeo.com/tags/CakePHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP 7.2.0 RC3 发布，bug 修复版本</title>
    <link href="http://www.iooeo.com/2017/09/28/PHP-7-2-0-RC3-%E5%8F%91%E5%B8%83%EF%BC%8Cbug-%E4%BF%AE%E5%A4%8D%E7%89%88%E6%9C%AC/"/>
    <id>http://www.iooeo.com/2017/09/28/PHP-7-2-0-RC3-发布，bug-修复版本/</id>
    <published>2017-09-28T08:30:41.000Z</published>
    <updated>2017-09-28T08:34:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>PHP 7.2.0 RC3 发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下：<br><a id="more"></a></p>
<h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><ul>
<li>Fixed bug #75241 (Null pointer dereference in zend_mm_alloc_small()). (Laruence)</li>
<li>Fixed bug #74878 (Data race in ZTS builds). (Nikita, Dmitry)</li>
<li>Fixed bug #75236 (infinite loop when printing an error-message). (Andrea)</li>
<li>Fixed bug #75252 (Incorrect token formatting on two parse errors in one request). (Nikita)</li>
</ul>
<h3 id="FPM"><a href="#FPM" class="headerlink" title="FPM:"></a>FPM:</h3><ul>
<li>Fixed bug #75212 (php_value acts like php_admin_value). (Remi)</li>
</ul>
<h3 id="MySQLi"><a href="#MySQLi" class="headerlink" title="MySQLi:"></a>MySQLi:</h3><ul>
<li>Fixed bug #75018 (Data corruption when reading fields of bit type). (Anatol)</li>
</ul>
<h3 id="Opcache"><a href="#Opcache" class="headerlink" title="Opcache:"></a>Opcache:</h3><ul>
<li>Fixed bug #75230 (Invalid opcode 49/1/8 using opcache). (Laruence)</li>
</ul>
<h3 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE:"></a>PCRE:</h3><ul>
<li>Fixed bug ##75223 (PCRE JIT broken in 7.2). (Dmitry)</li>
</ul>
<h3 id="PDO-mysql"><a href="#PDO-mysql" class="headerlink" title="PDO_mysql:"></a>PDO_mysql:</h3><ul>
<li>Fixed bug #75177 (Type ‘bit’ is fetched as unexpected string). (Anatol)</li>
</ul>
<h3 id="SPL"><a href="#SPL" class="headerlink" title="SPL:"></a>SPL:</h3><ul>
<li>Fixed bug #73629 (SplDoublyLinkedList::setIteratorMode masks intern flags). (J. Jeising, cmb)</li>
</ul>
<h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h3><p><a href="https://downloads.php.net/~remi/" target="_blank" rel="external">https://downloads.php.net/~remi/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP 7.2.0 RC3 发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下：&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP 7.0.24 和 7.1.10 正式发布，多项内容修复</title>
    <link href="http://www.iooeo.com/2017/09/27/PHP-7-0-24-%E5%92%8C-7-1-10-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E5%A4%9A%E9%A1%B9%E5%86%85%E5%AE%B9%E4%BF%AE%E5%A4%8D/"/>
    <id>http://www.iooeo.com/2017/09/27/PHP-7-0-24-和-7-1-10-正式发布，多项内容修复/</id>
    <published>2017-09-27T05:33:45.000Z</published>
    <updated>2017-09-27T05:41:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>PHP 7.0.24 和 7.1.10 正式发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下：<br><a id="more"></a></p>
<h2 id="PHP-7-1-10"><a href="#PHP-7-1-10" class="headerlink" title="PHP 7.1.10"></a>PHP 7.1.10</h2><h3 id="Core"><a href="#Core" class="headerlink" title="Core:"></a>Core:</h3><ul>
<li>Fixed bug #75042 (run-tests.php issues with EXTENSION block). (John Boehr)</li>
</ul>
<h3 id="BCMath"><a href="#BCMath" class="headerlink" title="BCMath:"></a>BCMath:</h3><ul>
<li>Fixed bug #44995 (bcpowmod() fails if scale != 0). (cmb)</li>
<li>Fixed bug #46781 (BC math handles minus zero incorrectly). (cmb)</li>
<li>Fixed bug #54598 (bcpowmod() may return 1 if modulus is 1). (okano1220, cmb)</li>
<li>Fixed bug #75178 (bcpowmod() misbehaves for non-integer base or modulus). (cmb)</li>
</ul>
<h3 id="CLI-server"><a href="#CLI-server" class="headerlink" title="CLI server:"></a>CLI server:</h3><ul>
<li>Fixed bug #70470 (Built-in server truncates headers spanning over TCP packets). (bouk)</li>
</ul>
<h3 id="CURL"><a href="#CURL" class="headerlink" title="CURL:"></a>CURL:</h3><ul>
<li>Fixed bug #75093 (OpenSSL support not detected). (Remi)</li>
</ul>
<h3 id="GD"><a href="#GD" class="headerlink" title="GD:"></a>GD:</h3><ul>
<li>Fixed bug #75124 (gdImageGrayScale() may produce colors). (cmb)</li>
<li>Fixed bug #75139 (libgd/gd_interpolation.c:1786: suspicious if ?). (cmb)</li>
</ul>
<h3 id="Gettext"><a href="#Gettext" class="headerlink" title="Gettext:"></a>Gettext:</h3><ul>
<li>Fixed bug #73730 (textdomain(null) throws in strict mode). (cmb)</li>
</ul>
<h3 id="Intl"><a href="#Intl" class="headerlink" title="Intl:"></a>Intl:</h3><ul>
<li>Fixed bug #75090 (IntlGregorianCalendar doesn’t have constants from parentclass). (tpunt)</li>
<li>Fixed bug #75193 (segfault in collator_convert_object_to_string). (Remi)</li>
</ul>
<h3 id="PDO-OCI"><a href="#PDO-OCI" class="headerlink" title="PDO_OCI:"></a>PDO_OCI:</h3><ul>
<li>Fixed bug #74631 (PDO_PCO with PHP-FPM: OCI environment initialized before PHP-FPM sets it up). (Ingmar Runge)</li>
</ul>
<h3 id="SPL"><a href="#SPL" class="headerlink" title="SPL:"></a>SPL:</h3><ul>
<li>Fixed bug #75155 (AppendIterator::append() is broken when appending another AppendIterator). (Nikita)</li>
<li>Fixed bug #75173 (incorrect behavior of AppendIterator::append in foreach loop). (jhdxr)</li>
</ul>
<h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard:"></a>Standard:</h3><ul>
<li>Fixed bug #75152 (signed integer overflow in parse_iv). (Laruence)</li>
<li>Fixed bug #75097 (gethostname fails if your host name is 64 chars long). (Andrea)</li>
</ul>
<h2 id="PHP-7-0-24"><a href="#PHP-7-0-24" class="headerlink" title="PHP 7.0.24"></a>PHP 7.0.24</h2><h3 id="Core-1"><a href="#Core-1" class="headerlink" title="Core:"></a>Core:</h3><ul>
<li>Fixed bug #75042 (run-tests.php issues with EXTENSION block). (John Boehr)</li>
</ul>
<h3 id="BCMath-1"><a href="#BCMath-1" class="headerlink" title="BCMath:"></a>BCMath:</h3><ul>
<li>Fixed bug #44995 (bcpowmod() fails if scale != 0). (cmb)</li>
<li>Fixed bug #46781 (BC math handles minus zero incorrectly). (cmb)</li>
<li>Fixed bug #54598 (bcpowmod() may return 1 if modulus is 1). (okano1220, cmb)</li>
<li>Fixed bug #75178 (bcpowmod() misbehaves for non-integer base or modulus). (cmb)</li>
</ul>
<h3 id="CLI-server-1"><a href="#CLI-server-1" class="headerlink" title="CLI server:"></a>CLI server:</h3><ul>
<li>Fixed bug #70470 (Built-in server truncates headers spanning over TCP packets). (bouk)</li>
</ul>
<h3 id="CURL-1"><a href="#CURL-1" class="headerlink" title="CURL:"></a>CURL:</h3><ul>
<li>Fixed bug #75093 (OpenSSL support not detected). (Remi)</li>
</ul>
<h3 id="GD-1"><a href="#GD-1" class="headerlink" title="GD:"></a>GD:</h3><ul>
<li>Fixed bug #75124 (gdImageGrayScale() may produce colors). (cmb)</li>
<li>Fixed bug #75139 (libgd/gd_interpolation.c:1786: suspicious if ?). (cmb)</li>
</ul>
<h3 id="Gettext-1"><a href="#Gettext-1" class="headerlink" title="Gettext:"></a>Gettext:</h3><ul>
<li>Fixed bug #73730 (textdomain(null) throws in strict mode). (cmb)</li>
</ul>
<h3 id="Intl-1"><a href="#Intl-1" class="headerlink" title="Intl:"></a>Intl:</h3><ul>
<li>Fixed bug #75090 (IntlGregorianCalendar doesn’t have constants from parent class). (tpunt)</li>
<li>Fixed bug #75193 (segfault in collator_convert_object_to_string). (Remi)</li>
</ul>
<h3 id="PDO-OCI-1"><a href="#PDO-OCI-1" class="headerlink" title="PDO_OCI:"></a>PDO_OCI:</h3><ul>
<li>Fixed bug #74631 (PDO_PCO with PHP-FPM: OCI environment initialized before PHP-FPM sets it up). (Ingmar Runge)</li>
</ul>
<h3 id="SPL-1"><a href="#SPL-1" class="headerlink" title="SPL:"></a>SPL:</h3><ul>
<li>Fixed bug #75173 (incorrect behavior of AppendIterator::append in foreach loop). (jhdxr)</li>
</ul>
<h3 id="Standard-1"><a href="#Standard-1" class="headerlink" title="Standard:"></a>Standard:</h3><ul>
<li>Fixed bug #75097 (gethostname fails if your host name is 64 chars long). (Andrea)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP 7.0.24 和 7.1.10 正式发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下：&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text 3.0 Build 3143 发布，全新 UI 主题</title>
    <link href="http://www.iooeo.com/2017/09/15/Sublime-Text-3-0-Build-3143-%E5%8F%91%E5%B8%83%EF%BC%8C%E5%85%A8%E6%96%B0-UI-%E4%B8%BB%E9%A2%98/"/>
    <id>http://www.iooeo.com/2017/09/15/Sublime-Text-3-0-Build-3143-发布，全新-UI-主题/</id>
    <published>2017-09-15T01:40:44.000Z</published>
    <updated>2017-09-15T01:45:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>还记得我刚学 PHP 编程的时候，老师强烈推荐了Sublime，当时因为正处于测试阶段，然后就种破解，现在3.0终于发布了，欠的船票该补上了。<br><a id="more"></a><br>Sublime Text 3.0 Build 3143 发布了。Sublime Text 3 比 Sublime Text 2 快得多。 虽然它比 2 的安装包更大，但它的启动速度更快，打开文件的速度更快，滚动效率更高。 </p>
<p>与最后一个 beta 版相比，3.0 带来了新的 UI 主题，新配色方案和新图标。其他改进如：</p>
<ul>
<li>改进大型语法的高亮</li>
<li>支持 Windows 触摸输入</li>
<li>支持 MacOS 上的 Touch Bar</li>
<li>添加适用于 Linux 的 apt / yum / pacman 存储库</li>
<li>提升 Goto Definition 的性能</li>
</ul>
<p><img src="http://ogpq2zwg5.bkt.clouddn.com/%20Sublime.png" alt="Sublime"><br>了解更多 3.0 版的更新内容，请参阅<a href="https://www.sublimetext.com/blog/articles/sublime-text-3-point-0" target="_blank" rel="external">发布新闻</a>和<a href="https://www.sublimetext.com/3" target="_blank" rel="external">完整版发布说明</a>。</p>
<p>下载地址：</p>
<ul>
<li><a href="https://www.sublimetext.com/3" target="_blank" rel="external">https://www.sublimetext.com/3</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还记得我刚学 PHP 编程的时候，老师强烈推荐了Sublime，当时因为正处于测试阶段，然后就种破解，现在3.0终于发布了，欠的船票该补上了。&lt;br&gt;
    
    </summary>
    
      <category term="Sublime" scheme="http://www.iooeo.com/categories/Sublime/"/>
    
    
      <category term="Sublime" scheme="http://www.iooeo.com/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>PHP 7.2.0 RC2 发布，bug 修复版本</title>
    <link href="http://www.iooeo.com/2017/09/13/PHP-7-2-0-RC2-%E5%8F%91%E5%B8%83%EF%BC%8Cbug-%E4%BF%AE%E5%A4%8D%E7%89%88%E6%9C%AC/"/>
    <id>http://www.iooeo.com/2017/09/13/PHP-7-2-0-RC2-发布，bug-修复版本/</id>
    <published>2017-09-13T01:22:03.000Z</published>
    <updated>2017-09-13T01:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>PHP 7.2.0 RC2 发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下：<br><a id="more"></a><br> 14 Sep 2017, PHP 7.2.0RC2</p>
<ul>
<li><p>Core:<br>. Fixed Bug #75142 (buildcheck.sh check for autoconf version needs to be updated for v2.64). (zizzy at zizzy dot net, Remi)</p>
</li>
<li><p>BCMath:<br>. Fixed bug #44995 (bcpowmod() fails if scale != 0). (cmb)<br>. Fixed bug #46781 (BC math handles minus zero incorrectly). (cmb)<br>. Fixed bug #54598 (bcpowmod() may return 1 if modulus is 1). (okano1220, cmb)<br>. Fixed bug #75178 (bcpowmod() misbehaves for non-integer base or modulus). (cmb)</p>
</li>
<li><p>CLI server:<br>. Fixed bug #70470 (Built-in server truncates headers spanning over TCP packets). (bouk)</p>
</li>
<li><p>Date:<br>. Fixed bug #75149 (redefinition of typedefs ttinfo and t1info). (Remi)</p>
</li>
<li><p>GD:<br>. Fixed bug #75139 (libgd/gd_interpolation.c:1786: suspicious if ?). (cmb)</p>
</li>
<li><p>Intl:<br>.  Fixed bug #75193 (segfault in collator_convert_object_to_string). (Remi)</p>
</li>
<li><p>Gettext:<br>. Fixed bug #73730 (textdomain(null) throws in strict mode). (cmb)</p>
</li>
<li><p>Opcache<br>. Fixed incorect constant conditional jump elimination. (Dmitry)</p>
</li>
<li><p>OpenSSL<br>. Automatically load OpenSSL configuration file. (Jakub Zelenka)</p>
</li>
<li><p>SPL:<br>. Fixed bug #75155 (AppendIterator::append() is broken when appending another AppendIterator). (Nikita)<br>. Fixed bug #75173 (incorrect behavior of AppendIterator::append in foreach loop). (jhdxr)</p>
</li>
<li><p>Standard:<br>. Fixed bug #75152 (signed integer overflow in parse_iv). (Laruence)<br>. Fixed bug #75170 (mt_rand() bias on 64-bit machines). (Nikita)</p>
</li>
<li><p>ZIP:<br>. Fixed bug #75143 (new method setEncryptionName() seems not to exist in ZipArchive). (Anatol)</p>
</li>
</ul>
<p>下载地址：<br><a href="https://downloads.php.net/~pollita/" target="_blank" rel="external">https://downloads.php.net/~pollita/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP 7.2.0 RC2 发布了。PHP（PHP：Hypertext Preprocessor）是一种在电脑上执行的脚本语言，主要是用途在于处理动态网页，也包含了命令列执行接口（command line interface），或者产生图形使用者接口（GUI）程式。改进日志如下：&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP V5.0.11 暨 5.1.0 RC1 版本发布: 包含安全更新</title>
    <link href="http://www.iooeo.com/2017/09/11/ThinkPHP-V5-0-11-%E6%9A%A8-5-1-0-RC1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83-%E5%8C%85%E5%90%AB%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0/"/>
    <id>http://www.iooeo.com/2017/09/11/ThinkPHP-V5-0-11-暨-5-1-0-RC1-版本发布-包含安全更新/</id>
    <published>2017-09-11T08:08:53.000Z</published>
    <updated>2017-09-11T08:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>V5.1.0RC1版本是继5.0版本之后又一个重大版本，ThinkPHP5.1在5.0的基础上对底层架构做了进一步的改进，引入新特性，并提升版本要求。<br><a id="more"></a><br>ThinkPHP5.1运行环境要求PHP5.6+，虽然不支持5.0的无缝升级，但升级过程并不复杂（请参考<a href="https://www.kancloud.cn/manual/thinkphp5_1/354155" target="_blank" rel="external">升级指导</a>）</p>
<h2 id="主要新特性"><a href="#主要新特性" class="headerlink" title="主要新特性"></a>主要新特性</h2><ul>
<li>引入容器和Facade支持</li>
<li>依赖注入完善和支持更多场景</li>
<li>重构的（对象化）路由</li>
<li>配置和路由目录独立</li>
<li>取消系统常量</li>
<li>助手函数增强</li>
<li>类库别名机制</li>
<li>模型和数据库增强</li>
<li>验证类增强</li>
<li>模板引擎改进</li>
<li>支持PSR-3日志规范</li>
</ul>
<p>下载<a href="http://www.thinkphp.cn/down/1041.html" target="_blank" rel="external">核心版本</a></p>
<h2 id="目前5-1版本尚处于RC阶段，仅供学习参考，请勿用于商业项目！"><a href="#目前5-1版本尚处于RC阶段，仅供学习参考，请勿用于商业项目！" class="headerlink" title="目前5.1版本尚处于RC阶段，仅供学习参考，请勿用于商业项目！"></a>目前5.1版本尚处于RC阶段，仅供学习参考，请勿用于商业项目！</h2><p>5.1完全开发手册：<a href="https://www.kancloud.cn/manual/thinkphp5_1/353946" target="_blank" rel="external">https://www.kancloud.cn/manual/thinkphp5_1/353946</a><br>V5.0.11版本主要为BUG修正和改进，并且包含一个安全更新，可以从5.0.10无缝升级，推荐更新，主要改进如下：</p>
<h2 id="主要更新"><a href="#主要更新" class="headerlink" title="主要更新"></a>主要更新</h2><ul>
<li>完善缓存驱动；</li>
<li>改进数据库查询；</li>
<li>改进URL生成类；</li>
<li>缓存有效期支持指定过期时间；</li>
</ul>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="数据库和模型"><a href="#数据库和模型" class="headerlink" title="[数据库和模型]"></a>[数据库和模型]</h3><ul>
<li>改进数据库驱动类</li>
<li>改进<code>group</code>方法的字段关键字冲突</li>
<li>修正聚合查询返回null的问题</li>
<li>改进Db类的强制重连</li>
<li>改进关联的属性绑定</li>
<li>修正事务的断线重连</li>
<li>修正对象的条件查询</li>
<li>Db类增加<code>clear</code>方法</li>
<li>改进数组查询条件中的<code>null</code>查询</li>
<li>改进Query类的<code>chunk</code>方法支持排序设置</li>
<li>改进HasOne和HasMany关联的<code>has</code>方法</li>
<li>改进软删除的关联删除</li>
<li>改进一个字段多次查询条件</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="[其它]"></a>[其它]</h3><ul>
<li>缓存有效期支持指定过期时间（<code>DateTime</code>）；</li>
<li>改进Url生成对端口号的支持</li>
<li>改进<code>RouteNotFound</code>异常提示</li>
<li>改进路由分组的全局完整路由匹配</li>
<li>修正部分验证规则的错误提示问题</li>
<li>支持数据集和模型的xml响应输出</li>
<li>改进模板的三元运算标签</li>
<li>改进控制器不存在的错误提示</li>
<li>input助手函数支持<code>route</code>变量获取</li>
<li>支持在配置文件中读取额外配置参数</li>
<li>完善分页类</li>
<li>修复Trait命名空间重复问题</li>
<li>修正Request类的env方法</li>
<li>优先使用Cookie中的多语言设置</li>
<li>获取缓存标签的时候过滤无效的缓存标识</li>
<li>修正路由批量注册的一个BUG</li>
<li><code>exception_handle</code>配置参数支持使用闭包定义<code>render</code>处理</li>
<li>请求缓存支持缓存标签设置</li>
<li>缓存类<code>remember</code>方法增加并发锁定机制</li>
<li>改进上传类对<code>swf</code>的支持</li>
<li>改进Session类的<code>prefix</code>方法</li>
</ul>
<p><code>5.0.10可以无缝升级到5.0.11，升级完成后务必清空你的缓存目录。</code></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>OSChina：<br>应用仓库：<a href="http://git.oschina.net/liu21st/thinkphp5" target="_blank" rel="external">http://git.oschina.net/liu21st/thinkphp5</a><br>核心仓库：<a href="http://git.oschina.net/liu21st/framework" target="_blank" rel="external">http://git.oschina.net/liu21st/framework</a><br>官网下载：<a href="http://www.thinkphp.cn/down/1039.html" target="_blank" rel="external">核心版</a> <a href="http://www.thinkphp.cn/down/1040.html" target="_blank" rel="external">完整版</a></p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>官方完全开发手册内容已经同步更新 <a href="http://www.kancloud.cn/manual/thinkphp5" target="_blank" rel="external">完全开发手册</a> <a href="http://www.kancloud.cn/special/thinkphp5_quickstart" target="_blank" rel="external">官方快速入门系列</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;V5.1.0RC1版本是继5.0版本之后又一个重大版本，ThinkPHP5.1在5.0的基础上对底层架构做了进一步的改进，引入新特性，并提升版本要求。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://www.iooeo.com/categories/PHP/ThinkPHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://www.iooeo.com/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>git  修改远程URL</title>
    <link href="http://www.iooeo.com/2017/09/04/git-%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8BURL/"/>
    <id>http://www.iooeo.com/2017/09/04/git-修改远程URL/</id>
    <published>2017-09-04T07:52:04.000Z</published>
    <updated>2017-09-11T06:42:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用的临时域名，没有实名制，暂时不能用了，项目急着上线，那只有修改远程 URL，使用 IP 访问了。<br><a id="more"></a><br>查看当前 remote url:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div></pre></td></tr></table></figure></p>
<p>修改 remote url:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote set-url origin  http://cola@101.81.167.17:10020/r/project.git</div></pre></td></tr></table></figure></p>
<p>完成，可以拉代码了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用的临时域名，没有实名制，暂时不能用了，项目急着上线，那只有修改远程 URL，使用 IP 访问了。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://www.iooeo.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.iooeo.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 5.5 LTS 正式发布，Whoops Package 回归</title>
    <link href="http://www.iooeo.com/2017/08/31/Laravel-5-5-LTS-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8CWhoops-Package-%E5%9B%9E%E5%BD%92/"/>
    <id>http://www.iooeo.com/2017/08/31/Laravel-5-5-LTS-正式发布，Whoops-Package-回归/</id>
    <published>2017-08-31T00:41:37.000Z</published>
    <updated>2017-08-31T00:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ogpq2zwg5.bkt.clouddn.com/235826_LPCu_2896879.png" alt="Laravel 5.5"><br>Laravel 5.5 已发布，这是最新的长期支持版本（LTS），包含多项改进。<br>发行说明：<a href="https://laravel-news.com/laravel-5-5" target="_blank" rel="external">https://laravel-news.com/laravel-5-5</a></p>
<h2 id="部分亮点"><a href="#部分亮点" class="headerlink" title="部分亮点"></a>部分亮点</h2><h3 id="Whoops-Package-回归"><a href="#Whoops-Package-回归" class="headerlink" title="Whoops Package 回归"></a>Whoops Package 回归</h3><p>filp / whoops package 曾经出现在 V4 系列，用于在调试时提供优雅的堆栈跟踪，是一个错误处理框架。Laravel 5.5 版本 Whoops Package 正式回归。<br><img src="http://ogpq2zwg5.bkt.clouddn.com/000334_DCvs_2896879.png" alt="Whoops Package"></p>
<h3 id="Exception-Rendering"><a href="#Exception-Rendering" class="headerlink" title="Exception Rendering"></a>Exception Rendering</h3><p>5.5 无需额外的逻辑，可直接抛出异常，并进行响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">// throw new TerribleSongException($song) in a controller...</div><div class="line"></div><div class="line">namespace App\Exceptions;</div><div class="line"></div><div class="line">use App\Song;</div><div class="line"></div><div class="line">class TerribleSongException extends \Exception</div><div class="line">&#123;</div><div class="line">    /**</div><div class="line">     * @var \App\Song</div><div class="line">     */</div><div class="line">    protected $song;</div><div class="line"></div><div class="line">    public function __construct(Song $song)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;song = $song;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param \Illuminate\Http\Request $request</div><div class="line">     */</div><div class="line">    public function render($request)</div><div class="line">    &#123;</div><div class="line">        return response(&quot;The song &apos;&#123;$this-&gt;song-&gt;title&#125;&apos; by &apos;&#123;$this-&gt;song-&gt;artist&#125;&apos; is terrible.&quot;);    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义验证规则对象"><a href="#自定义验证规则对象" class="headerlink" title="自定义验证规则对象"></a>自定义验证规则对象</h3><p>Laravel 5.5 带来新的自定义验证规则对象，以此作为 Validator::extend 的替代方法。新规则的逻辑更一目了然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">namespace App\Rules;</div><div class="line"></div><div class="line">use Illuminate\Contracts\Validation\Rule;</div><div class="line"></div><div class="line">class CowbellValidationRule implements Rule</div><div class="line">&#123;</div><div class="line">    public function passes($attribute, $value)</div><div class="line">    &#123;</div><div class="line">        return $value &gt; 10;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function message()</div><div class="line">    &#123;</div><div class="line">        return &apos;:attribute needs more cowbell!&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用新规则后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">request()-&gt;validate([</div><div class="line">    &apos;cowbells&apos; =&gt; [new CowbellValidationRule],</div><div class="line">    &apos;more_cowbells&apos; =&gt; [function ($attribute, $value, $fail) &#123;</div><div class="line">        if ($value &lt;= 10) &#123;</div><div class="line">            $fail(&apos;:attribute needs more cowbell!&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;]</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<h3 id="Blade-if-指令"><a href="#Blade-if-指令" class="headerlink" title="Blade::if () 指令"></a>Blade::if () 指令</h3><p>新的指令包括 @auth and @guest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@auth</div><div class="line">    Welcome &#123;&#123; user()-&gt;name &#125;&#125;!</div><div class="line">@endauth</div><div class="line"></div><div class="line">@guest</div><div class="line">    Welcome Guest!</div><div class="line">@endguest</div></pre></td></tr></table></figure></p>
<h3 id="新的迁移命令：Fresh"><a href="#新的迁移命令：Fresh" class="headerlink" title="新的迁移命令：Fresh"></a>新的迁移命令：Fresh</h3><p>新的 migrate:fresh 命令会直接删除所有的表，然后运行迁移。通常在开发过程中，你也只需删除表，获取新数据库，和运行迁移。</p>
<hr>
<p>更多细节请直接查看<a href="https://laravel-news.com/laravel-5-5" target="_blank" rel="external">发行说明</a><br>Laravel 5.5 更多链接：</p>
<ul>
<li>升级文档：<a href="https://laravel.com/docs/5.5" target="_blank" rel="external">https://laravel.com/docs/5.5</a></li>
<li>版本说明 <a href="https://laravel.com/docs/5.5/releases" target="_blank" rel="external">https://laravel.com/docs/5.5/releases</a></li>
<li>升级指南：<a href="https://laravel.com/docs/5.5/upgrade" target="_blank" rel="external">https://laravel.com/docs/5.5/upgrade</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ogpq2zwg5.bkt.clouddn.com/235826_LPCu_2896879.png&quot; alt=&quot;Laravel 5.5&quot;&gt;&lt;br&gt;Laravel 5.5 已发布，这是最新的长期支持版本（LTS），包含多项改进。&lt;br&gt;发行说
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Laravel" scheme="http://www.iooeo.com/categories/PHP/Laravel/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://www.iooeo.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>CRC16 For PHP</title>
    <link href="http://www.iooeo.com/2017/08/13/CRC16-For-PHP/"/>
    <id>http://www.iooeo.com/2017/08/13/CRC16-For-PHP/</id>
    <published>2017-08-13T01:06:54.000Z</published>
    <updated>2017-08-13T02:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着物联网技术的发展和普及，作为最好的语言 PHP 也难免会遇上与硬件设备数据对接的情况。在数据通信领域中有一种查错校验码，CRC。<br>在 PHP 官网上搜索了一下，只提供 CRC32 的相关的函数，关于 CRC16 我自己封装了一个方法用于校验计算。然后我将代码整理了一番，已发布到 GitHub，有需要的同学可以去看下，或许我们可以共同维护他。项目地址<a href="https://github.com/yangyiyuan/CRC16ForPHP" target="_blank" rel="external">CRC16ForPHP</a><br><a id="more"></a><br>具体实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function crc16Modbus($str)</div><div class="line">&#123;</div><div class="line">    $data = pack(&apos;H*&apos;, $str);</div><div class="line">    $crc = 0xFFFF;</div><div class="line">    for ($i = 0; $i &lt; strlen($data); $i++) &#123;</div><div class="line">        $crc ^= ord($data[$i]);</div><div class="line">        for ($j = 8; $j != 0; $j--) &#123;</div><div class="line">            if (($crc &amp; 0x0001) != 0) &#123;</div><div class="line">                $crc &gt;&gt;= 1;</div><div class="line">                $crc ^= 0xA001;</div><div class="line">            &#125; else $crc &gt;&gt;= 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sprintf(&apos;%04X&apos;, $crc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo crc16(&apos;010301180001&apos;).PHP_EOL;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着物联网技术的发展和普及，作为最好的语言 PHP 也难免会遇上与硬件设备数据对接的情况。在数据通信领域中有一种查错校验码，CRC。&lt;br&gt;在 PHP 官网上搜索了一下，只提供 CRC32 的相关的函数，关于 CRC16 我自己封装了一个方法用于校验计算。然后我将代码整理了一番，已发布到 GitHub，有需要的同学可以去看下，或许我们可以共同维护他。项目地址&lt;a href=&quot;https://github.com/yangyiyuan/CRC16ForPHP&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CRC16ForPHP&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="CRC16" scheme="http://www.iooeo.com/tags/CRC16/"/>
    
  </entry>
  
  <entry>
    <title>swoole TCP服务器心跳维持方案</title>
    <link href="http://www.iooeo.com/2017/08/04/swoole-TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BF%83%E8%B7%B3%E7%BB%B4%E6%8C%81%E6%96%B9%E6%A1%88/"/>
    <id>http://www.iooeo.com/2017/08/04/swoole-TCP服务器心跳维持方案/</id>
    <published>2017-08-04T06:40:30.000Z</published>
    <updated>2017-08-04T07:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>正常情况下客户端中断TCP连接时，会发送一个FIN包，进行4次断开握手来通知服务器。但一些异常情况下，如客户端突然断电断网或者网络异常，服务器可能无法得知客户端已断开连接。<br>尤其是移动网络，TCP连接非常不稳定，所以需要一套机制来保证服务器和客户端之间连接的有效性。<br><a id="more"></a><br>Swoole扩展本身内置了这种机制，开发者只需要配置一个参数即可启用。Swoole在每次收到客户端数据会记录一个时间戳，当客户端在一定时间内未向服务器端发送数据，那服务器会自动切断连接。<br>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set(array(</div><div class="line">    &apos;heartbeat_check_interval&apos; =&gt; 60,</div><div class="line">    &apos;heartbeat_idle_time&apos; =&gt; 300,</div><div class="line">));</div></pre></td></tr></table></figure></p>
<p>上面的设置就是每60秒侦测一次心跳，一个TCP连接如果在300秒内未向服务器端发送数据，将会被切断。当然我这个长连接，这样做是为了回收进程。</p>
<p>高级用法：<br>使用<code>swoole_server::heartbeat()</code>函数手工检测心跳是否到期。此函数会返回闲置时间超过<code>heartbeat_idle_time</code>的所有TCP连接。程序中可以将这些连接做一些操作，如发送数据或关闭连接。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正常情况下客户端中断TCP连接时，会发送一个FIN包，进行4次断开握手来通知服务器。但一些异常情况下，如客户端突然断电断网或者网络异常，服务器可能无法得知客户端已断开连接。&lt;br&gt;尤其是移动网络，TCP连接非常不稳定，所以需要一套机制来保证服务器和客户端之间连接的有效性。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole 粘包 EOF 包头+包尾</title>
    <link href="http://www.iooeo.com/2017/08/03/swoole-%E7%B2%98%E5%8C%85-EOF/"/>
    <id>http://www.iooeo.com/2017/08/03/swoole-粘包-EOF/</id>
    <published>2017-08-03T07:20:25.000Z</published>
    <updated>2017-08-03T09:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在跟硬件开发的小伙伴测试的时候发现了一个非常有趣的问题，即Client 每次请求，Server 端我返回相同信息，但是有时候会出现两次或多次返回的数据堆叠到一起的现象。开始我还以为我代码写的有问题，仔细看了一下代码没问题啊，终究还是要相信科学。<br><a id="more"></a><br><img src="http://ogpq2zwg5.bkt.clouddn.com/TCP%20%E7%B2%98%E5%8C%85.png" alt="tcp 粘包"><br>经我多方查证，原来我们的问题是 TCP 粘包问题，下面科普一下。</p>
<h2 id="TCP-粘包"><a href="#TCP-粘包" class="headerlink" title="TCP 粘包"></a>TCP 粘包</h2><h3 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h3><p>在讨论 TCP 粘包的问题前，我们先理解一下长连接和短连接。<br><code>长连接</code></p>
<blockquote>
<p>Client 与 Server 先建立通讯连接，连接建立后不断开， 然后再进行数据发送和接收。</p>
</blockquote>
<p><code>短连接</code></p>
<blockquote>
<p>Client 与 Server 每进行一次数据收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个Client连接一个Server。</p>
</blockquote>
<h3 id="什么是-TCP-粘包"><a href="#什么是-TCP-粘包" class="headerlink" title="什么是 TCP 粘包"></a>什么是 TCP 粘包</h3><p>TCP 粘包是指<em>发送方发送的若干包数据</em> 到 <em>接收方接收时粘成一包</em>，从接收缓冲区看，<em>后一包数据的头紧接着前一包数据的尾</em>。</p>
<h3 id="TCP-出现粘包的原因"><a href="#TCP-出现粘包的原因" class="headerlink" title="TCP 出现粘包的原因"></a>TCP 出现粘包的原因</h3><ul>
<li>发送方：发送方需要等缓冲区满才发送出去，造成粘包</li>
<li>接收方：接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>
<h3 id="什么时候需要处理粘包"><a href="#什么时候需要处理粘包" class="headerlink" title="什么时候需要处理粘包"></a>什么时候需要处理粘包</h3><p><code>不处理：</code></p>
<blockquote>
<ul>
<li>短连接，每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题。</li>
<li>如果发送数据无结构，如文件传输被分成多个分组发送，也不用考虑粘包。</li>
</ul>
</blockquote>
<p><code>需处理：</code></p>
<blockquote>
<p>双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：<code>good morning</code>、<code>good evening</code>，如果发送方连续发了两个包出去，接收方可能就回收到<code>`good morninggood evening</code>很明显不是我们想要，需要处理。</p>
</blockquote>
<h2 id="Swoole-处理粘包"><a href="#Swoole-处理粘包" class="headerlink" title="Swoole 处理粘包"></a>Swoole 处理粘包</h2><p>既然了解了为什么会出现粘包现象和什么时候需要处理粘包，那下边就是想办法解决了。很显然我的需求得处理，很幸运 Swoole 已经提供了怎么解决粘包问题的方案。</p>
<h3 id="EOF-结束协议"><a href="#EOF-结束协议" class="headerlink" title="EOF 结束协议"></a>EOF 结束协议</h3><p>之前我在翻阅 Swoole 文档过程中，在看到 Server 配置选项的时候，看到过<code>open_eof_check</code>、<code>open_eof_split</code>、<code>package_eof</code>…配置的时候，搂了两眼，感觉很深奥的样子，就一眼带过了。现在才知道它们是用来干嘛的。<br>EOF，即指每一个数据包的结尾加一个EOF标记，表示数据包的结束，但是如果你的数据本身含有EOF标记，那就会造成收到的数据包不完整，所以开启EOF支持后，应避免数据中含有EOF标记。<br>Server 的 <code>open_eof_check</code>设置为<code>true</code>时，打开EOF检测，此选项将检测客户端连接发来的数据，当数据包结尾是指定的EOF字符串时才会投递给Worker进程。否则会一直拼接数据包，直到超过缓存区或者超时才会中止。当出错时swoole底层会认为是恶意连接，丢弃数据并强制关闭连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">	&apos;open_eof_check&apos; =&gt; true, //打开EOF检测</div><div class="line">	&apos;package_eof&apos; =&gt; &quot;\r\n&quot;, //设置EOF</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>常见的Memcache/SMTP/POP等协议都是以<code>\r\n</code>结束的，就可以使用以上配置。开启后可以保证Worker进程一次性总是收到一个或者多个完整的数据包。<br>虽然Swoole 已经帮我在服务端做了 EOF 结束协议，但是你不能保证客户端会一次性发过来几条数据，这样会出现一次性接受多个数据包的问题，因为EOF检测不会从数据中间查找eof字符串，所以Worker进程可能会同时收到多个数据包，需要在应用层代码中自行explode(“\r\n”, $data) 来拆分数据包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public function onReceive($serv, $fd, $fromId, $data)</div><div class="line">&#123;</div><div class="line">    $datas = explode(&quot;\r\n&quot;, $data);</div><div class="line">    foreach ($datas as $data)</div><div class="line">    &#123;</div><div class="line">        if(!$data)&#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        echo &quot;Server received data: &#123;$data&#125;&quot; . PHP_EOL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然我们可以自己拆分数据，但是Swoole1.7.15版本增加了<code>open_eof_split</code>，支持从数据中查找EOF，并切分数据，那我们何乐而不为呐?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">	&apos;open_eof_check&apos; =&gt; true, //打开EOF检测</div><div class="line">    &apos;package_eof&apos; =&gt; &quot;\r\n&quot;, //设置EOF</div><div class="line">	&apos;open_eof_split&apos; =&gt; true,</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>配置成上面这样，我们就不用自己在应用层代码中自行 <code>explode()</code>了。</p>
<h3 id="发送长度-固定包头和包尾"><a href="#发送长度-固定包头和包尾" class="headerlink" title="发送长度 固定包头和包尾"></a>发送长度 固定包头和包尾</h3><p>发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。<br>在这种协议下，我们的数据包的组成就是包头+包体。其中包头就是包体长度的二进制形式。比如我们本来想向服务端发送一段数据 “Just a test.” 共12个字符，现在我们要发送的数据就应该是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pack(&apos;N&apos;, strlen(&quot;Just a test.&quot;)) . &quot;Just a test.&quot;</div></pre></td></tr></table></figure></p>
<p><code>pack()</code>函数是将数据打包成二进制字符串，也就是我们的包头部分。<br>这样的话 Server 收到一个数据包（可能是多个完整的数据包）之后，会先解出包头指定的数据长度，然后按照这个长度取出后面的数据，如果一次性收到多个数据包，依次循环，如此就能保证Worker进程可以一次性收到一个完整的数据包。<br>Swoole 为我们提供一下几个配置选项：</p>
<ul>
<li><code>open_length_check</code>：打开包长检测特性</li>
<li><code>package_length_type</code>：长度字段的类型，固定包头中用一个4字节或2字节表示包体长度，文章最后给出详细长度值的类型</li>
<li><code>package_length_offset</code>：从第几个字节开始是长度，比如包头长度为120字节，第10个字节为长度值，这里填入9（从0开始计数）</li>
<li><code>package_body_offset</code>：从第几个字节开始计算长度，比如包头为长度为120字节，第10个字节为长度值，包体长度为1000。如果长度包含包头，这里填入0，如果不包含包头，这里填入120</li>
<li><code>package_max_length</code>：最大允许的包长度。因为在一个请求包完整接收前，需要将所有数据保存在内存中，所以需要做保护。避免内存占用过大。</li>
</ul>
<p>具体配置就写这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">    &apos;open_length_check&apos;     =&gt; true,      // 开启协议解析</div><div class="line">    &apos;package_length_type&apos;   =&gt; &apos;N&apos;,     // 长度字段的类型</div><div class="line">    &apos;package_length_offset&apos; =&gt; 0,       //第几个字节是包长度的值</div><div class="line">    &apos;package_body_offset&apos;   =&gt; 4,       //第几个字节开始计算长度</div><div class="line">    &apos;package_max_length&apos;    =&gt; 81920,  //协议最大长度</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>数据处理部分为这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public function onReceive($serv, $fd, $fromId, $data)</div><div class="line">&#123;</div><div class="line">    $info = unpack(&apos;N&apos;, $data);</div><div class="line">    $len = $info[1];</div><div class="line">    $body = substr($data, - $len);</div><div class="line">    echo &quot;server received data: &#123;$body&#125;\n&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完成这些，这种方案就算完成了。</p>
<h4 id="package-length-type-长度值的类型"><a href="#package-length-type-长度值的类型" class="headerlink" title="package_length_type 长度值的类型"></a>package_length_type 长度值的类型</h4><p>长度值的类型，接受一个字符参数，与php的pack函数一致。目前swoole支持10种类型：</p>
<ul>
<li>c：有符号、1字节</li>
<li>C：无符号、1字节</li>
<li>s ：有符号、主机字节序、2字节</li>
<li>S：无符号、主机字节序、2字节</li>
<li>n：无符号、网络字节序、2字节 (常用)</li>
<li>N：无符号、网络字节序、4字节 (常用)</li>
<li>l：有符号、主机字节序、4字节（小写L）</li>
<li>L：无符号、主机字节序、4字节（大写L）</li>
<li>v：无符号、小端字节序、2字节</li>
<li>V：无符号、小端字节序、4字节</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在跟硬件开发的小伙伴测试的时候发现了一个非常有趣的问题，即Client 每次请求，Server 端我返回相同信息，但是有时候会出现两次或多次返回的数据堆叠到一起的现象。开始我还以为我代码写的有问题，仔细看了一下代码没问题啊，终究还是要相信科学。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>lantern 运行时关闭终端</title>
    <link href="http://www.iooeo.com/2017/08/03/lantern-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%85%B3%E9%97%AD%E7%BB%88%E7%AB%AF/"/>
    <id>http://www.iooeo.com/2017/08/03/lantern-运行时关闭终端/</id>
    <published>2017-08-03T03:34:39.000Z</published>
    <updated>2017-08-03T03:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇 Mac 上破解 lantern 的文章<a href="http://www.iooeo.com/2017/07/07/lantern-Mac%E7%89%88%E7%BC%96%E8%AF%91-%E5%85%8D%E8%B4%B9/">lantern Mac版编译 无限流量</a>。小伙伴胖佳说可以运行了，但是有个终端会一直开着，关闭掉以后 lantern 就终止执行了，也就不能翻墙了，今天想到了一个办法。<br><a id="more"></a><br>接着上篇文章继续，Mac上搜索一下lantern_darwin_amd64,双击打开以后，会出现一个终端，上边不停的有各种信息出现，此时我们是可以正常使用的。<br>但是一直开着个终端，有点不爽，首先我们把 lantern 执行终端滚到最上边会看到一下命令：<br><img src="http://ogpq2zwg5.bkt.clouddn.com/lantern%20%E6%89%A7%E8%A1%8C%E7%BB%88%E7%AB%AF.png" alt="lantern 执行终端"><br>其实我们就是想要<code>lantern_darwin_amd64</code>文件路径，然后你的<code>.bash_profile</code>或者<code>.profile</code>中添加以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias lantern=&apos;/Users/yangyiyuan/projects/landeng/lantern/lantern_darwin_amd64 &amp; exit&apos;</div></pre></td></tr></table></figure></p>
<p>将上边的文件路径换成你自己的就可以了，然后终端执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source .bash_profile</div></pre></td></tr></table></figure></p>
<p>这样就可以了，以后我们要启动蓝灯，直接打开终端执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lantern</div></pre></td></tr></table></figure></p>
<p>然后关闭窗口就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇 Mac 上破解 lantern 的文章&lt;a href=&quot;http://www.iooeo.com/2017/07/07/lantern-Mac%E7%89%88%E7%BC%96%E8%AF%91-%E5%85%8D%E8%B4%B9/&quot;&gt;lantern Mac版编译 无限流量&lt;/a&gt;。小伙伴胖佳说可以运行了，但是有个终端会一直开着，关闭掉以后 lantern 就终止执行了，也就不能翻墙了，今天想到了一个办法。&lt;br&gt;
    
    </summary>
    
      <category term="Mac" scheme="http://www.iooeo.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://www.iooeo.com/tags/Mac/"/>
    
      <category term="lantern" scheme="http://www.iooeo.com/tags/lantern/"/>
    
      <category term="VPN" scheme="http://www.iooeo.com/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>swoole 进程守护 日志保存</title>
    <link href="http://www.iooeo.com/2017/08/03/swoole-%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4-%E6%97%A5%E5%BF%97%E4%BF%9D%E5%AD%98/"/>
    <id>http://www.iooeo.com/2017/08/03/swoole-进程守护-日志保存/</id>
    <published>2017-08-03T02:56:59.000Z</published>
    <updated>2017-08-03T06:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>前边我已经学会了 Swoole 的 Server 和 Client，也用他们做了不同压力测试、并发测试等等。但是终究离应用到实际项目还差一步，因为没有开启进程守护，只要我的终端关掉了，程序也就中断执行了。<br><a id="more"></a><br>其实在写这篇之前，不依赖 Swoole 为我们提供的方法，如果 Linux 算熟悉的话，自己也能想到办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ php server.php &gt; server_log.log &amp;</div></pre></td></tr></table></figure></p>
<h2 id="进程守护-日志保存"><a href="#进程守护-日志保存" class="headerlink" title="进程守护 日志保存"></a>进程守护 日志保存</h2><p>但是既然 Swoole 给提供了，那我们就开看一下怎么用的吧。<br>将<code>daemonize</code>设置为<code>true</code>时，程序将转入后台作为守护进程运行。长时间运行的服务器端程序必须启用此项。如果不启用守护进程，当ssh终端退出后，程序将被终止运行。</p>
<ul>
<li>启用守护进程后，标准输入和输出会被重定向到 log_file</li>
<li>如果未设置log_file，将重定向到 /dev/null，所有打印屏幕的信息都会被丢弃</li>
</ul>
<p>代码实现，只要将我们之前讲过的 server 配置添加<code>daemonize</code> 和<code>log_file</code>即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">    &apos;worker_num&apos; =&gt; 1,</div><div class="line">    &apos;daemonize&apos; =&gt; true,</div><div class="line">    &apos;log_file&apos; =&gt; __DIR__ . &apos;/server.log&apos;</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>设置好以后，确认是够已经成功进行进程守护，可使用命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep server.php</div><div class="line">yangyiyuan       92904   0.0  0.0  2491660   2280   ??  S    10:54上午   0:00.00 php server.php</div><div class="line">yangyiyuan       92861   0.0  0.0  2491052   1596   ??  S    10:54上午   0:00.00 php server.php</div><div class="line">yangyiyuan       92857   0.0  0.0  2492280   1860   ??  Ss   10:54上午   0:00.27 php server.php</div><div class="line">yangyiyuan       98783   0.0  0.0  2423392    600 s001  R+    1:52下午   0:00.00 grep server.php</div></pre></td></tr></table></figure></p>
<p>此时执行我们的客户端文件，将会有日志输出到<code>server.log</code>文件中。</p>
<h2 id="重启进程"><a href="#重启进程" class="headerlink" title="重启进程"></a>重启进程</h2><p>一台繁忙的后端服务器随时都在处理请求，如果管理员通过kill进程方式来终止/重启服务器程序，可能导致刚好代码执行到一半终止。<br>这种情况下会产生数据的不一致。如交易系统中，支付逻辑的下一段是发货，假设在支付逻辑之后进程被终止了。会导致用户支付了货币，但并没有发货，后果非常严重。<br>Swoole提供了柔性终止/重启的机制，管理员只需要向<code>SwooleServer</code>发送特定的信号，Server的worker进程可以安全的结束。</p>
<ul>
<li><code>SIGTERM</code>: 向主进程/管理进程发送此信号服务器将安全终止,在PHP代码中可以调用<code>$serv-&gt;shutdown()</code>完成此操作</li>
<li><code>SIGUSR1</code>: 向主进程/管理进程发送<code>SIGUSR1</code>信号，将平稳地<code>restart</code>所有<code>worker</code>进程,在PHP代码中可以调用<code>$serv-&gt;reload()</code>完成此操作</li>
<li>swoole的<code>reload</code>有保护机制，当一次reload正在进行时，收到新的重启信号会丢弃</li>
<li>如果设置了user/group，Worker进程可能没有权限向master进程发送信息，这种情况下必须使用root账户，在shell中执行kill指令进行重启</li>
<li><code>reload</code>指令对<code>addProcess</code>添加的用户进程无效</li>
</ul>
<p>终端重启所有worker进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kill -USR1 主进程PID</div></pre></td></tr></table></figure></p>
<p>终端仅重启task进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kill -USR2 主进程PID</div></pre></td></tr></table></figure></p>
<p>注意事项：</p>
<blockquote>
<p>平滑重启只对onWorkerStart或onReceive等在Worker进程中include/require的PHP文件有效，Server启动前就已经include/require的PHP文件，不能通过平滑重启重新加载<br>对于Server的配置即$serv-&gt;set()中传入的参数设置，必须关闭/重启整个Server才可以重新加载<br>Server可以监听一个内网端口，然后可以接收远程的控制命令，去重启所有worker</p>
</blockquote>
<p>Reload有效范围：<br>Reload操作只能重新载入Worker进程启动后加载的PHP文件，建议使用get_included_files函数来列出哪些文件是在WorkerStart之前就加载的PHP文件，在此列表中的PHP文件，即使进行了reload操作也无法重新载入。比如要关闭服务器重新启动才能生效。<br>WorkerStart之前就加载的PHP文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;WorkerStart&apos;, function($serv, $workerId) &#123;</div><div class="line">    var_dump(get_included_files()); //此数组中的文件表示进程启动前就加载了，所以无法reload</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>重启无效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">require_once &apos;./Test.php&apos;;</div><div class="line">class Server&#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重启有效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;WorkerStart&apos;, function($serv, $workerId) &#123;</div><div class="line">        require_once(&quot;Test.php&quot;); //此处 Test.php重启有效</div><div class="line">        $this-&gt;_test = new Test;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前边我已经学会了 Swoole 的 Server 和 Client，也用他们做了不同压力测试、并发测试等等。但是终究离应用到实际项目还差一步，因为没有开启进程守护，只要我的终端关掉了，程序也就中断执行了。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole Worker进程</title>
    <link href="http://www.iooeo.com/2017/08/01/swoole-Worker%E8%BF%9B%E7%A8%8B/"/>
    <id>http://www.iooeo.com/2017/08/01/swoole-Worker进程/</id>
    <published>2017-08-01T07:46:55.000Z</published>
    <updated>2017-08-01T08:16:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在文章之前先看两张图片，试着去理解一下Swoole Server运行流程和进程/线程结构.<br><a id="more"></a></p>
<h2 id="运行流程图"><a href="#运行流程图" class="headerlink" title="运行流程图"></a>运行流程图</h2><p><img src="http://ogpq2zwg5.bkt.clouddn.com/swoole.jpg" alt="运行流程图"></p>
<h2 id="进程-线程结构图"><a href="#进程-线程结构图" class="headerlink" title="进程/线程结构图"></a>进程/线程结构图</h2><p><img src="http://ogpq2zwg5.bkt.clouddn.com/process.jpg" alt="进程/线程结构图"><br>为了能更好的理解Swoole Server 的运行流程，下面我们创一个简单的实例<em>server-process.php</em>配合上面的图片进行讲解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$serv = new swoole_server(&apos;127.0.0.1&apos;, 9501);</div><div class="line">$serv-&gt;set([</div><div class="line">    &apos;worker_num&apos; =&gt; 2,</div><div class="line">    &apos;task_worker_num&apos; =&gt; 1,</div><div class="line">]);</div><div class="line">$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123;</div><div class="line">&#125;);</div><div class="line">$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123;</div><div class="line">&#125;);</div><div class="line">$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123;</div><div class="line">&#125;);</div><div class="line">$serv-&gt;on(&apos;Task&apos;, function ($serv, $taskId, $fromId, $data) &#123;</div><div class="line">&#125;);</div><div class="line">$serv-&gt;on(&apos;Finish&apos;, function ($serv, $taskId, $data) &#123;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$serv-&gt;start();</div></pre></td></tr></table></figure></p>
<p>然后执行 ps 命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep server-process</div><div class="line">root     21843  xxx... php server-process.php</div><div class="line">root     21844  xxx... php server-process.php</div><div class="line">root     21846  xxx... php server-process.php</div><div class="line">root     21847  xxx... php server-process.php</div><div class="line">root     21848  xxx... php server-process.php</div><div class="line">root     21854  xxx... grep --color=auto server-process</div></pre></td></tr></table></figure></p>
<p>排除掉 grep 那条，一共有5条。<br>相比<em>Master-Worker</em>模式，swoole 的进程模型可以用<em>Master-Manager-Worker</em>来形容。即在<em>Master-Worker</em>的基础上又增加了一层Manager进程。</p>
<ul>
<li>1个 Master 进程</li>
<li>1个 Manager 进程    </li>
<li>2个 Worker 进程</li>
<li>1个 Task 进程</li>
</ul>
<p>Swoole 是一个多进程模式的框架（可以类比Nginx的进程模型），当启动一个Swoole应用时，一共会创建2 + n + m个进程，其中n为 Worker 进程数，m为TaskWorker进程数，2为一个 Master 进程和一个 Manager 进程，它们之间的关系如下图所示。<br><img src="http://ogpq2zwg5.bkt.clouddn.com/structure.png" alt="swoole 进程模型"><br>其中，Master进程为主进程，该进程会创建Manager进程、Reactor线程等工作进/线程。</p>
<ul>
<li>Reactor线程实际运行epoll实例，用于accept客户端连接以及接收客户端数据；</li>
<li>Manager进程为管理进程，该进程的作用是创建、管理所有的Worker进程和TaskWorker进程。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在文章之前先看两张图片，试着去理解一下Swoole Server运行流程和进程/线程结构.&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole Task Worker 篇</title>
    <link href="http://www.iooeo.com/2017/08/01/swoole-Task-Worker-%E7%AF%87/"/>
    <id>http://www.iooeo.com/2017/08/01/swoole-Task-Worker-篇/</id>
    <published>2017-08-01T06:51:52.000Z</published>
    <updated>2017-08-01T07:39:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>swoole_server-&gt;task</code>投递一个异步任务到 task_worker 池中。此函数是非阻塞的，执行完毕会立即返回。Worker 进程可以继续处理新的请求。使用Task功能，必须先设置 <em>task_worker_num</em>，并且必须设置 Server 的 <em>onTask</em> 和 <em>onFinish </em>事件回调函数。<br><a id="more"></a><br>注意事项：</p>
<ul>
<li>使用 task 必须为 Server 设置 <em>onTask</em> 和 <em>onFinish</em> 回调，否则 <code>swoole_server-&gt;start</code> 会失败</li>
<li>task 操作的次数必须小于 <em>onTask</em> 处理速度，如果投递容量超过处理能力，task 会塞满缓存区，导致 worker 进程发生阻塞。worker 进程将无法接收新的请求</li>
<li>使用 <em>addProcess</em> 添加的用户进程中无法使用 task 投递任务，请使用 <em>sendMessage</em> 接口与 Task 工作进程通信</li>
</ul>
<h2 id="Task-实例"><a href="#Task-实例" class="headerlink" title="Task 实例"></a>Task 实例</h2><h3 id="创建-Server"><a href="#创建-Server" class="headerlink" title="创建 Server"></a>创建 Server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501);</div></pre></td></tr></table></figure>
<h3 id="设置task-worker-num"><a href="#设置task-worker-num" class="headerlink" title="设置task_worker_num"></a>设置<em>task_worker_num</em></h3><p>设置<em>task_worker_num</em>是我们使用 task 中不可缺少的一点哦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">	&apos;worker_num&apos; =&gt; 2,</div><div class="line">	&apos;task_worker_num&apos; =&gt; 1,</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<h3 id="客户端链接回调"><a href="#客户端链接回调" class="headerlink" title="客户端链接回调"></a>客户端链接回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;new client connected.\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="接受客户端数据，使用-task"><a href="#接受客户端数据，使用-task" class="headerlink" title="接受客户端数据，使用 task"></a>接受客户端数据，使用 task</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123;</div><div class="line">    echo &quot;worker received data: &#123;$data&#125;\n&quot;;</div><div class="line">    // 投递一个任务到task进程中</div><div class="line">    $serv-&gt;task($data);</div><div class="line">    // 通知客户端server收到数据了</div><div class="line">    $serv-&gt;send($fd, &apos;This is a message from server.&apos;);</div><div class="line">    // 为了校验task是否是异步的，这里和task进程内都输出内容，看看谁先输出</div><div class="line">    echo &quot;worker continue run.\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="设置-Server-的-onTask-和-onFinish-事件回调函数"><a href="#设置-Server-的-onTask-和-onFinish-事件回调函数" class="headerlink" title="设置 Server 的 onTask 和 onFinish 事件回调函数"></a>设置 Server 的 <em>onTask</em> 和 <em>onFinish </em>事件回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * $serv swoole_server</div><div class="line"> * $taskId 投递的任务id,因为task进程是由worker进程发起，所以多worker多task下，该值可能会相同</div><div class="line"> * $fromId 来自那个worker进程的id</div><div class="line"> * $data 要投递的任务数据</div><div class="line"> */</div><div class="line">$serv-&gt;on(&apos;Task&apos;, function ($serv, $taskId, $fromId, $data) &#123;</div><div class="line">    echo &quot;task start. --- from worker id: &#123;$fromId&#125;.\n&quot;;</div><div class="line">    for ($i=0; $i &lt; 5; $i++) &#123; </div><div class="line">        sleep(1);</div><div class="line">        echo &quot;task runing. --- &#123;$i&#125;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    return &quot;task end&quot;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 只有在task进程中调用了finish方法或者return了结果，才会触发finish</div><div class="line"> */</div><div class="line">$serv-&gt;on(&apos;Finish&apos;, function ($serv, $taskId, $data) &#123;</div><div class="line">    echo &quot;finish received data &apos;&#123;$data&#125;&apos;\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;Client &#123;$fd&#125; close connection\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;start();</div></pre></td></tr></table></figure>
<p>客户端还是用我们上一篇<a href="http://www.iooeo.com/2017/08/01/swoole-%E5%88%9D%E8%AF%86-%E7%AE%80%E5%8D%95%E7%9A%84-Server-Client/">简单的Server Client</a>中的client.php。<br>执行查看 client 结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ php client.php </div><div class="line">This is a message from server.</div></pre></td></tr></table></figure></p>
<p>执行查看 server 结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ php index.php </div><div class="line">new client connected.</div><div class="line">Get Message From Client 1:hello server.</div><div class="line">worker continue run.</div><div class="line">task start. --- from worker id: 3.</div><div class="line">Client 1 close connection</div><div class="line">task runing. --- 0</div><div class="line">task runing. --- 1</div><div class="line">task runing. --- 2</div><div class="line">task runing. --- 3</div><div class="line">task runing. --- 4</div><div class="line">finish received data &apos;task end&apos;</div></pre></td></tr></table></figure></p>
<p>从上边 server 执行的结果可以看出，task执行已经在 close 之后了，这样就知道什么是异步任务了吧。<br>总结一下应用场景：</p>
<ul>
<li>没有耗时任务的情况下，worker直接运行，无需开启task</li>
<li>对于耗时的任务，可以在worker内调用task函数，把异步任务投递给task进程进行处理，task进程的数量取决于task_worker_num的配置</li>
<li>task进程内可以选择调用finish方法或者return，来通知worker进程此任务已完成，worker进程会在onFinish回调中对task的执行结果进一步处理。如果worker进程不关心任务的结果，finish就不需要做处理了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;swoole_server-&amp;gt;task&lt;/code&gt;投递一个异步任务到 task_worker 池中。此函数是非阻塞的，执行完毕会立即返回。Worker 进程可以继续处理新的请求。使用Task功能，必须先设置 &lt;em&gt;task_worker_num&lt;/em&gt;，并且必须设置 Server 的 &lt;em&gt;onTask&lt;/em&gt; 和 &lt;em&gt;onFinish &lt;/em&gt;事件回调函数。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole 初识 简单的 Server Client</title>
    <link href="http://www.iooeo.com/2017/08/01/swoole-%E5%88%9D%E8%AF%86-%E7%AE%80%E5%8D%95%E7%9A%84-Server-Client/"/>
    <id>http://www.iooeo.com/2017/08/01/swoole-初识-简单的-Server-Client/</id>
    <published>2017-08-01T03:21:13.000Z</published>
    <updated>2017-08-01T06:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了学 Swoole，我们在开始之前已经普及了很多的知识，这篇我们就要上手玩一把 Swoole，是不是感觉有点手痒了。。<br><a id="more"></a><br>前边几篇分别记录了：</p>
<ul>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AF%87/">进程与线程</a></li>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-I-O-%E6%A8%A1%E5%9E%8B/">I/O 模型</a></li>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E7%AF%87/">网络通讯协议</a></li>
<li><a href="http://www.iooeo.com/2017/08/01/swoole-Socket%E7%AF%87/">socket</a></li>
</ul>
<p>都是一些简单的网路基础知识，不过这些最好要牢记。<br>然后就是 Swoole 扩展的安装：</p>
<ul>
<li><a href="http://www.iooeo.com/2017/07/31/swoole-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%AF%87/">Swoole 扩展安装</a></li>
</ul>
<h2 id="Swoole-server"><a href="#Swoole-server" class="headerlink" title="Swoole server"></a>Swoole server</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>server 的创建其实非常简单，只需要我们在安装好扩展的基础上，实现以下代码就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// $serv = new swoole_server(string $host, int $port, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP);</div><div class="line">$serv = new swoole_server(&apos;127.0.0.1&apos;, 9501);</div></pre></td></tr></table></figure></p>
<p>swoole_server 类的构造函数一共有四个参数，上面我们填写了两个 ，还有两个有默认值，不填也可。<br>swoole_server构造函数</p>
<ul>
<li>@param     $host         // 监听的 IP</li>
<li>@param     $port        // 监听的端口</li>
<li>@param int $mode        // 运行模式，swoole提供了3种运行模式，默认为SWOOLE_PROCESS多进程模式</li>
<li>@param int $sock_type    // Socket的类型,支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种，默认为SWOOLE_SOCK_TCP TCP 类型</li>
</ul>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p><code>swoole_server-&gt;set()</code>函数用于设置swoole_server运行时的各项参数。服务器启动后通过$serv-&gt;setting来访问set函数设置的参数数组。<br>具体有哪些设置，我们后边慢慢学习，现在我们先实现一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;set([</div><div class="line">    &apos;worker_num&apos; =&gt; 2,</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>worker_num 设置启动的worker进程数量。swoole采用固定worker进程的模式。<br>PHP代码中是全异步非阻塞，worker_num配置为CPU核数的1-4倍即可。如果是同步阻塞，worker_num配置为100或者更高，具体要看每次请求处理的耗时和操作系统负载状况。</p>
<h3 id="事件回调函数"><a href="#事件回调函数" class="headerlink" title="事件回调函数"></a>事件回调函数</h3><p><code>swoole_server-&gt;on()</code>注册Server的事件回调函数。</p>
<ul>
<li>第1个参数是回调的名称, 大小写不敏感，具体内容参考回调函数列表，事件名称字符串不要加on</li>
<li>第2个函数是回调的PHP函数，可以是函数名的字符串，类静态方法，对象方法数组，匿名函数</li>
</ul>
<p>有新的客户端连接时，worker进程内会触发该回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Connect&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;new client connected.\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>server接收到客户端的数据后，worker进程内触发该回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Receive&apos;, function ($serv, $fd, $fromId, $data) &#123;</div><div class="line">    echo &quot;Get Message From Client &#123;$fd&#125;:&#123;$data&#125;\n&quot;;</div><div class="line">    $serv-&gt;send($fd, $data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>客户端断开连接或者server主动关闭连接时 worker进程内调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;on(&apos;Close&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;Client &#123;$fd&#125; close connection\n&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="启动server"><a href="#启动server" class="headerlink" title="启动server"></a>启动server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$serv-&gt;start();</div></pre></td></tr></table></figure>
<h2 id="Swoole-Client"><a href="#Swoole-Client" class="headerlink" title="Swoole Client"></a>Swoole Client</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>client 的创建一样非常简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$client = new swoole_client(SWOOLE_SOCK_TCP);</div></pre></td></tr></table></figure></p>
<p>swoole_client 类的构造函数一共有三个参数。<br>swoole_client构造函数</p>
<ul>
<li>@param int $sock_type 指定socket的类型，支持TCP/UDP、TCP6/UDP6 4种</li>
<li>@param int $sync_type SWOOLE_SOCK_SYNC/SWOOLE_SOCK_ASYNC  同步/异步</li>
<li>@param string $connectionKey 链接的编号，用于长连接复用</li>
</ul>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$client-&gt;connect(&apos;127.0.0.1&apos;, 9501) || exit(&quot;connect failed. Error: &#123;$client-&gt;errCode&#125;\n&quot;);</div></pre></td></tr></table></figure>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$client-&gt;send(&quot;hello server.&quot;);</div></pre></td></tr></table></figure>
<h3 id="从服务端接收数据"><a href="#从服务端接收数据" class="headerlink" title="从服务端接收数据"></a>从服务端接收数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$response = $client-&gt;recv();</div></pre></td></tr></table></figure>
<h3 id="输出接受到的数据"><a href="#输出接受到的数据" class="headerlink" title="输出接受到的数据"></a>输出接受到的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $response . PHP_EOL;</div></pre></td></tr></table></figure>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$client-&gt;close();</div></pre></td></tr></table></figure>
<h2 id="Server-和-Client-通讯"><a href="#Server-和-Client-通讯" class="headerlink" title="Server 和 Client 通讯"></a>Server 和 Client 通讯</h2><p>终端执行命令，将 server 挂起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ php server.php</div></pre></td></tr></table></figure></p>
<p>打开新的终端执行 client 程序，在此之前你可以使用一下命令查看 server 监听的9501端口的监听情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ netstat -an | grep 9501</div><div class="line">tcp4       0      0  127.0.0.1.9501         *.*                    LISTEN</div></pre></td></tr></table></figure></p>
<p>从上边可以看到一些状态<em>tcp4</em>、<em>LISTEN</em>等关键信息<br>执行 client 代码程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ php client.php </div><div class="line">hello server.</div></pre></td></tr></table></figure></p>
<p>运行 server的终端会显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ php server.php </div><div class="line">new client connected.</div><div class="line">Get Message From Client 1:hello server.</div><div class="line">Client 1 close connection</div></pre></td></tr></table></figure></p>
<blockquote>
<p>到这个地方我们已经简单的实现了 Swoole Server 和 Client 的链接通讯。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了学 Swoole，我们在开始之前已经普及了很多的知识，这篇我们就要上手玩一把 Swoole，是不是感觉有点手痒了。。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>swoole Socket篇</title>
    <link href="http://www.iooeo.com/2017/08/01/swoole-Socket%E7%AF%87/"/>
    <id>http://www.iooeo.com/2017/08/01/swoole-Socket篇/</id>
    <published>2017-08-01T02:50:21.000Z</published>
    <updated>2017-08-01T03:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 PHP socket 的使用，我在之前的工作中使用过一些，自己也动手封装了关于 socket server 和 socket client 的类库，已共享到 GitHub 和码云上面：<br><a id="more"></a></p>
<ul>
<li><a href="https://github.com/yangyiyuan/simple-socket/tree/master" target="_blank" rel="external">Github PHP simple-socket</a></li>
<li><a href="https://gitee.com/ewan.yang/simple-socket" target="_blank" rel="external">Oschina PHP simple-socket</a></li>
</ul>
<p>当然也有更好的例如 workerman 之类的 socket 开源项目。<br>但 socket 对于大部分 phper还是比较陌生的一个词语，百度上给出大部分网文关键字都是<em>套接字</em>，比较抽象难懂一些。<br>socket即套接字，是用来与另一个进程进行跨网络通信的文件，说是“文件”，也很好理解哈，因为在linux中一切都可以理解为“文件”。比如客户端可以借助socket与服务器之间建立连接。你也可以把socket理解为一组函数库，它确实也就是一堆函数。<br>我们知道，常见的网络应用都是基于Client-Server模型的。即一个服务器进程和多个客户端进程组合而成，如果你还理解为是一台电脑对另一台电脑，可以回去把进程/线程一文再看看了。在Client-Server模型中，服务器管理某种资源，并且通过对它管理的资源进行操作来为客户端提供服务。<br>那Client和Server又如何实现通信呢？这就要利用socket一系列的函数实现了。<br>基于套接字接口的网络应用的描述，用下面这张图来理解就好。<br><img src="http://ogpq2zwg5.bkt.clouddn.com/217f4d714f-socket-client-server.png" alt="套接字接口的网络应用的描述"></p>
<p>大致可以描述为：</p>
<blockquote>
<p>服务器创建一个socket，绑定ip和端口，在该端口处进行监听，然后通过accept函数阻塞。<br>当有新的客户端连接进来时，server接收客户端数据并处理数据，然后返回给客户端，客户端关闭连接，server关闭该客户端，一次连接交互完成。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 PHP socket 的使用，我在之前的工作中使用过一些，自己也动手封装了关于 socket server 和 socket client 的类库，已共享到 GitHub 和码云上面：&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.iooeo.com/categories/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/categories/PHP/Swoole/"/>
    
    
      <category term="PHP" scheme="http://www.iooeo.com/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://www.iooeo.com/tags/Swoole/"/>
    
  </entry>
  
</feed>
